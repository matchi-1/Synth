{"ast":null,"code":"/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactEventListener\n * @typechecks static-only\n */\n\n'use strict';\n\nvar EventListener = require(\"./EventListener\");\nvar ExecutionEnvironment = require(\"./ExecutionEnvironment\");\nvar PooledClass = require(\"./PooledClass\");\nvar ReactInstanceHandles = require(\"./ReactInstanceHandles\");\nvar ReactMount = require(\"./ReactMount\");\nvar ReactUpdates = require(\"./ReactUpdates\");\nvar assign = require(\"./Object.assign\");\nvar getEventTarget = require(\"./getEventTarget\");\nvar getUnboundedScrollPosition = require(\"./getUnboundedScrollPosition\");\n\n/**\n * Finds the parent React component of `node`.\n *\n * @param {*} node\n * @return {?DOMEventTarget} Parent container, or `null` if the specified node\n *                           is not nested.\n */\nfunction findParent(node) {\n  // TODO: It may be a good idea to cache this to prevent unnecessary DOM\n  // traversal, but caching is difficult to do correctly without using a\n  // mutation observer to listen for all DOM changes.\n  var nodeID = ReactMount.getID(node);\n  var rootID = ReactInstanceHandles.getReactRootIDFromNodeID(nodeID);\n  var container = ReactMount.findReactContainerForID(rootID);\n  var parent = ReactMount.getFirstReactDOM(container);\n  return parent;\n}\n\n// Used to store ancestor hierarchy in top level callback\nfunction TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {\n  this.topLevelType = topLevelType;\n  this.nativeEvent = nativeEvent;\n  this.ancestors = [];\n}\nassign(TopLevelCallbackBookKeeping.prototype, {\n  destructor: function () {\n    this.topLevelType = null;\n    this.nativeEvent = null;\n    this.ancestors.length = 0;\n  }\n});\nPooledClass.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass.twoArgumentPooler);\nfunction handleTopLevelImpl(bookKeeping) {\n  var topLevelTarget = ReactMount.getFirstReactDOM(getEventTarget(bookKeeping.nativeEvent)) || window;\n\n  // Loop through the hierarchy, in case there's any nested components.\n  // It's important that we build the array of ancestors before calling any\n  // event handlers, because event handlers can modify the DOM, leading to\n  // inconsistencies with ReactMount's node cache. See #1105.\n  var ancestor = topLevelTarget;\n  while (ancestor) {\n    bookKeeping.ancestors.push(ancestor);\n    ancestor = findParent(ancestor);\n  }\n  for (var i = 0, l = bookKeeping.ancestors.length; i < l; i++) {\n    topLevelTarget = bookKeeping.ancestors[i];\n    var topLevelTargetID = ReactMount.getID(topLevelTarget) || '';\n    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, topLevelTarget, topLevelTargetID, bookKeeping.nativeEvent);\n  }\n}\nfunction scrollValueMonitor(cb) {\n  var scrollPosition = getUnboundedScrollPosition(window);\n  cb(scrollPosition);\n}\nvar ReactEventListener = {\n  _enabled: true,\n  _handleTopLevel: null,\n  WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,\n  setHandleTopLevel: function (handleTopLevel) {\n    ReactEventListener._handleTopLevel = handleTopLevel;\n  },\n  setEnabled: function (enabled) {\n    ReactEventListener._enabled = !!enabled;\n  },\n  isEnabled: function () {\n    return ReactEventListener._enabled;\n  },\n  /**\n   * Traps top-level events by using event bubbling.\n   *\n   * @param {string} topLevelType Record from `EventConstants`.\n   * @param {string} handlerBaseName Event name (e.g. \"click\").\n   * @param {object} handle Element on which to attach listener.\n   * @return {object} An object with a remove function which will forcefully\n   *                  remove the listener.\n   * @internal\n   */\n  trapBubbledEvent: function (topLevelType, handlerBaseName, handle) {\n    var element = handle;\n    if (!element) {\n      return null;\n    }\n    return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));\n  },\n  /**\n   * Traps a top-level event by using event capturing.\n   *\n   * @param {string} topLevelType Record from `EventConstants`.\n   * @param {string} handlerBaseName Event name (e.g. \"click\").\n   * @param {object} handle Element on which to attach listener.\n   * @return {object} An object with a remove function which will forcefully\n   *                  remove the listener.\n   * @internal\n   */\n  trapCapturedEvent: function (topLevelType, handlerBaseName, handle) {\n    var element = handle;\n    if (!element) {\n      return null;\n    }\n    return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));\n  },\n  monitorScrollValue: function (refresh) {\n    var callback = scrollValueMonitor.bind(null, refresh);\n    EventListener.listen(window, 'scroll', callback);\n  },\n  dispatchEvent: function (topLevelType, nativeEvent) {\n    if (!ReactEventListener._enabled) {\n      return;\n    }\n    var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);\n    try {\n      // Event queue being processed in the same cycle allows\n      // `preventDefault`.\n      ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);\n    } finally {\n      TopLevelCallbackBookKeeping.release(bookKeeping);\n    }\n  }\n};\nmodule.exports = ReactEventListener;","map":{"version":3,"names":["EventListener","require","ExecutionEnvironment","PooledClass","ReactInstanceHandles","ReactMount","ReactUpdates","assign","getEventTarget","getUnboundedScrollPosition","findParent","node","nodeID","getID","rootID","getReactRootIDFromNodeID","container","findReactContainerForID","parent","getFirstReactDOM","TopLevelCallbackBookKeeping","topLevelType","nativeEvent","ancestors","prototype","destructor","length","addPoolingTo","twoArgumentPooler","handleTopLevelImpl","bookKeeping","topLevelTarget","window","ancestor","push","i","l","topLevelTargetID","ReactEventListener","_handleTopLevel","scrollValueMonitor","cb","scrollPosition","_enabled","WINDOW_HANDLE","canUseDOM","setHandleTopLevel","handleTopLevel","setEnabled","enabled","isEnabled","trapBubbledEvent","handlerBaseName","handle","element","listen","dispatchEvent","bind","trapCapturedEvent","capture","monitorScrollValue","refresh","callback","getPooled","batchedUpdates","release","module","exports"],"sources":["C:/Users/raffy/Desktop/test/Synth/Synth/node_modules/react-embedded-browser/node_modules/react/lib/ReactEventListener.js"],"sourcesContent":["/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactEventListener\n * @typechecks static-only\n */\n\n'use strict';\n\nvar EventListener = require(\"./EventListener\");\nvar ExecutionEnvironment = require(\"./ExecutionEnvironment\");\nvar PooledClass = require(\"./PooledClass\");\nvar ReactInstanceHandles = require(\"./ReactInstanceHandles\");\nvar ReactMount = require(\"./ReactMount\");\nvar ReactUpdates = require(\"./ReactUpdates\");\n\nvar assign = require(\"./Object.assign\");\nvar getEventTarget = require(\"./getEventTarget\");\nvar getUnboundedScrollPosition = require(\"./getUnboundedScrollPosition\");\n\n/**\n * Finds the parent React component of `node`.\n *\n * @param {*} node\n * @return {?DOMEventTarget} Parent container, or `null` if the specified node\n *                           is not nested.\n */\nfunction findParent(node) {\n  // TODO: It may be a good idea to cache this to prevent unnecessary DOM\n  // traversal, but caching is difficult to do correctly without using a\n  // mutation observer to listen for all DOM changes.\n  var nodeID = ReactMount.getID(node);\n  var rootID = ReactInstanceHandles.getReactRootIDFromNodeID(nodeID);\n  var container = ReactMount.findReactContainerForID(rootID);\n  var parent = ReactMount.getFirstReactDOM(container);\n  return parent;\n}\n\n// Used to store ancestor hierarchy in top level callback\nfunction TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {\n  this.topLevelType = topLevelType;\n  this.nativeEvent = nativeEvent;\n  this.ancestors = [];\n}\nassign(TopLevelCallbackBookKeeping.prototype, {\n  destructor: function() {\n    this.topLevelType = null;\n    this.nativeEvent = null;\n    this.ancestors.length = 0;\n  }\n});\nPooledClass.addPoolingTo(\n  TopLevelCallbackBookKeeping,\n  PooledClass.twoArgumentPooler\n);\n\nfunction handleTopLevelImpl(bookKeeping) {\n  var topLevelTarget = ReactMount.getFirstReactDOM(\n    getEventTarget(bookKeeping.nativeEvent)\n  ) || window;\n\n  // Loop through the hierarchy, in case there's any nested components.\n  // It's important that we build the array of ancestors before calling any\n  // event handlers, because event handlers can modify the DOM, leading to\n  // inconsistencies with ReactMount's node cache. See #1105.\n  var ancestor = topLevelTarget;\n  while (ancestor) {\n    bookKeeping.ancestors.push(ancestor);\n    ancestor = findParent(ancestor);\n  }\n\n  for (var i = 0, l = bookKeeping.ancestors.length; i < l; i++) {\n    topLevelTarget = bookKeeping.ancestors[i];\n    var topLevelTargetID = ReactMount.getID(topLevelTarget) || '';\n    ReactEventListener._handleTopLevel(\n      bookKeeping.topLevelType,\n      topLevelTarget,\n      topLevelTargetID,\n      bookKeeping.nativeEvent\n    );\n  }\n}\n\nfunction scrollValueMonitor(cb) {\n  var scrollPosition = getUnboundedScrollPosition(window);\n  cb(scrollPosition);\n}\n\nvar ReactEventListener = {\n  _enabled: true,\n  _handleTopLevel: null,\n\n  WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,\n\n  setHandleTopLevel: function(handleTopLevel) {\n    ReactEventListener._handleTopLevel = handleTopLevel;\n  },\n\n  setEnabled: function(enabled) {\n    ReactEventListener._enabled = !!enabled;\n  },\n\n  isEnabled: function() {\n    return ReactEventListener._enabled;\n  },\n\n\n  /**\n   * Traps top-level events by using event bubbling.\n   *\n   * @param {string} topLevelType Record from `EventConstants`.\n   * @param {string} handlerBaseName Event name (e.g. \"click\").\n   * @param {object} handle Element on which to attach listener.\n   * @return {object} An object with a remove function which will forcefully\n   *                  remove the listener.\n   * @internal\n   */\n  trapBubbledEvent: function(topLevelType, handlerBaseName, handle) {\n    var element = handle;\n    if (!element) {\n      return null;\n    }\n    return EventListener.listen(\n      element,\n      handlerBaseName,\n      ReactEventListener.dispatchEvent.bind(null, topLevelType)\n    );\n  },\n\n  /**\n   * Traps a top-level event by using event capturing.\n   *\n   * @param {string} topLevelType Record from `EventConstants`.\n   * @param {string} handlerBaseName Event name (e.g. \"click\").\n   * @param {object} handle Element on which to attach listener.\n   * @return {object} An object with a remove function which will forcefully\n   *                  remove the listener.\n   * @internal\n   */\n  trapCapturedEvent: function(topLevelType, handlerBaseName, handle) {\n    var element = handle;\n    if (!element) {\n      return null;\n    }\n    return EventListener.capture(\n      element,\n      handlerBaseName,\n      ReactEventListener.dispatchEvent.bind(null, topLevelType)\n    );\n  },\n\n  monitorScrollValue: function(refresh) {\n    var callback = scrollValueMonitor.bind(null, refresh);\n    EventListener.listen(window, 'scroll', callback);\n  },\n\n  dispatchEvent: function(topLevelType, nativeEvent) {\n    if (!ReactEventListener._enabled) {\n      return;\n    }\n\n    var bookKeeping = TopLevelCallbackBookKeeping.getPooled(\n      topLevelType,\n      nativeEvent\n    );\n    try {\n      // Event queue being processed in the same cycle allows\n      // `preventDefault`.\n      ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);\n    } finally {\n      TopLevelCallbackBookKeeping.release(bookKeeping);\n    }\n  }\n};\n\nmodule.exports = ReactEventListener;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}