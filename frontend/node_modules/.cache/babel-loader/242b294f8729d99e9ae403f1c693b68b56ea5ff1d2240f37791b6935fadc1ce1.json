{"ast":null,"code":"/**\n * @license\n * Copyright 2023 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport fs from 'fs';\nimport os from 'os';\nimport path from 'path';\nimport debug from 'debug';\nimport { Browser, executablePathByBrowser, getVersionComparator } from './browser-data/browser-data.js';\nimport { detectBrowserPlatform } from './detectPlatform.js';\nconst debugCache = debug('puppeteer:browsers:cache');\n/**\n * @public\n */\nexport class InstalledBrowser {\n  browser;\n  buildId;\n  platform;\n  executablePath;\n  #cache;\n  /**\n   * @internal\n   */\n  constructor(cache, browser, buildId, platform) {\n    this.#cache = cache;\n    this.browser = browser;\n    this.buildId = buildId;\n    this.platform = platform;\n    this.executablePath = cache.computeExecutablePath({\n      browser,\n      buildId,\n      platform\n    });\n  }\n  /**\n   * Path to the root of the installation folder. Use\n   * {@link computeExecutablePath} to get the path to the executable binary.\n   */\n  get path() {\n    return this.#cache.installationDir(this.browser, this.platform, this.buildId);\n  }\n  readMetadata() {\n    return this.#cache.readMetadata(this.browser);\n  }\n  writeMetadata(metadata) {\n    this.#cache.writeMetadata(this.browser, metadata);\n  }\n}\n/**\n * The cache used by Puppeteer relies on the following structure:\n *\n * - rootDir\n *   -- <browser1> | browserRoot(browser1)\n *   ---- <platform>-<buildId> | installationDir()\n *   ------ the browser-platform-buildId\n *   ------ specific structure.\n *   -- <browser2> | browserRoot(browser2)\n *   ---- <platform>-<buildId> | installationDir()\n *   ------ the browser-platform-buildId\n *   ------ specific structure.\n *   @internal\n */\nexport class Cache {\n  #rootDir;\n  constructor(rootDir) {\n    this.#rootDir = rootDir;\n  }\n  /**\n   * @internal\n   */\n  get rootDir() {\n    return this.#rootDir;\n  }\n  browserRoot(browser) {\n    return path.join(this.#rootDir, browser);\n  }\n  metadataFile(browser) {\n    return path.join(this.browserRoot(browser), '.metadata');\n  }\n  readMetadata(browser) {\n    const metatadaPath = this.metadataFile(browser);\n    if (!fs.existsSync(metatadaPath)) {\n      return {\n        aliases: {}\n      };\n    }\n    // TODO: add type-safe parsing.\n    const data = JSON.parse(fs.readFileSync(metatadaPath, 'utf8'));\n    if (typeof data !== 'object') {\n      throw new Error('.metadata is not an object');\n    }\n    return data;\n  }\n  writeMetadata(browser, metadata) {\n    const metatadaPath = this.metadataFile(browser);\n    fs.mkdirSync(path.dirname(metatadaPath), {\n      recursive: true\n    });\n    fs.writeFileSync(metatadaPath, JSON.stringify(metadata, null, 2));\n  }\n  resolveAlias(browser, alias) {\n    const metadata = this.readMetadata(browser);\n    if (alias === 'latest') {\n      return Object.values(metadata.aliases || {}).sort(getVersionComparator(browser)).at(-1);\n    }\n    return metadata.aliases[alias];\n  }\n  installationDir(browser, platform, buildId) {\n    return path.join(this.browserRoot(browser), `${platform}-${buildId}`);\n  }\n  clear() {\n    fs.rmSync(this.#rootDir, {\n      force: true,\n      recursive: true,\n      maxRetries: 10,\n      retryDelay: 500\n    });\n  }\n  uninstall(browser, platform, buildId) {\n    const metadata = this.readMetadata(browser);\n    for (const alias of Object.keys(metadata.aliases)) {\n      if (metadata.aliases[alias] === buildId) {\n        delete metadata.aliases[alias];\n      }\n    }\n    fs.rmSync(this.installationDir(browser, platform, buildId), {\n      force: true,\n      recursive: true,\n      maxRetries: 10,\n      retryDelay: 500\n    });\n  }\n  getInstalledBrowsers() {\n    if (!fs.existsSync(this.#rootDir)) {\n      return [];\n    }\n    const types = fs.readdirSync(this.#rootDir);\n    const browsers = types.filter(t => {\n      return Object.values(Browser).includes(t);\n    });\n    return browsers.flatMap(browser => {\n      const files = fs.readdirSync(this.browserRoot(browser));\n      return files.map(file => {\n        const result = parseFolderPath(path.join(this.browserRoot(browser), file));\n        if (!result) {\n          return null;\n        }\n        return new InstalledBrowser(this, browser, result.buildId, result.platform);\n      }).filter(item => {\n        return item !== null;\n      });\n    });\n  }\n  computeExecutablePath(options) {\n    options.platform ??= detectBrowserPlatform();\n    if (!options.platform) {\n      throw new Error(`Cannot download a binary for the provided platform: ${os.platform()} (${os.arch()})`);\n    }\n    try {\n      options.buildId = this.resolveAlias(options.browser, options.buildId) ?? options.buildId;\n    } catch {\n      debugCache('could not read .metadata file for the browser');\n    }\n    const installationDir = this.installationDir(options.browser, options.platform, options.buildId);\n    return path.join(installationDir, executablePathByBrowser[options.browser](options.platform, options.buildId));\n  }\n}\nfunction parseFolderPath(folderPath) {\n  const name = path.basename(folderPath);\n  const splits = name.split('-');\n  if (splits.length !== 2) {\n    return;\n  }\n  const [platform, buildId] = splits;\n  if (!buildId || !platform) {\n    return;\n  }\n  return {\n    platform,\n    buildId\n  };\n}","map":{"version":3,"names":["fs","os","path","debug","Browser","executablePathByBrowser","getVersionComparator","detectBrowserPlatform","debugCache","InstalledBrowser","browser","buildId","platform","executablePath","cache","constructor","computeExecutablePath","installationDir","readMetadata","writeMetadata","metadata","Cache","rootDir","browserRoot","join","metadataFile","metatadaPath","existsSync","aliases","data","JSON","parse","readFileSync","Error","mkdirSync","dirname","recursive","writeFileSync","stringify","resolveAlias","alias","Object","values","sort","at","clear","rmSync","force","maxRetries","retryDelay","uninstall","keys","getInstalledBrowsers","types","readdirSync","browsers","filter","t","includes","flatMap","files","map","file","result","parseFolderPath","item","options","arch","folderPath","name","basename","splits","split","length"],"sources":["C:\\Users\\raffy\\Desktop\\test\\node_modules\\@puppeteer\\browsers\\src\\Cache.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2023 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport fs from 'fs';\nimport os from 'os';\nimport path from 'path';\n\nimport debug from 'debug';\n\nimport {\n  Browser,\n  type BrowserPlatform,\n  executablePathByBrowser,\n  getVersionComparator,\n} from './browser-data/browser-data.js';\nimport {detectBrowserPlatform} from './detectPlatform.js';\n\nconst debugCache = debug('puppeteer:browsers:cache');\n\n/**\n * @public\n */\nexport class InstalledBrowser {\n  browser: Browser;\n  buildId: string;\n  platform: BrowserPlatform;\n  readonly executablePath: string;\n\n  #cache: Cache;\n\n  /**\n   * @internal\n   */\n  constructor(\n    cache: Cache,\n    browser: Browser,\n    buildId: string,\n    platform: BrowserPlatform\n  ) {\n    this.#cache = cache;\n    this.browser = browser;\n    this.buildId = buildId;\n    this.platform = platform;\n    this.executablePath = cache.computeExecutablePath({\n      browser,\n      buildId,\n      platform,\n    });\n  }\n\n  /**\n   * Path to the root of the installation folder. Use\n   * {@link computeExecutablePath} to get the path to the executable binary.\n   */\n  get path(): string {\n    return this.#cache.installationDir(\n      this.browser,\n      this.platform,\n      this.buildId\n    );\n  }\n\n  readMetadata(): Metadata {\n    return this.#cache.readMetadata(this.browser);\n  }\n\n  writeMetadata(metadata: Metadata): void {\n    this.#cache.writeMetadata(this.browser, metadata);\n  }\n}\n\n/**\n * @internal\n */\nexport interface ComputeExecutablePathOptions {\n  /**\n   * Determines which platform the browser will be suited for.\n   *\n   * @defaultValue **Auto-detected.**\n   */\n  platform?: BrowserPlatform;\n  /**\n   * Determines which browser to launch.\n   */\n  browser: Browser;\n  /**\n   * Determines which buildId to download. BuildId should uniquely identify\n   * binaries and they are used for caching.\n   */\n  buildId: string;\n}\n\nexport interface Metadata {\n  // Maps an alias (canary/latest/dev/etc.) to a buildId.\n  aliases: Record<string, string>;\n}\n\n/**\n * The cache used by Puppeteer relies on the following structure:\n *\n * - rootDir\n *   -- <browser1> | browserRoot(browser1)\n *   ---- <platform>-<buildId> | installationDir()\n *   ------ the browser-platform-buildId\n *   ------ specific structure.\n *   -- <browser2> | browserRoot(browser2)\n *   ---- <platform>-<buildId> | installationDir()\n *   ------ the browser-platform-buildId\n *   ------ specific structure.\n *   @internal\n */\nexport class Cache {\n  #rootDir: string;\n\n  constructor(rootDir: string) {\n    this.#rootDir = rootDir;\n  }\n\n  /**\n   * @internal\n   */\n  get rootDir(): string {\n    return this.#rootDir;\n  }\n\n  browserRoot(browser: Browser): string {\n    return path.join(this.#rootDir, browser);\n  }\n\n  metadataFile(browser: Browser): string {\n    return path.join(this.browserRoot(browser), '.metadata');\n  }\n\n  readMetadata(browser: Browser): Metadata {\n    const metatadaPath = this.metadataFile(browser);\n    if (!fs.existsSync(metatadaPath)) {\n      return {aliases: {}};\n    }\n    // TODO: add type-safe parsing.\n    const data = JSON.parse(fs.readFileSync(metatadaPath, 'utf8'));\n    if (typeof data !== 'object') {\n      throw new Error('.metadata is not an object');\n    }\n    return data;\n  }\n\n  writeMetadata(browser: Browser, metadata: Metadata): void {\n    const metatadaPath = this.metadataFile(browser);\n    fs.mkdirSync(path.dirname(metatadaPath), {recursive: true});\n    fs.writeFileSync(metatadaPath, JSON.stringify(metadata, null, 2));\n  }\n\n  resolveAlias(browser: Browser, alias: string): string | undefined {\n    const metadata = this.readMetadata(browser);\n    if (alias === 'latest') {\n      return Object.values(metadata.aliases || {})\n        .sort(getVersionComparator(browser))\n        .at(-1);\n    }\n    return metadata.aliases[alias];\n  }\n\n  installationDir(\n    browser: Browser,\n    platform: BrowserPlatform,\n    buildId: string\n  ): string {\n    return path.join(this.browserRoot(browser), `${platform}-${buildId}`);\n  }\n\n  clear(): void {\n    fs.rmSync(this.#rootDir, {\n      force: true,\n      recursive: true,\n      maxRetries: 10,\n      retryDelay: 500,\n    });\n  }\n\n  uninstall(\n    browser: Browser,\n    platform: BrowserPlatform,\n    buildId: string\n  ): void {\n    const metadata = this.readMetadata(browser);\n    for (const alias of Object.keys(metadata.aliases)) {\n      if (metadata.aliases[alias] === buildId) {\n        delete metadata.aliases[alias];\n      }\n    }\n    fs.rmSync(this.installationDir(browser, platform, buildId), {\n      force: true,\n      recursive: true,\n      maxRetries: 10,\n      retryDelay: 500,\n    });\n  }\n\n  getInstalledBrowsers(): InstalledBrowser[] {\n    if (!fs.existsSync(this.#rootDir)) {\n      return [];\n    }\n    const types = fs.readdirSync(this.#rootDir);\n    const browsers = types.filter((t): t is Browser => {\n      return (Object.values(Browser) as string[]).includes(t);\n    });\n    return browsers.flatMap(browser => {\n      const files = fs.readdirSync(this.browserRoot(browser));\n      return files\n        .map(file => {\n          const result = parseFolderPath(\n            path.join(this.browserRoot(browser), file)\n          );\n          if (!result) {\n            return null;\n          }\n          return new InstalledBrowser(\n            this,\n            browser,\n            result.buildId,\n            result.platform as BrowserPlatform\n          );\n        })\n        .filter((item: InstalledBrowser | null): item is InstalledBrowser => {\n          return item !== null;\n        });\n    });\n  }\n\n  computeExecutablePath(options: ComputeExecutablePathOptions): string {\n    options.platform ??= detectBrowserPlatform();\n    if (!options.platform) {\n      throw new Error(\n        `Cannot download a binary for the provided platform: ${os.platform()} (${os.arch()})`\n      );\n    }\n    try {\n      options.buildId =\n        this.resolveAlias(options.browser, options.buildId) ?? options.buildId;\n    } catch {\n      debugCache('could not read .metadata file for the browser');\n    }\n    const installationDir = this.installationDir(\n      options.browser,\n      options.platform,\n      options.buildId\n    );\n    return path.join(\n      installationDir,\n      executablePathByBrowser[options.browser](\n        options.platform,\n        options.buildId\n      )\n    );\n  }\n}\n\nfunction parseFolderPath(\n  folderPath: string\n): {platform: string; buildId: string} | undefined {\n  const name = path.basename(folderPath);\n  const splits = name.split('-');\n  if (splits.length !== 2) {\n    return;\n  }\n  const [platform, buildId] = splits;\n  if (!buildId || !platform) {\n    return;\n  }\n  return {platform, buildId};\n}\n"],"mappings":"AAAA;;;;;AAMA,OAAOA,EAAE,MAAM,IAAI;AACnB,OAAOC,EAAE,MAAM,IAAI;AACnB,OAAOC,IAAI,MAAM,MAAM;AAEvB,OAAOC,KAAK,MAAM,OAAO;AAEzB,SACEC,OAAO,EAEPC,uBAAuB,EACvBC,oBAAoB,QACf,gCAAgC;AACvC,SAAQC,qBAAqB,QAAO,qBAAqB;AAEzD,MAAMC,UAAU,GAAGL,KAAK,CAAC,0BAA0B,CAAC;AAEpD;;;AAGA,OAAM,MAAOM,gBAAgB;EAC3BC,OAAO;EACPC,OAAO;EACPC,QAAQ;EACCC,cAAc;EAEvB,CAAAC,KAAM;EAEN;;;EAGAC,YACED,KAAY,EACZJ,OAAgB,EAChBC,OAAe,EACfC,QAAyB;IAEzB,IAAI,CAAC,CAAAE,KAAM,GAAGA,KAAK;IACnB,IAAI,CAACJ,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACC,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACC,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACC,cAAc,GAAGC,KAAK,CAACE,qBAAqB,CAAC;MAChDN,OAAO;MACPC,OAAO;MACPC;KACD,CAAC;EACJ;EAEA;;;;EAIA,IAAIV,IAAIA,CAAA;IACN,OAAO,IAAI,CAAC,CAAAY,KAAM,CAACG,eAAe,CAChC,IAAI,CAACP,OAAO,EACZ,IAAI,CAACE,QAAQ,EACb,IAAI,CAACD,OAAO,CACb;EACH;EAEAO,YAAYA,CAAA;IACV,OAAO,IAAI,CAAC,CAAAJ,KAAM,CAACI,YAAY,CAAC,IAAI,CAACR,OAAO,CAAC;EAC/C;EAEAS,aAAaA,CAACC,QAAkB;IAC9B,IAAI,CAAC,CAAAN,KAAM,CAACK,aAAa,CAAC,IAAI,CAACT,OAAO,EAAEU,QAAQ,CAAC;EACnD;;AA6BF;;;;;;;;;;;;;;AAcA,OAAM,MAAOC,KAAK;EAChB,CAAAC,OAAQ;EAERP,YAAYO,OAAe;IACzB,IAAI,CAAC,CAAAA,OAAQ,GAAGA,OAAO;EACzB;EAEA;;;EAGA,IAAIA,OAAOA,CAAA;IACT,OAAO,IAAI,CAAC,CAAAA,OAAQ;EACtB;EAEAC,WAAWA,CAACb,OAAgB;IAC1B,OAAOR,IAAI,CAACsB,IAAI,CAAC,IAAI,CAAC,CAAAF,OAAQ,EAAEZ,OAAO,CAAC;EAC1C;EAEAe,YAAYA,CAACf,OAAgB;IAC3B,OAAOR,IAAI,CAACsB,IAAI,CAAC,IAAI,CAACD,WAAW,CAACb,OAAO,CAAC,EAAE,WAAW,CAAC;EAC1D;EAEAQ,YAAYA,CAACR,OAAgB;IAC3B,MAAMgB,YAAY,GAAG,IAAI,CAACD,YAAY,CAACf,OAAO,CAAC;IAC/C,IAAI,CAACV,EAAE,CAAC2B,UAAU,CAACD,YAAY,CAAC,EAAE;MAChC,OAAO;QAACE,OAAO,EAAE;MAAE,CAAC;IACtB;IACA;IACA,MAAMC,IAAI,GAAGC,IAAI,CAACC,KAAK,CAAC/B,EAAE,CAACgC,YAAY,CAACN,YAAY,EAAE,MAAM,CAAC,CAAC;IAC9D,IAAI,OAAOG,IAAI,KAAK,QAAQ,EAAE;MAC5B,MAAM,IAAII,KAAK,CAAC,4BAA4B,CAAC;IAC/C;IACA,OAAOJ,IAAI;EACb;EAEAV,aAAaA,CAACT,OAAgB,EAAEU,QAAkB;IAChD,MAAMM,YAAY,GAAG,IAAI,CAACD,YAAY,CAACf,OAAO,CAAC;IAC/CV,EAAE,CAACkC,SAAS,CAAChC,IAAI,CAACiC,OAAO,CAACT,YAAY,CAAC,EAAE;MAACU,SAAS,EAAE;IAAI,CAAC,CAAC;IAC3DpC,EAAE,CAACqC,aAAa,CAACX,YAAY,EAAEI,IAAI,CAACQ,SAAS,CAAClB,QAAQ,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC;EACnE;EAEAmB,YAAYA,CAAC7B,OAAgB,EAAE8B,KAAa;IAC1C,MAAMpB,QAAQ,GAAG,IAAI,CAACF,YAAY,CAACR,OAAO,CAAC;IAC3C,IAAI8B,KAAK,KAAK,QAAQ,EAAE;MACtB,OAAOC,MAAM,CAACC,MAAM,CAACtB,QAAQ,CAACQ,OAAO,IAAI,EAAE,CAAC,CACzCe,IAAI,CAACrC,oBAAoB,CAACI,OAAO,CAAC,CAAC,CACnCkC,EAAE,CAAC,CAAC,CAAC,CAAC;IACX;IACA,OAAOxB,QAAQ,CAACQ,OAAO,CAACY,KAAK,CAAC;EAChC;EAEAvB,eAAeA,CACbP,OAAgB,EAChBE,QAAyB,EACzBD,OAAe;IAEf,OAAOT,IAAI,CAACsB,IAAI,CAAC,IAAI,CAACD,WAAW,CAACb,OAAO,CAAC,EAAE,GAAGE,QAAQ,IAAID,OAAO,EAAE,CAAC;EACvE;EAEAkC,KAAKA,CAAA;IACH7C,EAAE,CAAC8C,MAAM,CAAC,IAAI,CAAC,CAAAxB,OAAQ,EAAE;MACvByB,KAAK,EAAE,IAAI;MACXX,SAAS,EAAE,IAAI;MACfY,UAAU,EAAE,EAAE;MACdC,UAAU,EAAE;KACb,CAAC;EACJ;EAEAC,SAASA,CACPxC,OAAgB,EAChBE,QAAyB,EACzBD,OAAe;IAEf,MAAMS,QAAQ,GAAG,IAAI,CAACF,YAAY,CAACR,OAAO,CAAC;IAC3C,KAAK,MAAM8B,KAAK,IAAIC,MAAM,CAACU,IAAI,CAAC/B,QAAQ,CAACQ,OAAO,CAAC,EAAE;MACjD,IAAIR,QAAQ,CAACQ,OAAO,CAACY,KAAK,CAAC,KAAK7B,OAAO,EAAE;QACvC,OAAOS,QAAQ,CAACQ,OAAO,CAACY,KAAK,CAAC;MAChC;IACF;IACAxC,EAAE,CAAC8C,MAAM,CAAC,IAAI,CAAC7B,eAAe,CAACP,OAAO,EAAEE,QAAQ,EAAED,OAAO,CAAC,EAAE;MAC1DoC,KAAK,EAAE,IAAI;MACXX,SAAS,EAAE,IAAI;MACfY,UAAU,EAAE,EAAE;MACdC,UAAU,EAAE;KACb,CAAC;EACJ;EAEAG,oBAAoBA,CAAA;IAClB,IAAI,CAACpD,EAAE,CAAC2B,UAAU,CAAC,IAAI,CAAC,CAAAL,OAAQ,CAAC,EAAE;MACjC,OAAO,EAAE;IACX;IACA,MAAM+B,KAAK,GAAGrD,EAAE,CAACsD,WAAW,CAAC,IAAI,CAAC,CAAAhC,OAAQ,CAAC;IAC3C,MAAMiC,QAAQ,GAAGF,KAAK,CAACG,MAAM,CAAEC,CAAC,IAAkB;MAChD,OAAQhB,MAAM,CAACC,MAAM,CAACtC,OAAO,CAAc,CAACsD,QAAQ,CAACD,CAAC,CAAC;IACzD,CAAC,CAAC;IACF,OAAOF,QAAQ,CAACI,OAAO,CAACjD,OAAO,IAAG;MAChC,MAAMkD,KAAK,GAAG5D,EAAE,CAACsD,WAAW,CAAC,IAAI,CAAC/B,WAAW,CAACb,OAAO,CAAC,CAAC;MACvD,OAAOkD,KAAK,CACTC,GAAG,CAACC,IAAI,IAAG;QACV,MAAMC,MAAM,GAAGC,eAAe,CAC5B9D,IAAI,CAACsB,IAAI,CAAC,IAAI,CAACD,WAAW,CAACb,OAAO,CAAC,EAAEoD,IAAI,CAAC,CAC3C;QACD,IAAI,CAACC,MAAM,EAAE;UACX,OAAO,IAAI;QACb;QACA,OAAO,IAAItD,gBAAgB,CACzB,IAAI,EACJC,OAAO,EACPqD,MAAM,CAACpD,OAAO,EACdoD,MAAM,CAACnD,QAA2B,CACnC;MACH,CAAC,CAAC,CACD4C,MAAM,CAAES,IAA6B,IAA8B;QAClE,OAAOA,IAAI,KAAK,IAAI;MACtB,CAAC,CAAC;IACN,CAAC,CAAC;EACJ;EAEAjD,qBAAqBA,CAACkD,OAAqC;IACzDA,OAAO,CAACtD,QAAQ,KAAKL,qBAAqB,EAAE;IAC5C,IAAI,CAAC2D,OAAO,CAACtD,QAAQ,EAAE;MACrB,MAAM,IAAIqB,KAAK,CACb,uDAAuDhC,EAAE,CAACW,QAAQ,EAAE,KAAKX,EAAE,CAACkE,IAAI,EAAE,GAAG,CACtF;IACH;IACA,IAAI;MACFD,OAAO,CAACvD,OAAO,GACb,IAAI,CAAC4B,YAAY,CAAC2B,OAAO,CAACxD,OAAO,EAAEwD,OAAO,CAACvD,OAAO,CAAC,IAAIuD,OAAO,CAACvD,OAAO;IAC1E,CAAC,CAAC,MAAM;MACNH,UAAU,CAAC,+CAA+C,CAAC;IAC7D;IACA,MAAMS,eAAe,GAAG,IAAI,CAACA,eAAe,CAC1CiD,OAAO,CAACxD,OAAO,EACfwD,OAAO,CAACtD,QAAQ,EAChBsD,OAAO,CAACvD,OAAO,CAChB;IACD,OAAOT,IAAI,CAACsB,IAAI,CACdP,eAAe,EACfZ,uBAAuB,CAAC6D,OAAO,CAACxD,OAAO,CAAC,CACtCwD,OAAO,CAACtD,QAAQ,EAChBsD,OAAO,CAACvD,OAAO,CAChB,CACF;EACH;;AAGF,SAASqD,eAAeA,CACtBI,UAAkB;EAElB,MAAMC,IAAI,GAAGnE,IAAI,CAACoE,QAAQ,CAACF,UAAU,CAAC;EACtC,MAAMG,MAAM,GAAGF,IAAI,CAACG,KAAK,CAAC,GAAG,CAAC;EAC9B,IAAID,MAAM,CAACE,MAAM,KAAK,CAAC,EAAE;IACvB;EACF;EACA,MAAM,CAAC7D,QAAQ,EAAED,OAAO,CAAC,GAAG4D,MAAM;EAClC,IAAI,CAAC5D,OAAO,IAAI,CAACC,QAAQ,EAAE;IACzB;EACF;EACA,OAAO;IAACA,QAAQ;IAAED;EAAO,CAAC;AAC5B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}