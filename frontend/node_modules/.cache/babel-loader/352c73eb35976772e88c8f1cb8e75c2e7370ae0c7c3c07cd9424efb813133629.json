{"ast":null,"code":"/**\n * @license\n * Copyright 2023 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\nvar __runInitializers = this && this.__runInitializers || function (thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\nvar __esDecorate = this && this.__esDecorate || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) {\n    if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\");\n    return f;\n  }\n  var kind = contextIn.kind,\n    key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _,\n    done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n    var context = {};\n    for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n    for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n    context.addInitializer = function (f) {\n      if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\");\n      extraInitializers.push(accept(f || null));\n    };\n    var result = (0, decorators[i])(kind === \"accessor\" ? {\n      get: descriptor.get,\n      set: descriptor.set\n    } : descriptor[key], context);\n    if (kind === \"accessor\") {\n      if (result === void 0) continue;\n      if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n      if (_ = accept(result.get)) descriptor.get = _;\n      if (_ = accept(result.set)) descriptor.set = _;\n      if (_ = accept(result.init)) initializers.unshift(_);\n    } else if (_ = accept(result)) {\n      if (kind === \"field\") initializers.unshift(_);else descriptor[key] = _;\n    }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\nvar __addDisposableResource = this && this.__addDisposableResource || function (env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose;\n    if (async) {\n      if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n      dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n      if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n      dispose = value[Symbol.dispose];\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    env.stack.push({\n      value: value,\n      dispose: dispose,\n      async: async\n    });\n  } else if (async) {\n    env.stack.push({\n      async: true\n    });\n  }\n  return value;\n};\nvar __disposeResources = this && this.__disposeResources || function (SuppressedError) {\n  return function (env) {\n    function fail(e) {\n      env.error = env.hasError ? new SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n      env.hasError = true;\n    }\n    function next() {\n      while (env.stack.length) {\n        var rec = env.stack.pop();\n        try {\n          var result = rec.dispose && rec.dispose.call(rec.value);\n          if (rec.async) return Promise.resolve(result).then(next, function (e) {\n            fail(e);\n            return next();\n          });\n        } catch (e) {\n          fail(e);\n        }\n      }\n      if (env.hasError) throw env.error;\n    }\n    return next();\n  };\n}(typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n});\nimport { EventEmitter } from '../common/EventEmitter.js';\nimport { getQueryHandlerAndSelector } from '../common/GetQueryHandler.js';\nimport { transposeIterableHandle } from '../common/HandleIterator.js';\nimport { withSourcePuppeteerURLIfNone } from '../common/util.js';\nimport { environment } from '../environment.js';\nimport { assert } from '../util/assert.js';\nimport { throwIfDisposed } from '../util/decorators.js';\nimport { FunctionLocator, NodeLocator } from './locators/locators.js';\n/**\n * We use symbols to prevent external parties listening to these events.\n * They are internal to Puppeteer.\n *\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport var FrameEvent;\n(function (FrameEvent) {\n  FrameEvent.FrameNavigated = Symbol('Frame.FrameNavigated');\n  FrameEvent.FrameSwapped = Symbol('Frame.FrameSwapped');\n  FrameEvent.LifecycleEvent = Symbol('Frame.LifecycleEvent');\n  FrameEvent.FrameNavigatedWithinDocument = Symbol('Frame.FrameNavigatedWithinDocument');\n  FrameEvent.FrameDetached = Symbol('Frame.FrameDetached');\n  FrameEvent.FrameSwappedByActivation = Symbol('Frame.FrameSwappedByActivation');\n})(FrameEvent || (FrameEvent = {}));\n/**\n * @internal\n */\nexport const throwIfDetached = throwIfDisposed(frame => {\n  return `Attempted to use detached Frame '${frame._id}'.`;\n});\n/**\n * Represents a DOM frame.\n *\n * To understand frames, you can think of frames as `<iframe>` elements. Just\n * like iframes, frames can be nested, and when JavaScript is executed in a\n * frame, the JavaScript does not effect frames inside the ambient frame the\n * JavaScript executes in.\n *\n * @example\n * At any point in time, {@link Page | pages} expose their current frame\n * tree via the {@link Page.mainFrame} and {@link Frame.childFrames} methods.\n *\n * @example\n * An example of dumping frame tree:\n *\n * ```ts\n * import puppeteer from 'puppeteer';\n *\n * (async () => {\n *   const browser = await puppeteer.launch();\n *   const page = await browser.newPage();\n *   await page.goto('https://www.google.com/chrome/browser/canary.html');\n *   dumpFrameTree(page.mainFrame(), '');\n *   await browser.close();\n *\n *   function dumpFrameTree(frame, indent) {\n *     console.log(indent + frame.url());\n *     for (const child of frame.childFrames()) {\n *       dumpFrameTree(child, indent + '  ');\n *     }\n *   }\n * })();\n * ```\n *\n * @example\n * An example of getting text from an iframe element:\n *\n * ```ts\n * const frame = page.frames().find(frame => frame.name() === 'myframe');\n * const text = await frame.$eval('.selector', element => element.textContent);\n * console.log(text);\n * ```\n *\n * @remarks\n * Frame lifecycles are controlled by three events that are all dispatched on\n * the parent {@link Frame.page | page}:\n *\n * - {@link PageEvent.FrameAttached}\n * - {@link PageEvent.FrameNavigated}\n * - {@link PageEvent.FrameDetached}\n *\n * @public\n */\nlet Frame = (() => {\n  let _classSuper = EventEmitter;\n  let _instanceExtraInitializers = [];\n  let _frameElement_decorators;\n  let _evaluateHandle_decorators;\n  let _evaluate_decorators;\n  let _locator_decorators;\n  let _$_decorators;\n  let _$$_decorators;\n  let _$eval_decorators;\n  let _$$eval_decorators;\n  let _waitForSelector_decorators;\n  let _waitForFunction_decorators;\n  let _content_decorators;\n  let _addScriptTag_decorators;\n  let _addStyleTag_decorators;\n  let _click_decorators;\n  let _focus_decorators;\n  let _hover_decorators;\n  let _select_decorators;\n  let _tap_decorators;\n  let _type_decorators;\n  let _title_decorators;\n  return class Frame extends _classSuper {\n    static {\n      const _metadata = typeof Symbol === \"function\" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;\n      _frameElement_decorators = [throwIfDetached];\n      _evaluateHandle_decorators = [throwIfDetached];\n      _evaluate_decorators = [throwIfDetached];\n      _locator_decorators = [throwIfDetached];\n      _$_decorators = [throwIfDetached];\n      _$$_decorators = [throwIfDetached];\n      _$eval_decorators = [throwIfDetached];\n      _$$eval_decorators = [throwIfDetached];\n      _waitForSelector_decorators = [throwIfDetached];\n      _waitForFunction_decorators = [throwIfDetached];\n      _content_decorators = [throwIfDetached];\n      _addScriptTag_decorators = [throwIfDetached];\n      _addStyleTag_decorators = [throwIfDetached];\n      _click_decorators = [throwIfDetached];\n      _focus_decorators = [throwIfDetached];\n      _hover_decorators = [throwIfDetached];\n      _select_decorators = [throwIfDetached];\n      _tap_decorators = [throwIfDetached];\n      _type_decorators = [throwIfDetached];\n      _title_decorators = [throwIfDetached];\n      __esDecorate(this, null, _frameElement_decorators, {\n        kind: \"method\",\n        name: \"frameElement\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"frameElement\" in obj,\n          get: obj => obj.frameElement\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _evaluateHandle_decorators, {\n        kind: \"method\",\n        name: \"evaluateHandle\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"evaluateHandle\" in obj,\n          get: obj => obj.evaluateHandle\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _evaluate_decorators, {\n        kind: \"method\",\n        name: \"evaluate\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"evaluate\" in obj,\n          get: obj => obj.evaluate\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _locator_decorators, {\n        kind: \"method\",\n        name: \"locator\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"locator\" in obj,\n          get: obj => obj.locator\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _$_decorators, {\n        kind: \"method\",\n        name: \"$\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"$\" in obj,\n          get: obj => obj.$\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _$$_decorators, {\n        kind: \"method\",\n        name: \"$$\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"$$\" in obj,\n          get: obj => obj.$$\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _$eval_decorators, {\n        kind: \"method\",\n        name: \"$eval\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"$eval\" in obj,\n          get: obj => obj.$eval\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _$$eval_decorators, {\n        kind: \"method\",\n        name: \"$$eval\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"$$eval\" in obj,\n          get: obj => obj.$$eval\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _waitForSelector_decorators, {\n        kind: \"method\",\n        name: \"waitForSelector\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"waitForSelector\" in obj,\n          get: obj => obj.waitForSelector\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _waitForFunction_decorators, {\n        kind: \"method\",\n        name: \"waitForFunction\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"waitForFunction\" in obj,\n          get: obj => obj.waitForFunction\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _content_decorators, {\n        kind: \"method\",\n        name: \"content\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"content\" in obj,\n          get: obj => obj.content\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _addScriptTag_decorators, {\n        kind: \"method\",\n        name: \"addScriptTag\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"addScriptTag\" in obj,\n          get: obj => obj.addScriptTag\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _addStyleTag_decorators, {\n        kind: \"method\",\n        name: \"addStyleTag\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"addStyleTag\" in obj,\n          get: obj => obj.addStyleTag\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _click_decorators, {\n        kind: \"method\",\n        name: \"click\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"click\" in obj,\n          get: obj => obj.click\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _focus_decorators, {\n        kind: \"method\",\n        name: \"focus\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"focus\" in obj,\n          get: obj => obj.focus\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _hover_decorators, {\n        kind: \"method\",\n        name: \"hover\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"hover\" in obj,\n          get: obj => obj.hover\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _select_decorators, {\n        kind: \"method\",\n        name: \"select\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"select\" in obj,\n          get: obj => obj.select\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _tap_decorators, {\n        kind: \"method\",\n        name: \"tap\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"tap\" in obj,\n          get: obj => obj.tap\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _type_decorators, {\n        kind: \"method\",\n        name: \"type\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"type\" in obj,\n          get: obj => obj.type\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _title_decorators, {\n        kind: \"method\",\n        name: \"title\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"title\" in obj,\n          get: obj => obj.title\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      if (_metadata) Object.defineProperty(this, Symbol.metadata, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value: _metadata\n      });\n    }\n    /**\n     * @internal\n     */\n    _id = __runInitializers(this, _instanceExtraInitializers);\n    /**\n     * @internal\n     */\n    _parentId;\n    /**\n     * @internal\n     */\n    _name;\n    /**\n     * @internal\n     */\n    _hasStartedLoading = false;\n    /**\n     * @internal\n     */\n    constructor() {\n      super();\n    }\n    #_document;\n    /**\n     * @internal\n     */\n    #document() {\n      if (!this.#_document) {\n        this.#_document = this.mainRealm().evaluateHandle(() => {\n          return document;\n        });\n      }\n      return this.#_document;\n    }\n    /**\n     * Used to clear the document handle that has been destroyed.\n     *\n     * @internal\n     */\n    clearDocumentHandle() {\n      this.#_document = undefined;\n    }\n    /**\n     * @returns The frame element associated with this frame (if any).\n     */\n    async frameElement() {\n      const env_1 = {\n        stack: [],\n        error: void 0,\n        hasError: false\n      };\n      try {\n        const parentFrame = this.parentFrame();\n        if (!parentFrame) {\n          return null;\n        }\n        const list = __addDisposableResource(env_1, await parentFrame.isolatedRealm().evaluateHandle(() => {\n          return document.querySelectorAll('iframe,frame');\n        }), false);\n        for await (const iframe_1 of transposeIterableHandle(list)) {\n          const env_2 = {\n            stack: [],\n            error: void 0,\n            hasError: false\n          };\n          try {\n            const iframe = __addDisposableResource(env_2, iframe_1, false);\n            const frame = await iframe.contentFrame();\n            if (frame?._id === this._id) {\n              return iframe.move();\n            }\n          } catch (e_1) {\n            env_2.error = e_1;\n            env_2.hasError = true;\n          } finally {\n            __disposeResources(env_2);\n          }\n        }\n        return null;\n      } catch (e_2) {\n        env_1.error = e_2;\n        env_1.hasError = true;\n      } finally {\n        __disposeResources(env_1);\n      }\n    }\n    /**\n     * Behaves identically to {@link Page.evaluateHandle} except it's run within\n     * the context of this frame.\n     *\n     * See {@link Page.evaluateHandle} for details.\n     */\n    async evaluateHandle(pageFunction, ...args) {\n      pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);\n      return await this.mainRealm().evaluateHandle(pageFunction, ...args);\n    }\n    /**\n     * Behaves identically to {@link Page.evaluate} except it's run within\n     * the context of this frame.\n     *\n     * See {@link Page.evaluate} for details.\n     */\n    async evaluate(pageFunction, ...args) {\n      pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);\n      return await this.mainRealm().evaluate(pageFunction, ...args);\n    }\n    /**\n     * @internal\n     */\n    locator(selectorOrFunc) {\n      if (typeof selectorOrFunc === 'string') {\n        return NodeLocator.create(this, selectorOrFunc);\n      } else {\n        return FunctionLocator.create(this, selectorOrFunc);\n      }\n    }\n    /**\n     * Queries the frame for an element matching the given selector.\n     *\n     * @param selector -\n     * {@link https://pptr.dev/guides/page-interactions#selectors | selector}\n     * to query the page for.\n     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}\n     * can be passed as-is and a\n     * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}\n     * allows quering by\n     * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},\n     * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},\n     * and\n     * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}\n     * and\n     * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.\n     * Alternatively, you can specify the selector type using a\n     * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.\n     *\n     * @returns A {@link ElementHandle | element handle} to the first element\n     * matching the given selector. Otherwise, `null`.\n     */\n    async $(selector) {\n      // eslint-disable-next-line rulesdir/use-using -- This is cached.\n      const document = await this.#document();\n      return await document.$(selector);\n    }\n    /**\n     * Queries the frame for all elements matching the given selector.\n     *\n     * @param selector -\n     * {@link https://pptr.dev/guides/page-interactions#selectors | selector}\n     * to query the page for.\n     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}\n     * can be passed as-is and a\n     * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}\n     * allows quering by\n     * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},\n     * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},\n     * and\n     * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}\n     * and\n     * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.\n     * Alternatively, you can specify the selector type using a\n     * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.\n     *\n     * @returns An array of {@link ElementHandle | element handles} that point to\n     * elements matching the given selector.\n     */\n    async $$(selector, options) {\n      // eslint-disable-next-line rulesdir/use-using -- This is cached.\n      const document = await this.#document();\n      return await document.$$(selector, options);\n    }\n    /**\n     * Runs the given function on the first element matching the given selector in\n     * the frame.\n     *\n     * If the given function returns a promise, then this method will wait till\n     * the promise resolves.\n     *\n     * @example\n     *\n     * ```ts\n     * const searchValue = await frame.$eval('#search', el => el.value);\n     * ```\n     *\n     * @param selector -\n     * {@link https://pptr.dev/guides/page-interactions#selectors | selector}\n     * to query the page for.\n     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}\n     * can be passed as-is and a\n     * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}\n     * allows quering by\n     * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},\n     * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},\n     * and\n     * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}\n     * and\n     * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.\n     * Alternatively, you can specify the selector type using a\n     * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.\n     * @param pageFunction - The function to be evaluated in the frame's context.\n     * The first element matching the selector will be passed to the function as\n     * its first argument.\n     * @param args - Additional arguments to pass to `pageFunction`.\n     * @returns A promise to the result of the function.\n     */\n    async $eval(selector, pageFunction, ...args) {\n      pageFunction = withSourcePuppeteerURLIfNone(this.$eval.name, pageFunction);\n      // eslint-disable-next-line rulesdir/use-using -- This is cached.\n      const document = await this.#document();\n      return await document.$eval(selector, pageFunction, ...args);\n    }\n    /**\n     * Runs the given function on an array of elements matching the given selector\n     * in the frame.\n     *\n     * If the given function returns a promise, then this method will wait till\n     * the promise resolves.\n     *\n     * @example\n     *\n     * ```ts\n     * const divsCounts = await frame.$$eval('div', divs => divs.length);\n     * ```\n     *\n     * @param selector -\n     * {@link https://pptr.dev/guides/page-interactions#selectors | selector}\n     * to query the page for.\n     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}\n     * can be passed as-is and a\n     * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}\n     * allows quering by\n     * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},\n     * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},\n     * and\n     * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}\n     * and\n     * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.\n     * Alternatively, you can specify the selector type using a\n     * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.\n     * @param pageFunction - The function to be evaluated in the frame's context.\n     * An array of elements matching the given selector will be passed to the\n     * function as its first argument.\n     * @param args - Additional arguments to pass to `pageFunction`.\n     * @returns A promise to the result of the function.\n     */\n    async $$eval(selector, pageFunction, ...args) {\n      pageFunction = withSourcePuppeteerURLIfNone(this.$$eval.name, pageFunction);\n      // eslint-disable-next-line rulesdir/use-using -- This is cached.\n      const document = await this.#document();\n      return await document.$$eval(selector, pageFunction, ...args);\n    }\n    /**\n     * Waits for an element matching the given selector to appear in the frame.\n     *\n     * This method works across navigations.\n     *\n     * @example\n     *\n     * ```ts\n     * import puppeteer from 'puppeteer';\n     *\n     * (async () => {\n     *   const browser = await puppeteer.launch();\n     *   const page = await browser.newPage();\n     *   let currentURL;\n     *   page\n     *     .mainFrame()\n     *     .waitForSelector('img')\n     *     .then(() => console.log('First URL with image: ' + currentURL));\n     *\n     *   for (currentURL of [\n     *     'https://example.com',\n     *     'https://google.com',\n     *     'https://bbc.com',\n     *   ]) {\n     *     await page.goto(currentURL);\n     *   }\n     *   await browser.close();\n     * })();\n     * ```\n     *\n     * @param selector - The selector to query and wait for.\n     * @param options - Options for customizing waiting behavior.\n     * @returns An element matching the given selector.\n     * @throws Throws if an element matching the given selector doesn't appear.\n     */\n    async waitForSelector(selector, options = {}) {\n      const {\n        updatedSelector,\n        QueryHandler,\n        polling\n      } = getQueryHandlerAndSelector(selector);\n      return await QueryHandler.waitFor(this, updatedSelector, {\n        polling,\n        ...options\n      });\n    }\n    /**\n     * @example\n     * The `waitForFunction` can be used to observe viewport size change:\n     *\n     * ```ts\n     * import puppeteer from 'puppeteer';\n     *\n     * (async () => {\n     * .  const browser = await puppeteer.launch();\n     * .  const page = await browser.newPage();\n     * .  const watchDog = page.mainFrame().waitForFunction('window.innerWidth < 100');\n     * .  page.setViewport({width: 50, height: 50});\n     * .  await watchDog;\n     * .  await browser.close();\n     * })();\n     * ```\n     *\n     * To pass arguments from Node.js to the predicate of `page.waitForFunction` function:\n     *\n     * ```ts\n     * const selector = '.foo';\n     * await frame.waitForFunction(\n     *   selector => !!document.querySelector(selector),\n     *   {}, // empty options object\n     *   selector\n     * );\n     * ```\n     *\n     * @param pageFunction - the function to evaluate in the frame context.\n     * @param options - options to configure the polling method and timeout.\n     * @param args - arguments to pass to the `pageFunction`.\n     * @returns the promise which resolve when the `pageFunction` returns a truthy value.\n     */\n    async waitForFunction(pageFunction, options = {}, ...args) {\n      return await this.mainRealm().waitForFunction(pageFunction, options, ...args);\n    }\n    /**\n     * The full HTML contents of the frame, including the DOCTYPE.\n     */\n    async content() {\n      return await this.evaluate(() => {\n        let content = '';\n        for (const node of document.childNodes) {\n          switch (node) {\n            case document.documentElement:\n              content += document.documentElement.outerHTML;\n              break;\n            default:\n              content += new XMLSerializer().serializeToString(node);\n              break;\n          }\n        }\n        return content;\n      });\n    }\n    /**\n     * @internal\n     */\n    async setFrameContent(content) {\n      return await this.evaluate(html => {\n        document.open();\n        document.write(html);\n        document.close();\n      }, content);\n    }\n    /**\n     * The frame's `name` attribute as specified in the tag.\n     *\n     * @remarks\n     * If the name is empty, it returns the `id` attribute instead.\n     *\n     * @remarks\n     * This value is calculated once when the frame is created, and will not\n     * update if the attribute is changed later.\n     *\n     * @deprecated Use\n     *\n     * ```ts\n     * const element = await frame.frameElement();\n     * const nameOrId = await element.evaluate(frame => frame.name ?? frame.id);\n     * ```\n     */\n    name() {\n      return this._name || '';\n    }\n    /**\n     * Is`true` if the frame has been detached. Otherwise, `false`.\n     *\n     * @deprecated Use the `detached` getter.\n     */\n    isDetached() {\n      return this.detached;\n    }\n    /**\n     * @internal\n     */\n    get disposed() {\n      return this.detached;\n    }\n    /**\n     * Adds a `<script>` tag into the page with the desired url or content.\n     *\n     * @param options - Options for the script.\n     * @returns An {@link ElementHandle | element handle} to the injected\n     * `<script>` element.\n     */\n    async addScriptTag(options) {\n      let {\n        content = '',\n        type\n      } = options;\n      const {\n        path\n      } = options;\n      if (+!!options.url + +!!path + +!!content !== 1) {\n        throw new Error('Exactly one of `url`, `path`, or `content` must be specified.');\n      }\n      if (path) {\n        content = await environment.value.fs.promises.readFile(path, 'utf8');\n        content += `//# sourceURL=${path.replace(/\\n/g, '')}`;\n      }\n      type = type ?? 'text/javascript';\n      return await this.mainRealm().transferHandle(await this.isolatedRealm().evaluateHandle(async ({\n        url,\n        id,\n        type,\n        content\n      }) => {\n        return await new Promise((resolve, reject) => {\n          const script = document.createElement('script');\n          script.type = type;\n          script.text = content;\n          script.addEventListener('error', event => {\n            reject(new Error(event.message ?? 'Could not load script'));\n          }, {\n            once: true\n          });\n          if (id) {\n            script.id = id;\n          }\n          if (url) {\n            script.src = url;\n            script.addEventListener('load', () => {\n              resolve(script);\n            }, {\n              once: true\n            });\n            document.head.appendChild(script);\n          } else {\n            document.head.appendChild(script);\n            resolve(script);\n          }\n        });\n      }, {\n        ...options,\n        type,\n        content\n      }));\n    }\n    /**\n     * @internal\n     */\n    async addStyleTag(options) {\n      let {\n        content = ''\n      } = options;\n      const {\n        path\n      } = options;\n      if (+!!options.url + +!!path + +!!content !== 1) {\n        throw new Error('Exactly one of `url`, `path`, or `content` must be specified.');\n      }\n      if (path) {\n        content = await environment.value.fs.promises.readFile(path, 'utf8');\n        content += '/*# sourceURL=' + path.replace(/\\n/g, '') + '*/';\n        options.content = content;\n      }\n      return await this.mainRealm().transferHandle(await this.isolatedRealm().evaluateHandle(async ({\n        url,\n        content\n      }) => {\n        return await new Promise((resolve, reject) => {\n          let element;\n          if (!url) {\n            element = document.createElement('style');\n            element.appendChild(document.createTextNode(content));\n          } else {\n            const link = document.createElement('link');\n            link.rel = 'stylesheet';\n            link.href = url;\n            element = link;\n          }\n          element.addEventListener('load', () => {\n            resolve(element);\n          }, {\n            once: true\n          });\n          element.addEventListener('error', event => {\n            reject(new Error(event.message ?? 'Could not load style'));\n          }, {\n            once: true\n          });\n          document.head.appendChild(element);\n          return element;\n        });\n      }, options));\n    }\n    /**\n     * Clicks the first element found that matches `selector`.\n     *\n     * @remarks\n     * If `click()` triggers a navigation event and there's a separate\n     * `page.waitForNavigation()` promise to be resolved, you may end up with a\n     * race condition that yields unexpected results. The correct pattern for\n     * click and wait for navigation is the following:\n     *\n     * ```ts\n     * const [response] = await Promise.all([\n     *   page.waitForNavigation(waitOptions),\n     *   frame.click(selector, clickOptions),\n     * ]);\n     * ```\n     *\n     * @param selector - The selector to query for.\n     */\n    async click(selector, options = {}) {\n      const env_3 = {\n        stack: [],\n        error: void 0,\n        hasError: false\n      };\n      try {\n        const handle = __addDisposableResource(env_3, await this.$(selector), false);\n        assert(handle, `No element found for selector: ${selector}`);\n        await handle.click(options);\n        await handle.dispose();\n      } catch (e_3) {\n        env_3.error = e_3;\n        env_3.hasError = true;\n      } finally {\n        __disposeResources(env_3);\n      }\n    }\n    /**\n     * Focuses the first element that matches the `selector`.\n     *\n     * @param selector - The selector to query for.\n     * @throws Throws if there's no element matching `selector`.\n     */\n    async focus(selector) {\n      const env_4 = {\n        stack: [],\n        error: void 0,\n        hasError: false\n      };\n      try {\n        const handle = __addDisposableResource(env_4, await this.$(selector), false);\n        assert(handle, `No element found for selector: ${selector}`);\n        await handle.focus();\n      } catch (e_4) {\n        env_4.error = e_4;\n        env_4.hasError = true;\n      } finally {\n        __disposeResources(env_4);\n      }\n    }\n    /**\n     * Hovers the pointer over the center of the first element that matches the\n     * `selector`.\n     *\n     * @param selector - The selector to query for.\n     * @throws Throws if there's no element matching `selector`.\n     */\n    async hover(selector) {\n      const env_5 = {\n        stack: [],\n        error: void 0,\n        hasError: false\n      };\n      try {\n        const handle = __addDisposableResource(env_5, await this.$(selector), false);\n        assert(handle, `No element found for selector: ${selector}`);\n        await handle.hover();\n      } catch (e_5) {\n        env_5.error = e_5;\n        env_5.hasError = true;\n      } finally {\n        __disposeResources(env_5);\n      }\n    }\n    /**\n     * Selects a set of value on the first `<select>` element that matches the\n     * `selector`.\n     *\n     * @example\n     *\n     * ```ts\n     * frame.select('select#colors', 'blue'); // single selection\n     * frame.select('select#colors', 'red', 'green', 'blue'); // multiple selections\n     * ```\n     *\n     * @param selector - The selector to query for.\n     * @param values - The array of values to select. If the `<select>` has the\n     * `multiple` attribute, all values are considered, otherwise only the first\n     * one is taken into account.\n     * @returns the list of values that were successfully selected.\n     * @throws Throws if there's no `<select>` matching `selector`.\n     */\n    async select(selector, ...values) {\n      const env_6 = {\n        stack: [],\n        error: void 0,\n        hasError: false\n      };\n      try {\n        const handle = __addDisposableResource(env_6, await this.$(selector), false);\n        assert(handle, `No element found for selector: ${selector}`);\n        return await handle.select(...values);\n      } catch (e_6) {\n        env_6.error = e_6;\n        env_6.hasError = true;\n      } finally {\n        __disposeResources(env_6);\n      }\n    }\n    /**\n     * Taps the first element that matches the `selector`.\n     *\n     * @param selector - The selector to query for.\n     * @throws Throws if there's no element matching `selector`.\n     */\n    async tap(selector) {\n      const env_7 = {\n        stack: [],\n        error: void 0,\n        hasError: false\n      };\n      try {\n        const handle = __addDisposableResource(env_7, await this.$(selector), false);\n        assert(handle, `No element found for selector: ${selector}`);\n        await handle.tap();\n      } catch (e_7) {\n        env_7.error = e_7;\n        env_7.hasError = true;\n      } finally {\n        __disposeResources(env_7);\n      }\n    }\n    /**\n     * Sends a `keydown`, `keypress`/`input`, and `keyup` event for each character\n     * in the text.\n     *\n     * @remarks\n     * To press a special key, like `Control` or `ArrowDown`, use\n     * {@link Keyboard.press}.\n     *\n     * @example\n     *\n     * ```ts\n     * await frame.type('#mytextarea', 'Hello'); // Types instantly\n     * await frame.type('#mytextarea', 'World', {delay: 100}); // Types slower, like a user\n     * ```\n     *\n     * @param selector - the selector for the element to type into. If there are\n     * multiple the first will be used.\n     * @param text - text to type into the element\n     * @param options - takes one option, `delay`, which sets the time to wait\n     * between key presses in milliseconds. Defaults to `0`.\n     */\n    async type(selector, text, options) {\n      const env_8 = {\n        stack: [],\n        error: void 0,\n        hasError: false\n      };\n      try {\n        const handle = __addDisposableResource(env_8, await this.$(selector), false);\n        assert(handle, `No element found for selector: ${selector}`);\n        await handle.type(text, options);\n      } catch (e_8) {\n        env_8.error = e_8;\n        env_8.hasError = true;\n      } finally {\n        __disposeResources(env_8);\n      }\n    }\n    /**\n     * The frame's title.\n     */\n    async title() {\n      return await this.isolatedRealm().evaluate(() => {\n        return document.title;\n      });\n    }\n  };\n})();\nexport { Frame };","map":{"version":3,"names":["EventEmitter","getQueryHandlerAndSelector","transposeIterableHandle","withSourcePuppeteerURLIfNone","environment","assert","throwIfDisposed","FunctionLocator","NodeLocator","FrameEvent","FrameNavigated","Symbol","FrameSwapped","LifecycleEvent","FrameNavigatedWithinDocument","FrameDetached","FrameSwappedByActivation","throwIfDetached","frame","_id","Frame","_classSuper","__esDecorate","_frameElement_decorators","kind","name","static","private","access","has","obj","get","frameElement","metadata","_metadata","_instanceExtraInitializers","_evaluateHandle_decorators","evaluateHandle","_evaluate_decorators","evaluate","_locator_decorators","locator","_$_decorators","$","_$$_decorators","$$","_$eval_decorators","$eval","_$$eval_decorators","$$eval","_waitForSelector_decorators","waitForSelector","_waitForFunction_decorators","waitForFunction","_content_decorators","content","_addScriptTag_decorators","addScriptTag","_addStyleTag_decorators","addStyleTag","_click_decorators","click","_focus_decorators","focus","_hover_decorators","hover","_select_decorators","select","_tap_decorators","tap","_type_decorators","type","_title_decorators","title","__runInitializers","_parentId","_name","_hasStartedLoading","constructor","_document","document","#document","mainRealm","clearDocumentHandle","undefined","parentFrame","list","__addDisposableResource","env_1","isolatedRealm","querySelectorAll","iframe_1","iframe","env_2","contentFrame","move","pageFunction","args","selectorOrFunc","create","selector","options","updatedSelector","QueryHandler","polling","waitFor","node","childNodes","documentElement","outerHTML","XMLSerializer","serializeToString","setFrameContent","html","open","write","close","isDetached","detached","disposed","path","url","Error","value","fs","promises","readFile","replace","transferHandle","id","Promise","resolve","reject","script","createElement","text","addEventListener","event","message","once","src","head","appendChild","element","createTextNode","link","rel","href","handle","env_3","dispose","env_4","env_5","values","env_6","env_7","env_8"],"sources":["C:\\Users\\raffy\\Desktop\\test\\node_modules\\puppeteer-core\\src\\api\\Frame.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2023 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport type Protocol from 'devtools-protocol';\n\nimport type {ClickOptions, ElementHandle} from '../api/ElementHandle.js';\nimport type {HTTPResponse} from '../api/HTTPResponse.js';\nimport type {\n  Page,\n  QueryOptions,\n  WaitForSelectorOptions,\n  WaitTimeoutOptions,\n} from '../api/Page.js';\nimport type {Accessibility} from '../cdp/Accessibility.js';\nimport type {DeviceRequestPrompt} from '../cdp/DeviceRequestPrompt.js';\nimport type {PuppeteerLifeCycleEvent} from '../cdp/LifecycleWatcher.js';\nimport {EventEmitter, type EventType} from '../common/EventEmitter.js';\nimport {getQueryHandlerAndSelector} from '../common/GetQueryHandler.js';\nimport {transposeIterableHandle} from '../common/HandleIterator.js';\nimport type {\n  Awaitable,\n  EvaluateFunc,\n  EvaluateFuncWith,\n  HandleFor,\n  NodeFor,\n} from '../common/types.js';\nimport {withSourcePuppeteerURLIfNone} from '../common/util.js';\nimport {environment} from '../environment.js';\nimport {assert} from '../util/assert.js';\nimport {throwIfDisposed} from '../util/decorators.js';\n\nimport type {CDPSession} from './CDPSession.js';\nimport type {KeyboardTypeOptions} from './Input.js';\nimport {\n  FunctionLocator,\n  NodeLocator,\n  type Locator,\n} from './locators/locators.js';\nimport type {Realm} from './Realm.js';\n\n/**\n * @public\n */\nexport interface WaitForOptions {\n  /**\n   * Maximum wait time in milliseconds. Pass 0 to disable the timeout.\n   *\n   * The default value can be changed by using the\n   * {@link Page.setDefaultTimeout} or {@link Page.setDefaultNavigationTimeout}\n   * methods.\n   *\n   * @defaultValue `30000`\n   */\n  timeout?: number;\n  /**\n   * When to consider waiting succeeds. Given an array of event strings, waiting\n   * is considered to be successful after all events have been fired.\n   *\n   * @defaultValue `'load'`\n   */\n  waitUntil?: PuppeteerLifeCycleEvent | PuppeteerLifeCycleEvent[];\n  /**\n   * @internal\n   */\n  ignoreSameDocumentNavigation?: boolean;\n  /**\n   * A signal object that allows you to cancel the call.\n   */\n  signal?: AbortSignal;\n}\n\n/**\n * @public\n */\nexport interface GoToOptions extends WaitForOptions {\n  /**\n   * If provided, it will take preference over the referer header value set by\n   * {@link Page.setExtraHTTPHeaders | page.setExtraHTTPHeaders()}.\n   */\n  referer?: string;\n  /**\n   * If provided, it will take preference over the referer-policy header value\n   * set by {@link Page.setExtraHTTPHeaders | page.setExtraHTTPHeaders()}.\n   */\n  referrerPolicy?: string;\n}\n\n/**\n * @public\n */\nexport interface FrameWaitForFunctionOptions {\n  /**\n   * An interval at which the `pageFunction` is executed, defaults to `raf`. If\n   * `polling` is a number, then it is treated as an interval in milliseconds at\n   * which the function would be executed. If `polling` is a string, then it can\n   * be one of the following values:\n   *\n   * - `raf` - to constantly execute `pageFunction` in `requestAnimationFrame`\n   *   callback. This is the tightest polling mode which is suitable to observe\n   *   styling changes.\n   *\n   * - `mutation` - to execute `pageFunction` on every DOM mutation.\n   */\n  polling?: 'raf' | 'mutation' | number;\n  /**\n   * Maximum time to wait in milliseconds. Defaults to `30000` (30 seconds).\n   * Pass `0` to disable the timeout. Puppeteer's default timeout can be changed\n   * using {@link Page.setDefaultTimeout}.\n   */\n  timeout?: number;\n  /**\n   * A signal object that allows you to cancel a waitForFunction call.\n   */\n  signal?: AbortSignal;\n}\n\n/**\n * @public\n */\nexport interface FrameAddScriptTagOptions {\n  /**\n   * URL of the script to be added.\n   */\n  url?: string;\n  /**\n   * Path to a JavaScript file to be injected into the frame.\n   *\n   * @remarks\n   * If `path` is a relative path, it is resolved relative to the current\n   * working directory (`process.cwd()` in Node.js).\n   */\n  path?: string;\n  /**\n   * JavaScript to be injected into the frame.\n   */\n  content?: string;\n  /**\n   * Sets the `type` of the script. Use `module` in order to load an ES2015 module.\n   */\n  type?: string;\n  /**\n   * Sets the `id` of the script.\n   */\n  id?: string;\n}\n\n/**\n * @public\n */\nexport interface FrameAddStyleTagOptions {\n  /**\n   * the URL of the CSS file to be added.\n   */\n  url?: string;\n  /**\n   * The path to a CSS file to be injected into the frame.\n   * @remarks\n   * If `path` is a relative path, it is resolved relative to the current\n   * working directory (`process.cwd()` in Node.js).\n   */\n  path?: string;\n  /**\n   * Raw CSS content to be injected into the frame.\n   */\n  content?: string;\n}\n\n/**\n * @public\n */\nexport interface FrameEvents extends Record<EventType, unknown> {\n  /** @internal */\n  [FrameEvent.FrameNavigated]: Protocol.Page.NavigationType;\n  /** @internal */\n  [FrameEvent.FrameSwapped]: undefined;\n  /** @internal */\n  [FrameEvent.LifecycleEvent]: undefined;\n  /** @internal */\n  [FrameEvent.FrameNavigatedWithinDocument]: undefined;\n  /** @internal */\n  [FrameEvent.FrameDetached]: Frame;\n  /** @internal */\n  [FrameEvent.FrameSwappedByActivation]: undefined;\n}\n\n/**\n * We use symbols to prevent external parties listening to these events.\n * They are internal to Puppeteer.\n *\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport namespace FrameEvent {\n  export const FrameNavigated = Symbol('Frame.FrameNavigated');\n  export const FrameSwapped = Symbol('Frame.FrameSwapped');\n  export const LifecycleEvent = Symbol('Frame.LifecycleEvent');\n  export const FrameNavigatedWithinDocument = Symbol(\n    'Frame.FrameNavigatedWithinDocument'\n  );\n  export const FrameDetached = Symbol('Frame.FrameDetached');\n  export const FrameSwappedByActivation = Symbol(\n    'Frame.FrameSwappedByActivation'\n  );\n}\n\n/**\n * @internal\n */\nexport const throwIfDetached = throwIfDisposed<Frame>(frame => {\n  return `Attempted to use detached Frame '${frame._id}'.`;\n});\n\n/**\n * Represents a DOM frame.\n *\n * To understand frames, you can think of frames as `<iframe>` elements. Just\n * like iframes, frames can be nested, and when JavaScript is executed in a\n * frame, the JavaScript does not effect frames inside the ambient frame the\n * JavaScript executes in.\n *\n * @example\n * At any point in time, {@link Page | pages} expose their current frame\n * tree via the {@link Page.mainFrame} and {@link Frame.childFrames} methods.\n *\n * @example\n * An example of dumping frame tree:\n *\n * ```ts\n * import puppeteer from 'puppeteer';\n *\n * (async () => {\n *   const browser = await puppeteer.launch();\n *   const page = await browser.newPage();\n *   await page.goto('https://www.google.com/chrome/browser/canary.html');\n *   dumpFrameTree(page.mainFrame(), '');\n *   await browser.close();\n *\n *   function dumpFrameTree(frame, indent) {\n *     console.log(indent + frame.url());\n *     for (const child of frame.childFrames()) {\n *       dumpFrameTree(child, indent + '  ');\n *     }\n *   }\n * })();\n * ```\n *\n * @example\n * An example of getting text from an iframe element:\n *\n * ```ts\n * const frame = page.frames().find(frame => frame.name() === 'myframe');\n * const text = await frame.$eval('.selector', element => element.textContent);\n * console.log(text);\n * ```\n *\n * @remarks\n * Frame lifecycles are controlled by three events that are all dispatched on\n * the parent {@link Frame.page | page}:\n *\n * - {@link PageEvent.FrameAttached}\n * - {@link PageEvent.FrameNavigated}\n * - {@link PageEvent.FrameDetached}\n *\n * @public\n */\nexport abstract class Frame extends EventEmitter<FrameEvents> {\n  /**\n   * @internal\n   */\n  _id!: string;\n  /**\n   * @internal\n   */\n  _parentId?: string;\n\n  /**\n   * @internal\n   */\n  _name?: string;\n\n  /**\n   * @internal\n   */\n  _hasStartedLoading = false;\n\n  /**\n   * @internal\n   */\n  constructor() {\n    super();\n  }\n\n  /**\n   * The page associated with the frame.\n   */\n  abstract page(): Page;\n\n  /**\n   * Navigates the frame or page to the given `url`.\n   *\n   * @remarks\n   * Navigation to `about:blank` or navigation to the same URL with a different\n   * hash will succeed and return `null`.\n   *\n   * :::warning\n   *\n   * Headless shell mode doesn't support navigation to a PDF document. See the\n   * {@link https://crbug.com/761295 | upstream issue}.\n   *\n   * :::\n   *\n   * In headless shell, this method will not throw an error when any valid HTTP\n   * status code is returned by the remote server, including 404 \"Not Found\" and\n   * 500 \"Internal Server Error\". The status code for such responses can be\n   * retrieved by calling {@link HTTPResponse.status}.\n   *\n   * @param url - URL to navigate the frame to. The URL should include scheme,\n   * e.g. `https://`\n   * @param options - Options to configure waiting behavior.\n   * @returns A promise which resolves to the main resource response. In case of\n   * multiple redirects, the navigation will resolve with the response of the\n   * last redirect.\n   * @throws If:\n   *\n   * - there's an SSL error (e.g. in case of self-signed certificates).\n   *\n   * - target URL is invalid.\n   *\n   * - the timeout is exceeded during navigation.\n   *\n   * - the remote server does not respond or is unreachable.\n   *\n   * - the main resource failed to load.\n   */\n  abstract goto(\n    url: string,\n    options?: GoToOptions\n  ): Promise<HTTPResponse | null>;\n\n  /**\n   * Waits for the frame to navigate. It is useful for when you run code which\n   * will indirectly cause the frame to navigate.\n   *\n   * Usage of the\n   * {@link https://developer.mozilla.org/en-US/docs/Web/API/History_API | History API}\n   * to change the URL is considered a navigation.\n   *\n   * @example\n   *\n   * ```ts\n   * const [response] = await Promise.all([\n   *   // The navigation promise resolves after navigation has finished\n   *   frame.waitForNavigation(),\n   *   // Clicking the link will indirectly cause a navigation\n   *   frame.click('a.my-link'),\n   * ]);\n   * ```\n   *\n   * @param options - Options to configure waiting behavior.\n   * @returns A promise which resolves to the main resource response.\n   */\n  abstract waitForNavigation(\n    options?: WaitForOptions\n  ): Promise<HTTPResponse | null>;\n\n  /**\n   * @internal\n   */\n  abstract get client(): CDPSession;\n\n  /**\n   * @internal\n   */\n  abstract get accessibility(): Accessibility;\n\n  /**\n   * @internal\n   */\n  abstract mainRealm(): Realm;\n\n  /**\n   * @internal\n   */\n  abstract isolatedRealm(): Realm;\n\n  #_document: Promise<ElementHandle<Document>> | undefined;\n\n  /**\n   * @internal\n   */\n  #document(): Promise<ElementHandle<Document>> {\n    if (!this.#_document) {\n      this.#_document = this.mainRealm().evaluateHandle(() => {\n        return document;\n      });\n    }\n    return this.#_document;\n  }\n\n  /**\n   * Used to clear the document handle that has been destroyed.\n   *\n   * @internal\n   */\n  clearDocumentHandle(): void {\n    this.#_document = undefined;\n  }\n\n  /**\n   * @returns The frame element associated with this frame (if any).\n   */\n  @throwIfDetached\n  async frameElement(): Promise<HandleFor<HTMLIFrameElement> | null> {\n    const parentFrame = this.parentFrame();\n    if (!parentFrame) {\n      return null;\n    }\n    using list = await parentFrame.isolatedRealm().evaluateHandle(() => {\n      return document.querySelectorAll('iframe,frame');\n    });\n    for await (using iframe of transposeIterableHandle(list)) {\n      const frame = await iframe.contentFrame();\n      if (frame?._id === this._id) {\n        return (iframe as HandleFor<HTMLIFrameElement>).move();\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Behaves identically to {@link Page.evaluateHandle} except it's run within\n   * the context of this frame.\n   *\n   * See {@link Page.evaluateHandle} for details.\n   */\n  @throwIfDetached\n  async evaluateHandle<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<HandleFor<Awaited<ReturnType<Func>>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(\n      this.evaluateHandle.name,\n      pageFunction\n    );\n    return await this.mainRealm().evaluateHandle(pageFunction, ...args);\n  }\n\n  /**\n   * Behaves identically to {@link Page.evaluate} except it's run within\n   * the context of this frame.\n   *\n   * See {@link Page.evaluate} for details.\n   */\n  @throwIfDetached\n  async evaluate<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<Awaited<ReturnType<Func>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(\n      this.evaluate.name,\n      pageFunction\n    );\n    return await this.mainRealm().evaluate(pageFunction, ...args);\n  }\n\n  /**\n   * Creates a locator for the provided selector. See {@link Locator} for\n   * details and supported actions.\n   *\n   * @param selector -\n   * {@link https://pptr.dev/guides/page-interactions#selectors | selector}\n   * to query the page for.\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}\n   * can be passed as-is and a\n   * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}\n   * allows quering by\n   * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},\n   * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},\n   * and\n   * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}\n   * and\n   * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.\n   * Alternatively, you can specify the selector type using a\n   * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.\n   */\n  locator<Selector extends string>(\n    selector: Selector\n  ): Locator<NodeFor<Selector>>;\n\n  /**\n   * Creates a locator for the provided function. See {@link Locator} for\n   * details and supported actions.\n   */\n  locator<Ret>(func: () => Awaitable<Ret>): Locator<Ret>;\n\n  /**\n   * @internal\n   */\n  @throwIfDetached\n  locator<Selector extends string, Ret>(\n    selectorOrFunc: Selector | (() => Awaitable<Ret>)\n  ): Locator<NodeFor<Selector>> | Locator<Ret> {\n    if (typeof selectorOrFunc === 'string') {\n      return NodeLocator.create(this, selectorOrFunc);\n    } else {\n      return FunctionLocator.create(this, selectorOrFunc);\n    }\n  }\n  /**\n   * Queries the frame for an element matching the given selector.\n   *\n   * @param selector -\n   * {@link https://pptr.dev/guides/page-interactions#selectors | selector}\n   * to query the page for.\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}\n   * can be passed as-is and a\n   * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}\n   * allows quering by\n   * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},\n   * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},\n   * and\n   * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}\n   * and\n   * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.\n   * Alternatively, you can specify the selector type using a\n   * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.\n   *\n   * @returns A {@link ElementHandle | element handle} to the first element\n   * matching the given selector. Otherwise, `null`.\n   */\n  @throwIfDetached\n  async $<Selector extends string>(\n    selector: Selector\n  ): Promise<ElementHandle<NodeFor<Selector>> | null> {\n    // eslint-disable-next-line rulesdir/use-using -- This is cached.\n    const document = await this.#document();\n    return await document.$(selector);\n  }\n\n  /**\n   * Queries the frame for all elements matching the given selector.\n   *\n   * @param selector -\n   * {@link https://pptr.dev/guides/page-interactions#selectors | selector}\n   * to query the page for.\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}\n   * can be passed as-is and a\n   * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}\n   * allows quering by\n   * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},\n   * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},\n   * and\n   * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}\n   * and\n   * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.\n   * Alternatively, you can specify the selector type using a\n   * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.\n   *\n   * @returns An array of {@link ElementHandle | element handles} that point to\n   * elements matching the given selector.\n   */\n  @throwIfDetached\n  async $$<Selector extends string>(\n    selector: Selector,\n    options?: QueryOptions\n  ): Promise<Array<ElementHandle<NodeFor<Selector>>>> {\n    // eslint-disable-next-line rulesdir/use-using -- This is cached.\n    const document = await this.#document();\n    return await document.$$(selector, options);\n  }\n\n  /**\n   * Runs the given function on the first element matching the given selector in\n   * the frame.\n   *\n   * If the given function returns a promise, then this method will wait till\n   * the promise resolves.\n   *\n   * @example\n   *\n   * ```ts\n   * const searchValue = await frame.$eval('#search', el => el.value);\n   * ```\n   *\n   * @param selector -\n   * {@link https://pptr.dev/guides/page-interactions#selectors | selector}\n   * to query the page for.\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}\n   * can be passed as-is and a\n   * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}\n   * allows quering by\n   * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},\n   * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},\n   * and\n   * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}\n   * and\n   * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.\n   * Alternatively, you can specify the selector type using a\n   * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.\n   * @param pageFunction - The function to be evaluated in the frame's context.\n   * The first element matching the selector will be passed to the function as\n   * its first argument.\n   * @param args - Additional arguments to pass to `pageFunction`.\n   * @returns A promise to the result of the function.\n   */\n  @throwIfDetached\n  async $eval<\n    Selector extends string,\n    Params extends unknown[],\n    Func extends EvaluateFuncWith<NodeFor<Selector>, Params> = EvaluateFuncWith<\n      NodeFor<Selector>,\n      Params\n    >,\n  >(\n    selector: Selector,\n    pageFunction: string | Func,\n    ...args: Params\n  ): Promise<Awaited<ReturnType<Func>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(this.$eval.name, pageFunction);\n    // eslint-disable-next-line rulesdir/use-using -- This is cached.\n    const document = await this.#document();\n    return await document.$eval(selector, pageFunction, ...args);\n  }\n\n  /**\n   * Runs the given function on an array of elements matching the given selector\n   * in the frame.\n   *\n   * If the given function returns a promise, then this method will wait till\n   * the promise resolves.\n   *\n   * @example\n   *\n   * ```ts\n   * const divsCounts = await frame.$$eval('div', divs => divs.length);\n   * ```\n   *\n   * @param selector -\n   * {@link https://pptr.dev/guides/page-interactions#selectors | selector}\n   * to query the page for.\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}\n   * can be passed as-is and a\n   * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}\n   * allows quering by\n   * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},\n   * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},\n   * and\n   * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}\n   * and\n   * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.\n   * Alternatively, you can specify the selector type using a\n   * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.\n   * @param pageFunction - The function to be evaluated in the frame's context.\n   * An array of elements matching the given selector will be passed to the\n   * function as its first argument.\n   * @param args - Additional arguments to pass to `pageFunction`.\n   * @returns A promise to the result of the function.\n   */\n  @throwIfDetached\n  async $$eval<\n    Selector extends string,\n    Params extends unknown[],\n    Func extends EvaluateFuncWith<\n      Array<NodeFor<Selector>>,\n      Params\n    > = EvaluateFuncWith<Array<NodeFor<Selector>>, Params>,\n  >(\n    selector: Selector,\n    pageFunction: string | Func,\n    ...args: Params\n  ): Promise<Awaited<ReturnType<Func>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(this.$$eval.name, pageFunction);\n    // eslint-disable-next-line rulesdir/use-using -- This is cached.\n    const document = await this.#document();\n    return await document.$$eval(selector, pageFunction, ...args);\n  }\n\n  /**\n   * Waits for an element matching the given selector to appear in the frame.\n   *\n   * This method works across navigations.\n   *\n   * @example\n   *\n   * ```ts\n   * import puppeteer from 'puppeteer';\n   *\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   const page = await browser.newPage();\n   *   let currentURL;\n   *   page\n   *     .mainFrame()\n   *     .waitForSelector('img')\n   *     .then(() => console.log('First URL with image: ' + currentURL));\n   *\n   *   for (currentURL of [\n   *     'https://example.com',\n   *     'https://google.com',\n   *     'https://bbc.com',\n   *   ]) {\n   *     await page.goto(currentURL);\n   *   }\n   *   await browser.close();\n   * })();\n   * ```\n   *\n   * @param selector - The selector to query and wait for.\n   * @param options - Options for customizing waiting behavior.\n   * @returns An element matching the given selector.\n   * @throws Throws if an element matching the given selector doesn't appear.\n   */\n  @throwIfDetached\n  async waitForSelector<Selector extends string>(\n    selector: Selector,\n    options: WaitForSelectorOptions = {}\n  ): Promise<ElementHandle<NodeFor<Selector>> | null> {\n    const {updatedSelector, QueryHandler, polling} =\n      getQueryHandlerAndSelector(selector);\n    return (await QueryHandler.waitFor(this, updatedSelector, {\n      polling,\n      ...options,\n    })) as ElementHandle<NodeFor<Selector>> | null;\n  }\n\n  /**\n   * @example\n   * The `waitForFunction` can be used to observe viewport size change:\n   *\n   * ```ts\n   * import puppeteer from 'puppeteer';\n   *\n   * (async () => {\n   * .  const browser = await puppeteer.launch();\n   * .  const page = await browser.newPage();\n   * .  const watchDog = page.mainFrame().waitForFunction('window.innerWidth < 100');\n   * .  page.setViewport({width: 50, height: 50});\n   * .  await watchDog;\n   * .  await browser.close();\n   * })();\n   * ```\n   *\n   * To pass arguments from Node.js to the predicate of `page.waitForFunction` function:\n   *\n   * ```ts\n   * const selector = '.foo';\n   * await frame.waitForFunction(\n   *   selector => !!document.querySelector(selector),\n   *   {}, // empty options object\n   *   selector\n   * );\n   * ```\n   *\n   * @param pageFunction - the function to evaluate in the frame context.\n   * @param options - options to configure the polling method and timeout.\n   * @param args - arguments to pass to the `pageFunction`.\n   * @returns the promise which resolve when the `pageFunction` returns a truthy value.\n   */\n  @throwIfDetached\n  async waitForFunction<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(\n    pageFunction: Func | string,\n    options: FrameWaitForFunctionOptions = {},\n    ...args: Params\n  ): Promise<HandleFor<Awaited<ReturnType<Func>>>> {\n    return await (this.mainRealm().waitForFunction(\n      pageFunction,\n      options,\n      ...args\n    ) as Promise<HandleFor<Awaited<ReturnType<Func>>>>);\n  }\n  /**\n   * The full HTML contents of the frame, including the DOCTYPE.\n   */\n  @throwIfDetached\n  async content(): Promise<string> {\n    return await this.evaluate(() => {\n      let content = '';\n      for (const node of document.childNodes) {\n        switch (node) {\n          case document.documentElement:\n            content += document.documentElement.outerHTML;\n            break;\n          default:\n            content += new XMLSerializer().serializeToString(node);\n            break;\n        }\n      }\n\n      return content;\n    });\n  }\n\n  /**\n   * Set the content of the frame.\n   *\n   * @param html - HTML markup to assign to the page.\n   * @param options - Options to configure how long before timing out and at\n   * what point to consider the content setting successful.\n   */\n  abstract setContent(html: string, options?: WaitForOptions): Promise<void>;\n\n  /**\n   * @internal\n   */\n  async setFrameContent(content: string): Promise<void> {\n    return await this.evaluate(html => {\n      document.open();\n      document.write(html);\n      document.close();\n    }, content);\n  }\n\n  /**\n   * The frame's `name` attribute as specified in the tag.\n   *\n   * @remarks\n   * If the name is empty, it returns the `id` attribute instead.\n   *\n   * @remarks\n   * This value is calculated once when the frame is created, and will not\n   * update if the attribute is changed later.\n   *\n   * @deprecated Use\n   *\n   * ```ts\n   * const element = await frame.frameElement();\n   * const nameOrId = await element.evaluate(frame => frame.name ?? frame.id);\n   * ```\n   */\n  name(): string {\n    return this._name || '';\n  }\n\n  /**\n   * The frame's URL.\n   */\n  abstract url(): string;\n\n  /**\n   * The parent frame, if any. Detached and main frames return `null`.\n   */\n  abstract parentFrame(): Frame | null;\n\n  /**\n   * An array of child frames.\n   */\n  abstract childFrames(): Frame[];\n\n  /**\n   * @returns `true` if the frame has detached. `false` otherwise.\n   */\n  abstract get detached(): boolean;\n\n  /**\n   * Is`true` if the frame has been detached. Otherwise, `false`.\n   *\n   * @deprecated Use the `detached` getter.\n   */\n  isDetached(): boolean {\n    return this.detached;\n  }\n\n  /**\n   * @internal\n   */\n  get disposed(): boolean {\n    return this.detached;\n  }\n\n  /**\n   * Adds a `<script>` tag into the page with the desired url or content.\n   *\n   * @param options - Options for the script.\n   * @returns An {@link ElementHandle | element handle} to the injected\n   * `<script>` element.\n   */\n  @throwIfDetached\n  async addScriptTag(\n    options: FrameAddScriptTagOptions\n  ): Promise<ElementHandle<HTMLScriptElement>> {\n    let {content = '', type} = options;\n    const {path} = options;\n    if (+!!options.url + +!!path + +!!content !== 1) {\n      throw new Error(\n        'Exactly one of `url`, `path`, or `content` must be specified.'\n      );\n    }\n\n    if (path) {\n      content = await environment.value.fs.promises.readFile(path, 'utf8');\n      content += `//# sourceURL=${path.replace(/\\n/g, '')}`;\n    }\n\n    type = type ?? 'text/javascript';\n\n    return await this.mainRealm().transferHandle(\n      await this.isolatedRealm().evaluateHandle(\n        async ({url, id, type, content}) => {\n          return await new Promise<HTMLScriptElement>((resolve, reject) => {\n            const script = document.createElement('script');\n            script.type = type;\n            script.text = content;\n            script.addEventListener(\n              'error',\n              event => {\n                reject(new Error(event.message ?? 'Could not load script'));\n              },\n              {once: true}\n            );\n            if (id) {\n              script.id = id;\n            }\n            if (url) {\n              script.src = url;\n              script.addEventListener(\n                'load',\n                () => {\n                  resolve(script);\n                },\n                {once: true}\n              );\n              document.head.appendChild(script);\n            } else {\n              document.head.appendChild(script);\n              resolve(script);\n            }\n          });\n        },\n        {...options, type, content}\n      )\n    );\n  }\n\n  /**\n   * Adds a `HTMLStyleElement` into the frame with the desired URL\n   *\n   * @returns An {@link ElementHandle | element handle} to the loaded `<style>`\n   * element.\n   */\n  async addStyleTag(\n    options: Omit<FrameAddStyleTagOptions, 'url'>\n  ): Promise<ElementHandle<HTMLStyleElement>>;\n\n  /**\n   * Adds a `HTMLLinkElement` into the frame with the desired URL\n   *\n   * @returns An {@link ElementHandle | element handle} to the loaded `<link>`\n   * element.\n   */\n  async addStyleTag(\n    options: FrameAddStyleTagOptions\n  ): Promise<ElementHandle<HTMLLinkElement>>;\n\n  /**\n   * @internal\n   */\n  @throwIfDetached\n  async addStyleTag(\n    options: FrameAddStyleTagOptions\n  ): Promise<ElementHandle<HTMLStyleElement | HTMLLinkElement>> {\n    let {content = ''} = options;\n    const {path} = options;\n    if (+!!options.url + +!!path + +!!content !== 1) {\n      throw new Error(\n        'Exactly one of `url`, `path`, or `content` must be specified.'\n      );\n    }\n\n    if (path) {\n      content = await environment.value.fs.promises.readFile(path, 'utf8');\n      content += '/*# sourceURL=' + path.replace(/\\n/g, '') + '*/';\n      options.content = content;\n    }\n\n    return await this.mainRealm().transferHandle(\n      await this.isolatedRealm().evaluateHandle(async ({url, content}) => {\n        return await new Promise<HTMLStyleElement | HTMLLinkElement>(\n          (resolve, reject) => {\n            let element: HTMLStyleElement | HTMLLinkElement;\n            if (!url) {\n              element = document.createElement('style');\n              element.appendChild(document.createTextNode(content!));\n            } else {\n              const link = document.createElement('link');\n              link.rel = 'stylesheet';\n              link.href = url;\n              element = link;\n            }\n            element.addEventListener(\n              'load',\n              () => {\n                resolve(element);\n              },\n              {once: true}\n            );\n            element.addEventListener(\n              'error',\n              event => {\n                reject(\n                  new Error(\n                    (event as ErrorEvent).message ?? 'Could not load style'\n                  )\n                );\n              },\n              {once: true}\n            );\n            document.head.appendChild(element);\n            return element;\n          }\n        );\n      }, options)\n    );\n  }\n\n  /**\n   * Clicks the first element found that matches `selector`.\n   *\n   * @remarks\n   * If `click()` triggers a navigation event and there's a separate\n   * `page.waitForNavigation()` promise to be resolved, you may end up with a\n   * race condition that yields unexpected results. The correct pattern for\n   * click and wait for navigation is the following:\n   *\n   * ```ts\n   * const [response] = await Promise.all([\n   *   page.waitForNavigation(waitOptions),\n   *   frame.click(selector, clickOptions),\n   * ]);\n   * ```\n   *\n   * @param selector - The selector to query for.\n   */\n  @throwIfDetached\n  async click(\n    selector: string,\n    options: Readonly<ClickOptions> = {}\n  ): Promise<void> {\n    using handle = await this.$(selector);\n    assert(handle, `No element found for selector: ${selector}`);\n    await handle.click(options);\n    await handle.dispose();\n  }\n\n  /**\n   * Focuses the first element that matches the `selector`.\n   *\n   * @param selector - The selector to query for.\n   * @throws Throws if there's no element matching `selector`.\n   */\n  @throwIfDetached\n  async focus(selector: string): Promise<void> {\n    using handle = await this.$(selector);\n    assert(handle, `No element found for selector: ${selector}`);\n    await handle.focus();\n  }\n\n  /**\n   * Hovers the pointer over the center of the first element that matches the\n   * `selector`.\n   *\n   * @param selector - The selector to query for.\n   * @throws Throws if there's no element matching `selector`.\n   */\n  @throwIfDetached\n  async hover(selector: string): Promise<void> {\n    using handle = await this.$(selector);\n    assert(handle, `No element found for selector: ${selector}`);\n    await handle.hover();\n  }\n\n  /**\n   * Selects a set of value on the first `<select>` element that matches the\n   * `selector`.\n   *\n   * @example\n   *\n   * ```ts\n   * frame.select('select#colors', 'blue'); // single selection\n   * frame.select('select#colors', 'red', 'green', 'blue'); // multiple selections\n   * ```\n   *\n   * @param selector - The selector to query for.\n   * @param values - The array of values to select. If the `<select>` has the\n   * `multiple` attribute, all values are considered, otherwise only the first\n   * one is taken into account.\n   * @returns the list of values that were successfully selected.\n   * @throws Throws if there's no `<select>` matching `selector`.\n   */\n  @throwIfDetached\n  async select(selector: string, ...values: string[]): Promise<string[]> {\n    using handle = await this.$(selector);\n    assert(handle, `No element found for selector: ${selector}`);\n    return await handle.select(...values);\n  }\n\n  /**\n   * Taps the first element that matches the `selector`.\n   *\n   * @param selector - The selector to query for.\n   * @throws Throws if there's no element matching `selector`.\n   */\n  @throwIfDetached\n  async tap(selector: string): Promise<void> {\n    using handle = await this.$(selector);\n    assert(handle, `No element found for selector: ${selector}`);\n    await handle.tap();\n  }\n\n  /**\n   * Sends a `keydown`, `keypress`/`input`, and `keyup` event for each character\n   * in the text.\n   *\n   * @remarks\n   * To press a special key, like `Control` or `ArrowDown`, use\n   * {@link Keyboard.press}.\n   *\n   * @example\n   *\n   * ```ts\n   * await frame.type('#mytextarea', 'Hello'); // Types instantly\n   * await frame.type('#mytextarea', 'World', {delay: 100}); // Types slower, like a user\n   * ```\n   *\n   * @param selector - the selector for the element to type into. If there are\n   * multiple the first will be used.\n   * @param text - text to type into the element\n   * @param options - takes one option, `delay`, which sets the time to wait\n   * between key presses in milliseconds. Defaults to `0`.\n   */\n  @throwIfDetached\n  async type(\n    selector: string,\n    text: string,\n    options?: Readonly<KeyboardTypeOptions>\n  ): Promise<void> {\n    using handle = await this.$(selector);\n    assert(handle, `No element found for selector: ${selector}`);\n    await handle.type(text, options);\n  }\n\n  /**\n   * The frame's title.\n   */\n  @throwIfDetached\n  async title(): Promise<string> {\n    return await this.isolatedRealm().evaluate(() => {\n      return document.title;\n    });\n  }\n\n  /**\n   * This method is typically coupled with an action that triggers a device\n   * request from an api such as WebBluetooth.\n   *\n   * :::caution\n   *\n   * This must be called before the device request is made. It will not return a\n   * currently active device prompt.\n   *\n   * :::\n   *\n   * @example\n   *\n   * ```ts\n   * const [devicePrompt] = Promise.all([\n   *   frame.waitForDevicePrompt(),\n   *   frame.click('#connect-bluetooth'),\n   * ]);\n   * await devicePrompt.select(\n   *   await devicePrompt.waitForDevice(({name}) => name.includes('My Device'))\n   * );\n   * ```\n   *\n   * @internal\n   */\n  abstract waitForDevicePrompt(\n    options?: WaitTimeoutOptions\n  ): Promise<DeviceRequestPrompt>;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}