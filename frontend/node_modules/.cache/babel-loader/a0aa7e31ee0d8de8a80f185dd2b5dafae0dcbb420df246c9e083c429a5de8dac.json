{"ast":null,"code":"import { debugError, isString } from '../common/util.js';\nimport { assert } from '../util/assert.js';\nimport { typedArrayToBase64 } from '../util/encoding.js';\n/**\n * The default cooperative request interception resolution priority\n *\n * @public\n */\nexport const DEFAULT_INTERCEPT_RESOLUTION_PRIORITY = 0;\n/**\n * Represents an HTTP request sent by a page.\n * @remarks\n *\n * Whenever the page sends a request, such as for a network resource, the\n * following events are emitted by Puppeteer's `page`:\n *\n * - `request`: emitted when the request is issued by the page.\n * - `requestfinished` - emitted when the response body is downloaded and the\n *   request is complete.\n *\n * If request fails at some point, then instead of `requestfinished` event the\n * `requestfailed` event is emitted.\n *\n * All of these events provide an instance of `HTTPRequest` representing the\n * request that occurred:\n *\n * ```\n * page.on('request', request => ...)\n * ```\n *\n * NOTE: HTTP Error responses, such as 404 or 503, are still successful\n * responses from HTTP standpoint, so request will complete with\n * `requestfinished` event.\n *\n * If request gets a 'redirect' response, the request is successfully finished\n * with the `requestfinished` event, and a new request is issued to a\n * redirected url.\n *\n * @public\n */\nexport class HTTPRequest {\n  /**\n   * @internal\n   */\n  _interceptionId;\n  /**\n   * @internal\n   */\n  _failureText = null;\n  /**\n   * @internal\n   */\n  _response = null;\n  /**\n   * @internal\n   */\n  _fromMemoryCache = false;\n  /**\n   * @internal\n   */\n  _redirectChain = [];\n  /**\n   * @internal\n   */\n  interception = {\n    enabled: false,\n    handled: false,\n    handlers: [],\n    resolutionState: {\n      action: InterceptResolutionAction.None\n    },\n    requestOverrides: {},\n    response: null,\n    abortReason: null\n  };\n  /**\n   * @internal\n   */\n  constructor() {}\n  /**\n   * The `ContinueRequestOverrides` that will be used\n   * if the interception is allowed to continue (ie, `abort()` and\n   * `respond()` aren't called).\n   */\n  continueRequestOverrides() {\n    assert(this.interception.enabled, 'Request Interception is not enabled!');\n    return this.interception.requestOverrides;\n  }\n  /**\n   * The `ResponseForRequest` that gets used if the\n   * interception is allowed to respond (ie, `abort()` is not called).\n   */\n  responseForRequest() {\n    assert(this.interception.enabled, 'Request Interception is not enabled!');\n    return this.interception.response;\n  }\n  /**\n   * The most recent reason for aborting the request\n   */\n  abortErrorReason() {\n    assert(this.interception.enabled, 'Request Interception is not enabled!');\n    return this.interception.abortReason;\n  }\n  /**\n   * An InterceptResolutionState object describing the current resolution\n   * action and priority.\n   *\n   * InterceptResolutionState contains:\n   * action: InterceptResolutionAction\n   * priority?: number\n   *\n   * InterceptResolutionAction is one of: `abort`, `respond`, `continue`,\n   * `disabled`, `none`, or `already-handled`.\n   */\n  interceptResolutionState() {\n    if (!this.interception.enabled) {\n      return {\n        action: InterceptResolutionAction.Disabled\n      };\n    }\n    if (this.interception.handled) {\n      return {\n        action: InterceptResolutionAction.AlreadyHandled\n      };\n    }\n    return {\n      ...this.interception.resolutionState\n    };\n  }\n  /**\n   * Is `true` if the intercept resolution has already been handled,\n   * `false` otherwise.\n   */\n  isInterceptResolutionHandled() {\n    return this.interception.handled;\n  }\n  /**\n   * Adds an async request handler to the processing queue.\n   * Deferred handlers are not guaranteed to execute in any particular order,\n   * but they are guaranteed to resolve before the request interception\n   * is finalized.\n   */\n  enqueueInterceptAction(pendingHandler) {\n    this.interception.handlers.push(pendingHandler);\n  }\n  /**\n   * Awaits pending interception handlers and then decides how to fulfill\n   * the request interception.\n   */\n  async finalizeInterceptions() {\n    await this.interception.handlers.reduce((promiseChain, interceptAction) => {\n      return promiseChain.then(interceptAction);\n    }, Promise.resolve());\n    this.interception.handlers = [];\n    const {\n      action\n    } = this.interceptResolutionState();\n    switch (action) {\n      case 'abort':\n        return await this._abort(this.interception.abortReason);\n      case 'respond':\n        if (this.interception.response === null) {\n          throw new Error('Response is missing for the interception');\n        }\n        return await this._respond(this.interception.response);\n      case 'continue':\n        return await this._continue(this.interception.requestOverrides);\n    }\n  }\n  /**\n   * Continues request with optional request overrides.\n   *\n   * @example\n   *\n   * ```ts\n   * await page.setRequestInterception(true);\n   * page.on('request', request => {\n   *   // Override headers\n   *   const headers = Object.assign({}, request.headers(), {\n   *     foo: 'bar', // set \"foo\" header\n   *     origin: undefined, // remove \"origin\" header\n   *   });\n   *   request.continue({headers});\n   * });\n   * ```\n   *\n   * @param overrides - optional overrides to apply to the request.\n   * @param priority - If provided, intercept is resolved using cooperative\n   * handling rules. Otherwise, intercept is resolved immediately.\n   *\n   * @remarks\n   *\n   * To use this, request interception should be enabled with\n   * {@link Page.setRequestInterception}.\n   *\n   * Exception is immediately thrown if the request interception is not enabled.\n   */\n  async continue(overrides = {}, priority) {\n    // Request interception is not supported for data: urls.\n    if (this.url().startsWith('data:')) {\n      return;\n    }\n    assert(this.interception.enabled, 'Request Interception is not enabled!');\n    assert(!this.interception.handled, 'Request is already handled!');\n    if (priority === undefined) {\n      return await this._continue(overrides);\n    }\n    this.interception.requestOverrides = overrides;\n    if (this.interception.resolutionState.priority === undefined || priority > this.interception.resolutionState.priority) {\n      this.interception.resolutionState = {\n        action: InterceptResolutionAction.Continue,\n        priority\n      };\n      return;\n    }\n    if (priority === this.interception.resolutionState.priority) {\n      if (this.interception.resolutionState.action === 'abort' || this.interception.resolutionState.action === 'respond') {\n        return;\n      }\n      this.interception.resolutionState.action = InterceptResolutionAction.Continue;\n    }\n    return;\n  }\n  /**\n   * Fulfills a request with the given response.\n   *\n   * @example\n   * An example of fulfilling all requests with 404 responses:\n   *\n   * ```ts\n   * await page.setRequestInterception(true);\n   * page.on('request', request => {\n   *   request.respond({\n   *     status: 404,\n   *     contentType: 'text/plain',\n   *     body: 'Not Found!',\n   *   });\n   * });\n   * ```\n   *\n   * NOTE: Mocking responses for dataURL requests is not supported.\n   * Calling `request.respond` for a dataURL request is a noop.\n   *\n   * @param response - the response to fulfill the request with.\n   * @param priority - If provided, intercept is resolved using\n   * cooperative handling rules. Otherwise, intercept is resolved\n   * immediately.\n   *\n   * @remarks\n   *\n   * To use this, request\n   * interception should be enabled with {@link Page.setRequestInterception}.\n   *\n   * Exception is immediately thrown if the request interception is not enabled.\n   */\n  async respond(response, priority) {\n    // Mocking responses for dataURL requests is not currently supported.\n    if (this.url().startsWith('data:')) {\n      return;\n    }\n    assert(this.interception.enabled, 'Request Interception is not enabled!');\n    assert(!this.interception.handled, 'Request is already handled!');\n    if (priority === undefined) {\n      return await this._respond(response);\n    }\n    this.interception.response = response;\n    if (this.interception.resolutionState.priority === undefined || priority > this.interception.resolutionState.priority) {\n      this.interception.resolutionState = {\n        action: InterceptResolutionAction.Respond,\n        priority\n      };\n      return;\n    }\n    if (priority === this.interception.resolutionState.priority) {\n      if (this.interception.resolutionState.action === 'abort') {\n        return;\n      }\n      this.interception.resolutionState.action = InterceptResolutionAction.Respond;\n    }\n  }\n  /**\n   * Aborts a request.\n   *\n   * @param errorCode - optional error code to provide.\n   * @param priority - If provided, intercept is resolved using\n   * cooperative handling rules. Otherwise, intercept is resolved\n   * immediately.\n   *\n   * @remarks\n   *\n   * To use this, request interception should be enabled with\n   * {@link Page.setRequestInterception}. If it is not enabled, this method will\n   * throw an exception immediately.\n   */\n  async abort(errorCode = 'failed', priority) {\n    // Request interception is not supported for data: urls.\n    if (this.url().startsWith('data:')) {\n      return;\n    }\n    const errorReason = errorReasons[errorCode];\n    assert(errorReason, 'Unknown error code: ' + errorCode);\n    assert(this.interception.enabled, 'Request Interception is not enabled!');\n    assert(!this.interception.handled, 'Request is already handled!');\n    if (priority === undefined) {\n      return await this._abort(errorReason);\n    }\n    this.interception.abortReason = errorReason;\n    if (this.interception.resolutionState.priority === undefined || priority >= this.interception.resolutionState.priority) {\n      this.interception.resolutionState = {\n        action: InterceptResolutionAction.Abort,\n        priority\n      };\n      return;\n    }\n  }\n  /**\n   * @internal\n   */\n  static getResponse(body) {\n    // Needed to get the correct byteLength\n    const byteBody = isString(body) ? new TextEncoder().encode(body) : body;\n    return {\n      contentLength: byteBody.byteLength,\n      base64: typedArrayToBase64(byteBody)\n    };\n  }\n}\n/**\n * @public\n */\nexport var InterceptResolutionAction;\n(function (InterceptResolutionAction) {\n  InterceptResolutionAction[\"Abort\"] = \"abort\";\n  InterceptResolutionAction[\"Respond\"] = \"respond\";\n  InterceptResolutionAction[\"Continue\"] = \"continue\";\n  InterceptResolutionAction[\"Disabled\"] = \"disabled\";\n  InterceptResolutionAction[\"None\"] = \"none\";\n  InterceptResolutionAction[\"AlreadyHandled\"] = \"already-handled\";\n})(InterceptResolutionAction || (InterceptResolutionAction = {}));\n/**\n * @internal\n */\nexport function headersArray(headers) {\n  const result = [];\n  for (const name in headers) {\n    const value = headers[name];\n    if (!Object.is(value, undefined)) {\n      const values = Array.isArray(value) ? value : [value];\n      result.push(...values.map(value => {\n        return {\n          name,\n          value: value + ''\n        };\n      }));\n    }\n  }\n  return result;\n}\n/**\n * @internal\n *\n * @remarks\n * List taken from {@link https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml}\n * with extra 306 and 418 codes.\n */\nexport const STATUS_TEXTS = {\n  '100': 'Continue',\n  '101': 'Switching Protocols',\n  '102': 'Processing',\n  '103': 'Early Hints',\n  '200': 'OK',\n  '201': 'Created',\n  '202': 'Accepted',\n  '203': 'Non-Authoritative Information',\n  '204': 'No Content',\n  '205': 'Reset Content',\n  '206': 'Partial Content',\n  '207': 'Multi-Status',\n  '208': 'Already Reported',\n  '226': 'IM Used',\n  '300': 'Multiple Choices',\n  '301': 'Moved Permanently',\n  '302': 'Found',\n  '303': 'See Other',\n  '304': 'Not Modified',\n  '305': 'Use Proxy',\n  '306': 'Switch Proxy',\n  '307': 'Temporary Redirect',\n  '308': 'Permanent Redirect',\n  '400': 'Bad Request',\n  '401': 'Unauthorized',\n  '402': 'Payment Required',\n  '403': 'Forbidden',\n  '404': 'Not Found',\n  '405': 'Method Not Allowed',\n  '406': 'Not Acceptable',\n  '407': 'Proxy Authentication Required',\n  '408': 'Request Timeout',\n  '409': 'Conflict',\n  '410': 'Gone',\n  '411': 'Length Required',\n  '412': 'Precondition Failed',\n  '413': 'Payload Too Large',\n  '414': 'URI Too Long',\n  '415': 'Unsupported Media Type',\n  '416': 'Range Not Satisfiable',\n  '417': 'Expectation Failed',\n  '418': \"I'm a teapot\",\n  '421': 'Misdirected Request',\n  '422': 'Unprocessable Entity',\n  '423': 'Locked',\n  '424': 'Failed Dependency',\n  '425': 'Too Early',\n  '426': 'Upgrade Required',\n  '428': 'Precondition Required',\n  '429': 'Too Many Requests',\n  '431': 'Request Header Fields Too Large',\n  '451': 'Unavailable For Legal Reasons',\n  '500': 'Internal Server Error',\n  '501': 'Not Implemented',\n  '502': 'Bad Gateway',\n  '503': 'Service Unavailable',\n  '504': 'Gateway Timeout',\n  '505': 'HTTP Version Not Supported',\n  '506': 'Variant Also Negotiates',\n  '507': 'Insufficient Storage',\n  '508': 'Loop Detected',\n  '510': 'Not Extended',\n  '511': 'Network Authentication Required'\n};\nconst errorReasons = {\n  aborted: 'Aborted',\n  accessdenied: 'AccessDenied',\n  addressunreachable: 'AddressUnreachable',\n  blockedbyclient: 'BlockedByClient',\n  blockedbyresponse: 'BlockedByResponse',\n  connectionaborted: 'ConnectionAborted',\n  connectionclosed: 'ConnectionClosed',\n  connectionfailed: 'ConnectionFailed',\n  connectionrefused: 'ConnectionRefused',\n  connectionreset: 'ConnectionReset',\n  internetdisconnected: 'InternetDisconnected',\n  namenotresolved: 'NameNotResolved',\n  timedout: 'TimedOut',\n  failed: 'Failed'\n};\n/**\n * @internal\n */\nexport function handleError(error) {\n  // Firefox throws an invalid argument error with a message starting with\n  // 'Expected \"header\" [...]'.\n  if (error.originalMessage.includes('Invalid header') || error.originalMessage.includes('Expected \"header\"') ||\n  // WebDriver BiDi error for invalid values, for example, headers.\n  error.originalMessage.includes('invalid argument')) {\n    throw error;\n  }\n  // In certain cases, protocol will return error if the request was\n  // already canceled or the page was closed. We should tolerate these\n  // errors.\n  debugError(error);\n}","map":{"version":3,"names":["debugError","isString","assert","typedArrayToBase64","DEFAULT_INTERCEPT_RESOLUTION_PRIORITY","HTTPRequest","_interceptionId","_failureText","_response","_fromMemoryCache","_redirectChain","interception","enabled","handled","handlers","resolutionState","action","InterceptResolutionAction","None","requestOverrides","response","abortReason","constructor","continueRequestOverrides","responseForRequest","abortErrorReason","interceptResolutionState","Disabled","AlreadyHandled","isInterceptResolutionHandled","enqueueInterceptAction","pendingHandler","push","finalizeInterceptions","reduce","promiseChain","interceptAction","then","Promise","resolve","_abort","Error","_respond","_continue","continue","overrides","priority","url","startsWith","undefined","Continue","respond","Respond","abort","errorCode","errorReason","errorReasons","Abort","getResponse","body","byteBody","TextEncoder","encode","contentLength","byteLength","base64","headersArray","headers","result","name","value","Object","is","values","Array","isArray","map","STATUS_TEXTS","aborted","accessdenied","addressunreachable","blockedbyclient","blockedbyresponse","connectionaborted","connectionclosed","connectionfailed","connectionrefused","connectionreset","internetdisconnected","namenotresolved","timedout","failed","handleError","error","originalMessage","includes"],"sources":["C:\\Users\\raffy\\Desktop\\test\\node_modules\\puppeteer-core\\src\\api\\HTTPRequest.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport type {Protocol} from 'devtools-protocol';\n\nimport type {ProtocolError} from '../common/Errors.js';\nimport {debugError, isString} from '../common/util.js';\nimport {assert} from '../util/assert.js';\nimport {typedArrayToBase64} from '../util/encoding.js';\n\nimport type {CDPSession} from './CDPSession.js';\nimport type {Frame} from './Frame.js';\nimport type {HTTPResponse} from './HTTPResponse.js';\n\n/**\n * @public\n */\nexport interface ContinueRequestOverrides {\n  /**\n   * If set, the request URL will change. This is not a redirect.\n   */\n  url?: string;\n  method?: string;\n  postData?: string;\n  headers?: Record<string, string>;\n}\n\n/**\n * @public\n */\nexport interface InterceptResolutionState {\n  action: InterceptResolutionAction;\n  priority?: number;\n}\n\n/**\n * Required response data to fulfill a request with.\n *\n * @public\n */\nexport interface ResponseForRequest {\n  status: number;\n  /**\n   * Optional response headers. All values are converted to strings.\n   */\n  headers: Record<string, unknown>;\n  contentType: string;\n  body: string | Uint8Array;\n}\n\n/**\n * Resource types for HTTPRequests as perceived by the rendering engine.\n *\n * @public\n */\nexport type ResourceType = Lowercase<Protocol.Network.ResourceType>;\n\n/**\n * The default cooperative request interception resolution priority\n *\n * @public\n */\nexport const DEFAULT_INTERCEPT_RESOLUTION_PRIORITY = 0;\n\n/**\n * Represents an HTTP request sent by a page.\n * @remarks\n *\n * Whenever the page sends a request, such as for a network resource, the\n * following events are emitted by Puppeteer's `page`:\n *\n * - `request`: emitted when the request is issued by the page.\n * - `requestfinished` - emitted when the response body is downloaded and the\n *   request is complete.\n *\n * If request fails at some point, then instead of `requestfinished` event the\n * `requestfailed` event is emitted.\n *\n * All of these events provide an instance of `HTTPRequest` representing the\n * request that occurred:\n *\n * ```\n * page.on('request', request => ...)\n * ```\n *\n * NOTE: HTTP Error responses, such as 404 or 503, are still successful\n * responses from HTTP standpoint, so request will complete with\n * `requestfinished` event.\n *\n * If request gets a 'redirect' response, the request is successfully finished\n * with the `requestfinished` event, and a new request is issued to a\n * redirected url.\n *\n * @public\n */\nexport abstract class HTTPRequest {\n  /**\n   * @internal\n   */\n  abstract get id(): string;\n\n  /**\n   * @internal\n   */\n  _interceptionId: string | undefined;\n  /**\n   * @internal\n   */\n  _failureText: string | null = null;\n  /**\n   * @internal\n   */\n  _response: HTTPResponse | null = null;\n  /**\n   * @internal\n   */\n  _fromMemoryCache = false;\n  /**\n   * @internal\n   */\n  _redirectChain: HTTPRequest[] = [];\n\n  /**\n   * @internal\n   */\n  protected interception: {\n    enabled: boolean;\n    handled: boolean;\n    handlers: Array<() => void | PromiseLike<any>>;\n    resolutionState: InterceptResolutionState;\n    requestOverrides: ContinueRequestOverrides;\n    response: Partial<ResponseForRequest> | null;\n    abortReason: Protocol.Network.ErrorReason | null;\n  } = {\n    enabled: false,\n    handled: false,\n    handlers: [],\n    resolutionState: {\n      action: InterceptResolutionAction.None,\n    },\n    requestOverrides: {},\n    response: null,\n    abortReason: null,\n  };\n\n  /**\n   * Warning! Using this client can break Puppeteer. Use with caution.\n   *\n   * @experimental\n   */\n  abstract get client(): CDPSession;\n\n  /**\n   * @internal\n   */\n  constructor() {}\n\n  /**\n   * The URL of the request\n   */\n  abstract url(): string;\n\n  /**\n   * The `ContinueRequestOverrides` that will be used\n   * if the interception is allowed to continue (ie, `abort()` and\n   * `respond()` aren't called).\n   */\n  continueRequestOverrides(): ContinueRequestOverrides {\n    assert(this.interception.enabled, 'Request Interception is not enabled!');\n    return this.interception.requestOverrides;\n  }\n\n  /**\n   * The `ResponseForRequest` that gets used if the\n   * interception is allowed to respond (ie, `abort()` is not called).\n   */\n  responseForRequest(): Partial<ResponseForRequest> | null {\n    assert(this.interception.enabled, 'Request Interception is not enabled!');\n    return this.interception.response;\n  }\n\n  /**\n   * The most recent reason for aborting the request\n   */\n  abortErrorReason(): Protocol.Network.ErrorReason | null {\n    assert(this.interception.enabled, 'Request Interception is not enabled!');\n    return this.interception.abortReason;\n  }\n\n  /**\n   * An InterceptResolutionState object describing the current resolution\n   * action and priority.\n   *\n   * InterceptResolutionState contains:\n   * action: InterceptResolutionAction\n   * priority?: number\n   *\n   * InterceptResolutionAction is one of: `abort`, `respond`, `continue`,\n   * `disabled`, `none`, or `already-handled`.\n   */\n  interceptResolutionState(): InterceptResolutionState {\n    if (!this.interception.enabled) {\n      return {action: InterceptResolutionAction.Disabled};\n    }\n    if (this.interception.handled) {\n      return {action: InterceptResolutionAction.AlreadyHandled};\n    }\n    return {...this.interception.resolutionState};\n  }\n\n  /**\n   * Is `true` if the intercept resolution has already been handled,\n   * `false` otherwise.\n   */\n  isInterceptResolutionHandled(): boolean {\n    return this.interception.handled;\n  }\n\n  /**\n   * Adds an async request handler to the processing queue.\n   * Deferred handlers are not guaranteed to execute in any particular order,\n   * but they are guaranteed to resolve before the request interception\n   * is finalized.\n   */\n  enqueueInterceptAction(\n    pendingHandler: () => void | PromiseLike<unknown>\n  ): void {\n    this.interception.handlers.push(pendingHandler);\n  }\n\n  /**\n   * @internal\n   */\n  abstract _abort(\n    errorReason: Protocol.Network.ErrorReason | null\n  ): Promise<void>;\n\n  /**\n   * @internal\n   */\n  abstract _respond(response: Partial<ResponseForRequest>): Promise<void>;\n\n  /**\n   * @internal\n   */\n  abstract _continue(overrides: ContinueRequestOverrides): Promise<void>;\n\n  /**\n   * Awaits pending interception handlers and then decides how to fulfill\n   * the request interception.\n   */\n  async finalizeInterceptions(): Promise<void> {\n    await this.interception.handlers.reduce((promiseChain, interceptAction) => {\n      return promiseChain.then(interceptAction);\n    }, Promise.resolve());\n    this.interception.handlers = [];\n    const {action} = this.interceptResolutionState();\n    switch (action) {\n      case 'abort':\n        return await this._abort(this.interception.abortReason);\n      case 'respond':\n        if (this.interception.response === null) {\n          throw new Error('Response is missing for the interception');\n        }\n        return await this._respond(this.interception.response);\n      case 'continue':\n        return await this._continue(this.interception.requestOverrides);\n    }\n  }\n\n  /**\n   * Contains the request's resource type as it was perceived by the rendering\n   * engine.\n   */\n  abstract resourceType(): ResourceType;\n\n  /**\n   * The method used (`GET`, `POST`, etc.)\n   */\n  abstract method(): string;\n\n  /**\n   * The request's post body, if any.\n   */\n  abstract postData(): string | undefined;\n\n  /**\n   * True when the request has POST data. Note that {@link HTTPRequest.postData}\n   * might still be undefined when this flag is true when the data is too long\n   * or not readily available in the decoded form. In that case, use\n   * {@link HTTPRequest.fetchPostData}.\n   */\n  abstract hasPostData(): boolean;\n\n  /**\n   * Fetches the POST data for the request from the browser.\n   */\n  abstract fetchPostData(): Promise<string | undefined>;\n\n  /**\n   * An object with HTTP headers associated with the request. All\n   * header names are lower-case.\n   */\n  abstract headers(): Record<string, string>;\n\n  /**\n   * A matching `HTTPResponse` object, or null if the response has not\n   * been received yet.\n   */\n  abstract response(): HTTPResponse | null;\n\n  /**\n   * The frame that initiated the request, or null if navigating to\n   * error pages.\n   */\n  abstract frame(): Frame | null;\n\n  /**\n   * True if the request is the driver of the current frame's navigation.\n   */\n  abstract isNavigationRequest(): boolean;\n\n  /**\n   * The initiator of the request.\n   */\n  abstract initiator(): Protocol.Network.Initiator | undefined;\n\n  /**\n   * A `redirectChain` is a chain of requests initiated to fetch a resource.\n   * @remarks\n   *\n   * `redirectChain` is shared between all the requests of the same chain.\n   *\n   * For example, if the website `http://example.com` has a single redirect to\n   * `https://example.com`, then the chain will contain one request:\n   *\n   * ```ts\n   * const response = await page.goto('http://example.com');\n   * const chain = response.request().redirectChain();\n   * console.log(chain.length); // 1\n   * console.log(chain[0].url()); // 'http://example.com'\n   * ```\n   *\n   * If the website `https://google.com` has no redirects, then the chain will be empty:\n   *\n   * ```ts\n   * const response = await page.goto('https://google.com');\n   * const chain = response.request().redirectChain();\n   * console.log(chain.length); // 0\n   * ```\n   *\n   * @returns the chain of requests - if a server responds with at least a\n   * single redirect, this chain will contain all requests that were redirected.\n   */\n  abstract redirectChain(): HTTPRequest[];\n\n  /**\n   * Access information about the request's failure.\n   *\n   * @remarks\n   *\n   * @example\n   *\n   * Example of logging all failed requests:\n   *\n   * ```ts\n   * page.on('requestfailed', request => {\n   *   console.log(request.url() + ' ' + request.failure().errorText);\n   * });\n   * ```\n   *\n   * @returns `null` unless the request failed. If the request fails this can\n   * return an object with `errorText` containing a human-readable error\n   * message, e.g. `net::ERR_FAILED`. It is not guaranteed that there will be\n   * failure text if the request fails.\n   */\n  abstract failure(): {errorText: string} | null;\n\n  /**\n   * Continues request with optional request overrides.\n   *\n   * @example\n   *\n   * ```ts\n   * await page.setRequestInterception(true);\n   * page.on('request', request => {\n   *   // Override headers\n   *   const headers = Object.assign({}, request.headers(), {\n   *     foo: 'bar', // set \"foo\" header\n   *     origin: undefined, // remove \"origin\" header\n   *   });\n   *   request.continue({headers});\n   * });\n   * ```\n   *\n   * @param overrides - optional overrides to apply to the request.\n   * @param priority - If provided, intercept is resolved using cooperative\n   * handling rules. Otherwise, intercept is resolved immediately.\n   *\n   * @remarks\n   *\n   * To use this, request interception should be enabled with\n   * {@link Page.setRequestInterception}.\n   *\n   * Exception is immediately thrown if the request interception is not enabled.\n   */\n  async continue(\n    overrides: ContinueRequestOverrides = {},\n    priority?: number\n  ): Promise<void> {\n    // Request interception is not supported for data: urls.\n    if (this.url().startsWith('data:')) {\n      return;\n    }\n    assert(this.interception.enabled, 'Request Interception is not enabled!');\n    assert(!this.interception.handled, 'Request is already handled!');\n    if (priority === undefined) {\n      return await this._continue(overrides);\n    }\n    this.interception.requestOverrides = overrides;\n    if (\n      this.interception.resolutionState.priority === undefined ||\n      priority > this.interception.resolutionState.priority\n    ) {\n      this.interception.resolutionState = {\n        action: InterceptResolutionAction.Continue,\n        priority,\n      };\n      return;\n    }\n    if (priority === this.interception.resolutionState.priority) {\n      if (\n        this.interception.resolutionState.action === 'abort' ||\n        this.interception.resolutionState.action === 'respond'\n      ) {\n        return;\n      }\n      this.interception.resolutionState.action =\n        InterceptResolutionAction.Continue;\n    }\n    return;\n  }\n\n  /**\n   * Fulfills a request with the given response.\n   *\n   * @example\n   * An example of fulfilling all requests with 404 responses:\n   *\n   * ```ts\n   * await page.setRequestInterception(true);\n   * page.on('request', request => {\n   *   request.respond({\n   *     status: 404,\n   *     contentType: 'text/plain',\n   *     body: 'Not Found!',\n   *   });\n   * });\n   * ```\n   *\n   * NOTE: Mocking responses for dataURL requests is not supported.\n   * Calling `request.respond` for a dataURL request is a noop.\n   *\n   * @param response - the response to fulfill the request with.\n   * @param priority - If provided, intercept is resolved using\n   * cooperative handling rules. Otherwise, intercept is resolved\n   * immediately.\n   *\n   * @remarks\n   *\n   * To use this, request\n   * interception should be enabled with {@link Page.setRequestInterception}.\n   *\n   * Exception is immediately thrown if the request interception is not enabled.\n   */\n  async respond(\n    response: Partial<ResponseForRequest>,\n    priority?: number\n  ): Promise<void> {\n    // Mocking responses for dataURL requests is not currently supported.\n    if (this.url().startsWith('data:')) {\n      return;\n    }\n    assert(this.interception.enabled, 'Request Interception is not enabled!');\n    assert(!this.interception.handled, 'Request is already handled!');\n    if (priority === undefined) {\n      return await this._respond(response);\n    }\n    this.interception.response = response;\n    if (\n      this.interception.resolutionState.priority === undefined ||\n      priority > this.interception.resolutionState.priority\n    ) {\n      this.interception.resolutionState = {\n        action: InterceptResolutionAction.Respond,\n        priority,\n      };\n      return;\n    }\n    if (priority === this.interception.resolutionState.priority) {\n      if (this.interception.resolutionState.action === 'abort') {\n        return;\n      }\n      this.interception.resolutionState.action =\n        InterceptResolutionAction.Respond;\n    }\n  }\n\n  /**\n   * Aborts a request.\n   *\n   * @param errorCode - optional error code to provide.\n   * @param priority - If provided, intercept is resolved using\n   * cooperative handling rules. Otherwise, intercept is resolved\n   * immediately.\n   *\n   * @remarks\n   *\n   * To use this, request interception should be enabled with\n   * {@link Page.setRequestInterception}. If it is not enabled, this method will\n   * throw an exception immediately.\n   */\n  async abort(\n    errorCode: ErrorCode = 'failed',\n    priority?: number\n  ): Promise<void> {\n    // Request interception is not supported for data: urls.\n    if (this.url().startsWith('data:')) {\n      return;\n    }\n    const errorReason = errorReasons[errorCode];\n    assert(errorReason, 'Unknown error code: ' + errorCode);\n    assert(this.interception.enabled, 'Request Interception is not enabled!');\n    assert(!this.interception.handled, 'Request is already handled!');\n    if (priority === undefined) {\n      return await this._abort(errorReason);\n    }\n    this.interception.abortReason = errorReason;\n    if (\n      this.interception.resolutionState.priority === undefined ||\n      priority >= this.interception.resolutionState.priority\n    ) {\n      this.interception.resolutionState = {\n        action: InterceptResolutionAction.Abort,\n        priority,\n      };\n      return;\n    }\n  }\n\n  /**\n   * @internal\n   */\n  static getResponse(body: string | Uint8Array): {\n    contentLength: number;\n    base64: string;\n  } {\n    // Needed to get the correct byteLength\n    const byteBody: Uint8Array = isString(body)\n      ? new TextEncoder().encode(body)\n      : body;\n\n    return {\n      contentLength: byteBody.byteLength,\n      base64: typedArrayToBase64(byteBody),\n    };\n  }\n}\n\n/**\n * @public\n */\nexport enum InterceptResolutionAction {\n  Abort = 'abort',\n  Respond = 'respond',\n  Continue = 'continue',\n  Disabled = 'disabled',\n  None = 'none',\n  AlreadyHandled = 'already-handled',\n}\n\n/**\n * @public\n */\nexport type ErrorCode =\n  | 'aborted'\n  | 'accessdenied'\n  | 'addressunreachable'\n  | 'blockedbyclient'\n  | 'blockedbyresponse'\n  | 'connectionaborted'\n  | 'connectionclosed'\n  | 'connectionfailed'\n  | 'connectionrefused'\n  | 'connectionreset'\n  | 'internetdisconnected'\n  | 'namenotresolved'\n  | 'timedout'\n  | 'failed';\n\n/**\n * @public\n */\nexport type ActionResult = 'continue' | 'abort' | 'respond';\n\n/**\n * @internal\n */\nexport function headersArray(\n  headers: Record<string, string | string[]>\n): Array<{name: string; value: string}> {\n  const result = [];\n  for (const name in headers) {\n    const value = headers[name];\n\n    if (!Object.is(value, undefined)) {\n      const values = Array.isArray(value) ? value : [value];\n\n      result.push(\n        ...values.map(value => {\n          return {name, value: value + ''};\n        })\n      );\n    }\n  }\n  return result;\n}\n\n/**\n * @internal\n *\n * @remarks\n * List taken from {@link https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml}\n * with extra 306 and 418 codes.\n */\nexport const STATUS_TEXTS: Record<string, string> = {\n  '100': 'Continue',\n  '101': 'Switching Protocols',\n  '102': 'Processing',\n  '103': 'Early Hints',\n  '200': 'OK',\n  '201': 'Created',\n  '202': 'Accepted',\n  '203': 'Non-Authoritative Information',\n  '204': 'No Content',\n  '205': 'Reset Content',\n  '206': 'Partial Content',\n  '207': 'Multi-Status',\n  '208': 'Already Reported',\n  '226': 'IM Used',\n  '300': 'Multiple Choices',\n  '301': 'Moved Permanently',\n  '302': 'Found',\n  '303': 'See Other',\n  '304': 'Not Modified',\n  '305': 'Use Proxy',\n  '306': 'Switch Proxy',\n  '307': 'Temporary Redirect',\n  '308': 'Permanent Redirect',\n  '400': 'Bad Request',\n  '401': 'Unauthorized',\n  '402': 'Payment Required',\n  '403': 'Forbidden',\n  '404': 'Not Found',\n  '405': 'Method Not Allowed',\n  '406': 'Not Acceptable',\n  '407': 'Proxy Authentication Required',\n  '408': 'Request Timeout',\n  '409': 'Conflict',\n  '410': 'Gone',\n  '411': 'Length Required',\n  '412': 'Precondition Failed',\n  '413': 'Payload Too Large',\n  '414': 'URI Too Long',\n  '415': 'Unsupported Media Type',\n  '416': 'Range Not Satisfiable',\n  '417': 'Expectation Failed',\n  '418': \"I'm a teapot\",\n  '421': 'Misdirected Request',\n  '422': 'Unprocessable Entity',\n  '423': 'Locked',\n  '424': 'Failed Dependency',\n  '425': 'Too Early',\n  '426': 'Upgrade Required',\n  '428': 'Precondition Required',\n  '429': 'Too Many Requests',\n  '431': 'Request Header Fields Too Large',\n  '451': 'Unavailable For Legal Reasons',\n  '500': 'Internal Server Error',\n  '501': 'Not Implemented',\n  '502': 'Bad Gateway',\n  '503': 'Service Unavailable',\n  '504': 'Gateway Timeout',\n  '505': 'HTTP Version Not Supported',\n  '506': 'Variant Also Negotiates',\n  '507': 'Insufficient Storage',\n  '508': 'Loop Detected',\n  '510': 'Not Extended',\n  '511': 'Network Authentication Required',\n} as const;\n\nconst errorReasons: Record<ErrorCode, Protocol.Network.ErrorReason> = {\n  aborted: 'Aborted',\n  accessdenied: 'AccessDenied',\n  addressunreachable: 'AddressUnreachable',\n  blockedbyclient: 'BlockedByClient',\n  blockedbyresponse: 'BlockedByResponse',\n  connectionaborted: 'ConnectionAborted',\n  connectionclosed: 'ConnectionClosed',\n  connectionfailed: 'ConnectionFailed',\n  connectionrefused: 'ConnectionRefused',\n  connectionreset: 'ConnectionReset',\n  internetdisconnected: 'InternetDisconnected',\n  namenotresolved: 'NameNotResolved',\n  timedout: 'TimedOut',\n  failed: 'Failed',\n} as const;\n\n/**\n * @internal\n */\nexport function handleError(error: ProtocolError): void {\n  // Firefox throws an invalid argument error with a message starting with\n  // 'Expected \"header\" [...]'.\n  if (\n    error.originalMessage.includes('Invalid header') ||\n    error.originalMessage.includes('Expected \"header\"') ||\n    // WebDriver BiDi error for invalid values, for example, headers.\n    error.originalMessage.includes('invalid argument')\n  ) {\n    throw error;\n  }\n  // In certain cases, protocol will return error if the request was\n  // already canceled or the page was closed. We should tolerate these\n  // errors.\n  debugError(error);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}