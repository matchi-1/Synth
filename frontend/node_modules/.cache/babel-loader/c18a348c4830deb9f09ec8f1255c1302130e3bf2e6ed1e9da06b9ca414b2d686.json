{"ast":null,"code":"/**\n * @license\n * Copyright 2023 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\nvar __runInitializers = this && this.__runInitializers || function (thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\nvar __esDecorate = this && this.__esDecorate || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) {\n    if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\");\n    return f;\n  }\n  var kind = contextIn.kind,\n    key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _,\n    done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n    var context = {};\n    for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n    for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n    context.addInitializer = function (f) {\n      if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\");\n      extraInitializers.push(accept(f || null));\n    };\n    var result = (0, decorators[i])(kind === \"accessor\" ? {\n      get: descriptor.get,\n      set: descriptor.set\n    } : descriptor[key], context);\n    if (kind === \"accessor\") {\n      if (result === void 0) continue;\n      if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n      if (_ = accept(result.get)) descriptor.get = _;\n      if (_ = accept(result.set)) descriptor.set = _;\n      if (_ = accept(result.init)) initializers.unshift(_);\n    } else if (_ = accept(result)) {\n      if (kind === \"field\") initializers.unshift(_);else descriptor[key] = _;\n    }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\nvar __addDisposableResource = this && this.__addDisposableResource || function (env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose;\n    if (async) {\n      if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n      dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n      if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n      dispose = value[Symbol.dispose];\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    env.stack.push({\n      value: value,\n      dispose: dispose,\n      async: async\n    });\n  } else if (async) {\n    env.stack.push({\n      async: true\n    });\n  }\n  return value;\n};\nvar __disposeResources = this && this.__disposeResources || function (SuppressedError) {\n  return function (env) {\n    function fail(e) {\n      env.error = env.hasError ? new SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n      env.hasError = true;\n    }\n    function next() {\n      while (env.stack.length) {\n        var rec = env.stack.pop();\n        try {\n          var result = rec.dispose && rec.dispose.call(rec.value);\n          if (rec.async) return Promise.resolve(result).then(next, function (e) {\n            fail(e);\n            return next();\n          });\n        } catch (e) {\n          fail(e);\n        }\n      }\n      if (env.hasError) throw env.error;\n    }\n    return next();\n  };\n}(typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n});\nvar __setFunctionName = this && this.__setFunctionName || function (f, name, prefix) {\n  if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\n  return Object.defineProperty(f, \"name\", {\n    configurable: true,\n    value: prefix ? \"\".concat(prefix, \" \", name) : name\n  });\n};\nimport { getQueryHandlerAndSelector } from '../common/GetQueryHandler.js';\nimport { LazyArg } from '../common/LazyArg.js';\nimport { isString, withSourcePuppeteerURLIfNone } from '../common/util.js';\nimport { assert } from '../util/assert.js';\nimport { AsyncIterableUtil } from '../util/AsyncIterableUtil.js';\nimport { throwIfDisposed } from '../util/decorators.js';\nimport { _isElementHandle } from './ElementHandleSymbol.js';\nimport { JSHandle } from './JSHandle.js';\n/**\n * ElementHandle represents an in-page DOM element.\n *\n * @remarks\n * ElementHandles can be created with the {@link Page.$} method.\n *\n * ```ts\n * import puppeteer from 'puppeteer';\n *\n * (async () => {\n *   const browser = await puppeteer.launch();\n *   const page = await browser.newPage();\n *   await page.goto('https://example.com');\n *   const hrefElement = await page.$('a');\n *   await hrefElement.click();\n *   // ...\n * })();\n * ```\n *\n * ElementHandle prevents the DOM element from being garbage-collected unless the\n * handle is {@link JSHandle.dispose | disposed}. ElementHandles are auto-disposed\n * when their origin frame gets navigated.\n *\n * ElementHandle instances can be used as arguments in {@link Page.$eval} and\n * {@link Page.evaluate} methods.\n *\n * If you're using TypeScript, ElementHandle takes a generic argument that\n * denotes the type of element the handle is holding within. For example, if you\n * have a handle to a `<select>` element, you can type it as\n * `ElementHandle<HTMLSelectElement>` and you get some nicer type checks.\n *\n * @public\n */\nlet ElementHandle = (() => {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5;\n  let _classSuper = JSHandle;\n  let _instanceExtraInitializers = [];\n  let _getProperty_decorators;\n  let _getProperties_decorators;\n  let _jsonValue_decorators;\n  let _$_decorators;\n  let _$$_decorators;\n  let _private_$$_decorators;\n  let _private_$$_descriptor;\n  let _waitForSelector_decorators;\n  let _isVisible_decorators;\n  let _isHidden_decorators;\n  let _toElement_decorators;\n  let _clickablePoint_decorators;\n  let _hover_decorators;\n  let _click_decorators;\n  let _drag_decorators;\n  let _dragEnter_decorators;\n  let _dragOver_decorators;\n  let _drop_decorators;\n  let _dragAndDrop_decorators;\n  let _select_decorators;\n  let _tap_decorators;\n  let _touchStart_decorators;\n  let _touchMove_decorators;\n  let _touchEnd_decorators;\n  let _focus_decorators;\n  let _type_decorators;\n  let _press_decorators;\n  let _boundingBox_decorators;\n  let _boxModel_decorators;\n  let _screenshot_decorators;\n  let _isIntersectingViewport_decorators;\n  let _scrollIntoView_decorators;\n  return class ElementHandle extends _classSuper {\n    static {\n      const _metadata = typeof Symbol === \"function\" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;\n      _getProperty_decorators = [throwIfDisposed(), (_a = ElementHandle).bindIsolatedHandle.bind(_a)];\n      _getProperties_decorators = [throwIfDisposed(), (_b = ElementHandle).bindIsolatedHandle.bind(_b)];\n      _jsonValue_decorators = [throwIfDisposed(), (_c = ElementHandle).bindIsolatedHandle.bind(_c)];\n      _$_decorators = [throwIfDisposed(), (_d = ElementHandle).bindIsolatedHandle.bind(_d)];\n      _$$_decorators = [throwIfDisposed()];\n      _private_$$_decorators = [(_e = ElementHandle).bindIsolatedHandle.bind(_e)];\n      _waitForSelector_decorators = [throwIfDisposed(), (_f = ElementHandle).bindIsolatedHandle.bind(_f)];\n      _isVisible_decorators = [throwIfDisposed(), (_g = ElementHandle).bindIsolatedHandle.bind(_g)];\n      _isHidden_decorators = [throwIfDisposed(), (_h = ElementHandle).bindIsolatedHandle.bind(_h)];\n      _toElement_decorators = [throwIfDisposed(), (_j = ElementHandle).bindIsolatedHandle.bind(_j)];\n      _clickablePoint_decorators = [throwIfDisposed(), (_k = ElementHandle).bindIsolatedHandle.bind(_k)];\n      _hover_decorators = [throwIfDisposed(), (_l = ElementHandle).bindIsolatedHandle.bind(_l)];\n      _click_decorators = [throwIfDisposed(), (_m = ElementHandle).bindIsolatedHandle.bind(_m)];\n      _drag_decorators = [throwIfDisposed(), (_o = ElementHandle).bindIsolatedHandle.bind(_o)];\n      _dragEnter_decorators = [throwIfDisposed(), (_p = ElementHandle).bindIsolatedHandle.bind(_p)];\n      _dragOver_decorators = [throwIfDisposed(), (_q = ElementHandle).bindIsolatedHandle.bind(_q)];\n      _drop_decorators = [throwIfDisposed(), (_r = ElementHandle).bindIsolatedHandle.bind(_r)];\n      _dragAndDrop_decorators = [throwIfDisposed(), (_s = ElementHandle).bindIsolatedHandle.bind(_s)];\n      _select_decorators = [throwIfDisposed(), (_t = ElementHandle).bindIsolatedHandle.bind(_t)];\n      _tap_decorators = [throwIfDisposed(), (_u = ElementHandle).bindIsolatedHandle.bind(_u)];\n      _touchStart_decorators = [throwIfDisposed(), (_v = ElementHandle).bindIsolatedHandle.bind(_v)];\n      _touchMove_decorators = [throwIfDisposed(), (_w = ElementHandle).bindIsolatedHandle.bind(_w)];\n      _touchEnd_decorators = [throwIfDisposed(), (_x = ElementHandle).bindIsolatedHandle.bind(_x)];\n      _focus_decorators = [throwIfDisposed(), (_y = ElementHandle).bindIsolatedHandle.bind(_y)];\n      _type_decorators = [throwIfDisposed(), (_z = ElementHandle).bindIsolatedHandle.bind(_z)];\n      _press_decorators = [throwIfDisposed(), (_0 = ElementHandle).bindIsolatedHandle.bind(_0)];\n      _boundingBox_decorators = [throwIfDisposed(), (_1 = ElementHandle).bindIsolatedHandle.bind(_1)];\n      _boxModel_decorators = [throwIfDisposed(), (_2 = ElementHandle).bindIsolatedHandle.bind(_2)];\n      _screenshot_decorators = [throwIfDisposed(), (_3 = ElementHandle).bindIsolatedHandle.bind(_3)];\n      _isIntersectingViewport_decorators = [throwIfDisposed(), (_4 = ElementHandle).bindIsolatedHandle.bind(_4)];\n      _scrollIntoView_decorators = [throwIfDisposed(), (_5 = ElementHandle).bindIsolatedHandle.bind(_5)];\n      __esDecorate(this, null, _getProperty_decorators, {\n        kind: \"method\",\n        name: \"getProperty\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"getProperty\" in obj,\n          get: obj => obj.getProperty\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _getProperties_decorators, {\n        kind: \"method\",\n        name: \"getProperties\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"getProperties\" in obj,\n          get: obj => obj.getProperties\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _jsonValue_decorators, {\n        kind: \"method\",\n        name: \"jsonValue\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"jsonValue\" in obj,\n          get: obj => obj.jsonValue\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _$_decorators, {\n        kind: \"method\",\n        name: \"$\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"$\" in obj,\n          get: obj => obj.$\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _$$_decorators, {\n        kind: \"method\",\n        name: \"$$\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"$$\" in obj,\n          get: obj => obj.$$\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, _private_$$_descriptor = {\n        value: __setFunctionName(async function (selector) {\n          return await this.#$$impl(selector);\n        }, \"#$$\")\n      }, _private_$$_decorators, {\n        kind: \"method\",\n        name: \"#$$\",\n        static: false,\n        private: true,\n        access: {\n          has: obj => #$$ in obj,\n          get: obj => obj.#$$\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _waitForSelector_decorators, {\n        kind: \"method\",\n        name: \"waitForSelector\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"waitForSelector\" in obj,\n          get: obj => obj.waitForSelector\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _isVisible_decorators, {\n        kind: \"method\",\n        name: \"isVisible\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"isVisible\" in obj,\n          get: obj => obj.isVisible\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _isHidden_decorators, {\n        kind: \"method\",\n        name: \"isHidden\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"isHidden\" in obj,\n          get: obj => obj.isHidden\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _toElement_decorators, {\n        kind: \"method\",\n        name: \"toElement\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"toElement\" in obj,\n          get: obj => obj.toElement\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _clickablePoint_decorators, {\n        kind: \"method\",\n        name: \"clickablePoint\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"clickablePoint\" in obj,\n          get: obj => obj.clickablePoint\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _hover_decorators, {\n        kind: \"method\",\n        name: \"hover\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"hover\" in obj,\n          get: obj => obj.hover\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _click_decorators, {\n        kind: \"method\",\n        name: \"click\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"click\" in obj,\n          get: obj => obj.click\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _drag_decorators, {\n        kind: \"method\",\n        name: \"drag\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"drag\" in obj,\n          get: obj => obj.drag\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _dragEnter_decorators, {\n        kind: \"method\",\n        name: \"dragEnter\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"dragEnter\" in obj,\n          get: obj => obj.dragEnter\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _dragOver_decorators, {\n        kind: \"method\",\n        name: \"dragOver\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"dragOver\" in obj,\n          get: obj => obj.dragOver\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _drop_decorators, {\n        kind: \"method\",\n        name: \"drop\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"drop\" in obj,\n          get: obj => obj.drop\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _dragAndDrop_decorators, {\n        kind: \"method\",\n        name: \"dragAndDrop\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"dragAndDrop\" in obj,\n          get: obj => obj.dragAndDrop\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _select_decorators, {\n        kind: \"method\",\n        name: \"select\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"select\" in obj,\n          get: obj => obj.select\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _tap_decorators, {\n        kind: \"method\",\n        name: \"tap\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"tap\" in obj,\n          get: obj => obj.tap\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _touchStart_decorators, {\n        kind: \"method\",\n        name: \"touchStart\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"touchStart\" in obj,\n          get: obj => obj.touchStart\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _touchMove_decorators, {\n        kind: \"method\",\n        name: \"touchMove\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"touchMove\" in obj,\n          get: obj => obj.touchMove\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _touchEnd_decorators, {\n        kind: \"method\",\n        name: \"touchEnd\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"touchEnd\" in obj,\n          get: obj => obj.touchEnd\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _focus_decorators, {\n        kind: \"method\",\n        name: \"focus\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"focus\" in obj,\n          get: obj => obj.focus\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _type_decorators, {\n        kind: \"method\",\n        name: \"type\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"type\" in obj,\n          get: obj => obj.type\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _press_decorators, {\n        kind: \"method\",\n        name: \"press\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"press\" in obj,\n          get: obj => obj.press\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _boundingBox_decorators, {\n        kind: \"method\",\n        name: \"boundingBox\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"boundingBox\" in obj,\n          get: obj => obj.boundingBox\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _boxModel_decorators, {\n        kind: \"method\",\n        name: \"boxModel\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"boxModel\" in obj,\n          get: obj => obj.boxModel\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _screenshot_decorators, {\n        kind: \"method\",\n        name: \"screenshot\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"screenshot\" in obj,\n          get: obj => obj.screenshot\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _isIntersectingViewport_decorators, {\n        kind: \"method\",\n        name: \"isIntersectingViewport\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"isIntersectingViewport\" in obj,\n          get: obj => obj.isIntersectingViewport\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _scrollIntoView_decorators, {\n        kind: \"method\",\n        name: \"scrollIntoView\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"scrollIntoView\" in obj,\n          get: obj => obj.scrollIntoView\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      if (_metadata) Object.defineProperty(this, Symbol.metadata, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value: _metadata\n      });\n    }\n    /**\n     * @internal\n     * Cached isolatedHandle to prevent\n     * trying to adopt it multiple times\n     */\n    isolatedHandle = __runInitializers(this, _instanceExtraInitializers);\n    /**\n     * A given method will have it's `this` replaced with an isolated version of\n     * `this` when decorated with this decorator.\n     *\n     * All changes of isolated `this` are reflected on the actual `this`.\n     *\n     * @internal\n     */\n    static bindIsolatedHandle(target, _) {\n      return async function (...args) {\n        // If the handle is already isolated, then we don't need to adopt it\n        // again.\n        if (this.realm === this.frame.isolatedRealm()) {\n          return await target.call(this, ...args);\n        }\n        let adoptedThis;\n        if (this['isolatedHandle']) {\n          adoptedThis = this['isolatedHandle'];\n        } else {\n          this['isolatedHandle'] = adoptedThis = await this.frame.isolatedRealm().adoptHandle(this);\n        }\n        const result = await target.call(adoptedThis, ...args);\n        // If the function returns `adoptedThis`, then we return `this`.\n        if (result === adoptedThis) {\n          return this;\n        }\n        // If the function returns a handle, transfer it into the current realm.\n        if (result instanceof JSHandle) {\n          return await this.realm.transferHandle(result);\n        }\n        // If the function returns an array of handlers, transfer them into the\n        // current realm.\n        if (Array.isArray(result)) {\n          await Promise.all(result.map(async (item, index, result) => {\n            if (item instanceof JSHandle) {\n              result[index] = await this.realm.transferHandle(item);\n            }\n          }));\n        }\n        if (result instanceof Map) {\n          await Promise.all([...result.entries()].map(async ([key, value]) => {\n            if (value instanceof JSHandle) {\n              result.set(key, await this.realm.transferHandle(value));\n            }\n          }));\n        }\n        return result;\n      };\n    }\n    /**\n     * @internal\n     */\n    handle;\n    /**\n     * @internal\n     */\n    constructor(handle) {\n      super();\n      this.handle = handle;\n      this[_isElementHandle] = true;\n    }\n    /**\n     * @internal\n     */\n    get id() {\n      return this.handle.id;\n    }\n    /**\n     * @internal\n     */\n    get disposed() {\n      return this.handle.disposed;\n    }\n    /**\n     * @internal\n     */\n    async getProperty(propertyName) {\n      return await this.handle.getProperty(propertyName);\n    }\n    /**\n     * @internal\n     */\n    async getProperties() {\n      return await this.handle.getProperties();\n    }\n    /**\n     * @internal\n     */\n    async evaluate(pageFunction, ...args) {\n      pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);\n      return await this.handle.evaluate(pageFunction, ...args);\n    }\n    /**\n     * @internal\n     */\n    async evaluateHandle(pageFunction, ...args) {\n      pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);\n      return await this.handle.evaluateHandle(pageFunction, ...args);\n    }\n    /**\n     * @internal\n     */\n    async jsonValue() {\n      return await this.handle.jsonValue();\n    }\n    /**\n     * @internal\n     */\n    toString() {\n      return this.handle.toString();\n    }\n    /**\n     * @internal\n     */\n    remoteObject() {\n      return this.handle.remoteObject();\n    }\n    /**\n     * @internal\n     */\n    dispose() {\n      return this.handle.dispose();\n    }\n    /**\n     * @internal\n     */\n    asElement() {\n      return this;\n    }\n    /**\n     * Queries the current element for an element matching the given selector.\n     *\n     * @param selector -\n     * {@link https://pptr.dev/guides/page-interactions#selectors | selector}\n     * to query the page for.\n     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}\n     * can be passed as-is and a\n     * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}\n     * allows quering by\n     * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},\n     * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},\n     * and\n     * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}\n     * and\n     * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.\n     * Alternatively, you can specify the selector type using a\n     * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.\n     * @returns A {@link ElementHandle | element handle} to the first element\n     * matching the given selector. Otherwise, `null`.\n     */\n    async $(selector) {\n      const {\n        updatedSelector,\n        QueryHandler\n      } = getQueryHandlerAndSelector(selector);\n      return await QueryHandler.queryOne(this, updatedSelector);\n    }\n    /**\n     * Queries the current element for all elements matching the given selector.\n     *\n     * @param selector -\n     * {@link https://pptr.dev/guides/page-interactions#selectors | selector}\n     * to query the page for.\n     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}\n     * can be passed as-is and a\n     * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}\n     * allows quering by\n     * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},\n     * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},\n     * and\n     * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}\n     * and\n     * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.\n     * Alternatively, you can specify the selector type using a\n     * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.\n     * @returns An array of {@link ElementHandle | element handles} that point to\n     * elements matching the given selector.\n     */\n    async $$(selector, options) {\n      if (options?.isolate === false) {\n        return await this.#$$impl(selector);\n      }\n      return await this.#$$(selector);\n    }\n    /**\n     * Isolates {@link ElementHandle.$$} if needed.\n     *\n     * @internal\n     */\n    get #$$() {\n      return _private_$$_descriptor.value;\n    }\n    /**\n     * Implementation for {@link ElementHandle.$$}.\n     *\n     * @internal\n     */\n    async #$$impl(selector) {\n      const {\n        updatedSelector,\n        QueryHandler\n      } = getQueryHandlerAndSelector(selector);\n      return await AsyncIterableUtil.collect(QueryHandler.queryAll(this, updatedSelector));\n    }\n    /**\n     * Runs the given function on the first element matching the given selector in\n     * the current element.\n     *\n     * If the given function returns a promise, then this method will wait till\n     * the promise resolves.\n     *\n     * @example\n     *\n     * ```ts\n     * const tweetHandle = await page.$('.tweet');\n     * expect(await tweetHandle.$eval('.like', node => node.innerText)).toBe(\n     *   '100'\n     * );\n     * expect(await tweetHandle.$eval('.retweets', node => node.innerText)).toBe(\n     *   '10'\n     * );\n     * ```\n     *\n     * @param selector -\n     * {@link https://pptr.dev/guides/page-interactions#selectors | selector}\n     * to query the page for.\n     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}\n     * can be passed as-is and a\n     * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}\n     * allows quering by\n     * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},\n     * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},\n     * and\n     * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}\n     * and\n     * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.\n     * Alternatively, you can specify the selector type using a\n     * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.\n     * @param pageFunction - The function to be evaluated in this element's page's\n     * context. The first element matching the selector will be passed in as the\n     * first argument.\n     * @param args - Additional arguments to pass to `pageFunction`.\n     * @returns A promise to the result of the function.\n     */\n    async $eval(selector, pageFunction, ...args) {\n      const env_1 = {\n        stack: [],\n        error: void 0,\n        hasError: false\n      };\n      try {\n        pageFunction = withSourcePuppeteerURLIfNone(this.$eval.name, pageFunction);\n        const elementHandle = __addDisposableResource(env_1, await this.$(selector), false);\n        if (!elementHandle) {\n          throw new Error(`Error: failed to find element matching selector \"${selector}\"`);\n        }\n        return await elementHandle.evaluate(pageFunction, ...args);\n      } catch (e_1) {\n        env_1.error = e_1;\n        env_1.hasError = true;\n      } finally {\n        __disposeResources(env_1);\n      }\n    }\n    /**\n     * Runs the given function on an array of elements matching the given selector\n     * in the current element.\n     *\n     * If the given function returns a promise, then this method will wait till\n     * the promise resolves.\n     *\n     * @example\n     * HTML:\n     *\n     * ```html\n     * <div class=\"feed\">\n     *   <div class=\"tweet\">Hello!</div>\n     *   <div class=\"tweet\">Hi!</div>\n     * </div>\n     * ```\n     *\n     * JavaScript:\n     *\n     * ```ts\n     * const feedHandle = await page.$('.feed');\n     * expect(\n     *   await feedHandle.$$eval('.tweet', nodes => nodes.map(n => n.innerText))\n     * ).toEqual(['Hello!', 'Hi!']);\n     * ```\n     *\n     * @param selector -\n     * {@link https://pptr.dev/guides/page-interactions#selectors | selector}\n     * to query the page for.\n     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}\n     * can be passed as-is and a\n     * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}\n     * allows quering by\n     * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},\n     * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},\n     * and\n     * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}\n     * and\n     * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.\n     * Alternatively, you can specify the selector type using a\n     * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.\n     * @param pageFunction - The function to be evaluated in the element's page's\n     * context. An array of elements matching the given selector will be passed to\n     * the function as its first argument.\n     * @param args - Additional arguments to pass to `pageFunction`.\n     * @returns A promise to the result of the function.\n     */\n    async $$eval(selector, pageFunction, ...args) {\n      const env_2 = {\n        stack: [],\n        error: void 0,\n        hasError: false\n      };\n      try {\n        pageFunction = withSourcePuppeteerURLIfNone(this.$$eval.name, pageFunction);\n        const results = await this.$$(selector);\n        const elements = __addDisposableResource(env_2, await this.evaluateHandle((_, ...elements) => {\n          return elements;\n        }, ...results), false);\n        const [result] = await Promise.all([elements.evaluate(pageFunction, ...args), ...results.map(results => {\n          return results.dispose();\n        })]);\n        return result;\n      } catch (e_2) {\n        env_2.error = e_2;\n        env_2.hasError = true;\n      } finally {\n        __disposeResources(env_2);\n      }\n    }\n    /**\n     * Wait for an element matching the given selector to appear in the current\n     * element.\n     *\n     * Unlike {@link Frame.waitForSelector}, this method does not work across\n     * navigations or if the element is detached from DOM.\n     *\n     * @example\n     *\n     * ```ts\n     * import puppeteer from 'puppeteer';\n     *\n     * (async () => {\n     *   const browser = await puppeteer.launch();\n     *   const page = await browser.newPage();\n     *   let currentURL;\n     *   page\n     *     .mainFrame()\n     *     .waitForSelector('img')\n     *     .then(() => console.log('First URL with image: ' + currentURL));\n     *\n     *   for (currentURL of [\n     *     'https://example.com',\n     *     'https://google.com',\n     *     'https://bbc.com',\n     *   ]) {\n     *     await page.goto(currentURL);\n     *   }\n     *   await browser.close();\n     * })();\n     * ```\n     *\n     * @param selector - The selector to query and wait for.\n     * @param options - Options for customizing waiting behavior.\n     * @returns An element matching the given selector.\n     * @throws Throws if an element matching the given selector doesn't appear.\n     */\n    async waitForSelector(selector, options = {}) {\n      const {\n        updatedSelector,\n        QueryHandler,\n        polling\n      } = getQueryHandlerAndSelector(selector);\n      return await QueryHandler.waitFor(this, updatedSelector, {\n        polling,\n        ...options\n      });\n    }\n    async #checkVisibility(visibility) {\n      return await this.evaluate(async (element, PuppeteerUtil, visibility) => {\n        return Boolean(PuppeteerUtil.checkVisibility(element, visibility));\n      }, LazyArg.create(context => {\n        return context.puppeteerUtil;\n      }), visibility);\n    }\n    /**\n     * An element is considered to be visible if all of the following is\n     * true:\n     *\n     * - the element has\n     *   {@link https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle | computed styles}.\n     *\n     * - the element has a non-empty\n     *   {@link https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect | bounding client rect}.\n     *\n     * - the element's {@link https://developer.mozilla.org/en-US/docs/Web/CSS/visibility | visibility}\n     *   is not `hidden` or `collapse`.\n     */\n    async isVisible() {\n      return await this.#checkVisibility(true);\n    }\n    /**\n     * An element is considered to be hidden if at least one of the following is true:\n     *\n     * - the element has no\n     *   {@link https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle | computed styles}.\n     *\n     * - the element has an empty\n     *   {@link https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect | bounding client rect}.\n     *\n     * - the element's {@link https://developer.mozilla.org/en-US/docs/Web/CSS/visibility | visibility}\n     *   is `hidden` or `collapse`.\n     */\n    async isHidden() {\n      return await this.#checkVisibility(false);\n    }\n    /**\n     * Converts the current handle to the given element type.\n     *\n     * @example\n     *\n     * ```ts\n     * const element: ElementHandle<Element> = await page.$(\n     *   '.class-name-of-anchor'\n     * );\n     * // DO NOT DISPOSE `element`, this will be always be the same handle.\n     * const anchor: ElementHandle<HTMLAnchorElement> =\n     *   await element.toElement('a');\n     * ```\n     *\n     * @param tagName - The tag name of the desired element type.\n     * @throws An error if the handle does not match. **The handle will not be\n     * automatically disposed.**\n     */\n    async toElement(tagName) {\n      const isMatchingTagName = await this.evaluate((node, tagName) => {\n        return node.nodeName === tagName.toUpperCase();\n      }, tagName);\n      if (!isMatchingTagName) {\n        throw new Error(`Element is not a(n) \\`${tagName}\\` element`);\n      }\n      return this;\n    }\n    /**\n     * Returns the middle point within an element unless a specific offset is provided.\n     */\n    async clickablePoint(offset) {\n      const box = await this.#clickableBox();\n      if (!box) {\n        throw new Error('Node is either not clickable or not an Element');\n      }\n      if (offset !== undefined) {\n        return {\n          x: box.x + offset.x,\n          y: box.y + offset.y\n        };\n      }\n      return {\n        x: box.x + box.width / 2,\n        y: box.y + box.height / 2\n      };\n    }\n    /**\n     * This method scrolls element into view if needed, and then\n     * uses {@link Page.mouse} to hover over the center of the element.\n     * If the element is detached from DOM, the method throws an error.\n     */\n    async hover() {\n      await this.scrollIntoViewIfNeeded();\n      const {\n        x,\n        y\n      } = await this.clickablePoint();\n      await this.frame.page().mouse.move(x, y);\n    }\n    /**\n     * This method scrolls element into view if needed, and then\n     * uses {@link Page.mouse} to click in the center of the element.\n     * If the element is detached from DOM, the method throws an error.\n     */\n    async click(options = {}) {\n      await this.scrollIntoViewIfNeeded();\n      const {\n        x,\n        y\n      } = await this.clickablePoint(options.offset);\n      await this.frame.page().mouse.click(x, y, options);\n    }\n    /**\n     * Drags an element over the given element or point.\n     *\n     * @returns DEPRECATED. When drag interception is enabled, the drag payload is\n     * returned.\n     */\n    async drag(target) {\n      await this.scrollIntoViewIfNeeded();\n      const page = this.frame.page();\n      if (page.isDragInterceptionEnabled()) {\n        const source = await this.clickablePoint();\n        if (target instanceof ElementHandle) {\n          target = await target.clickablePoint();\n        }\n        return await page.mouse.drag(source, target);\n      }\n      try {\n        if (!page._isDragging) {\n          page._isDragging = true;\n          await this.hover();\n          await page.mouse.down();\n        }\n        if (target instanceof ElementHandle) {\n          await target.hover();\n        } else {\n          await page.mouse.move(target.x, target.y);\n        }\n      } catch (error) {\n        page._isDragging = false;\n        throw error;\n      }\n    }\n    /**\n     * @deprecated Do not use. `dragenter` will automatically be performed during dragging.\n     */\n    async dragEnter(data = {\n      items: [],\n      dragOperationsMask: 1\n    }) {\n      const page = this.frame.page();\n      await this.scrollIntoViewIfNeeded();\n      const target = await this.clickablePoint();\n      await page.mouse.dragEnter(target, data);\n    }\n    /**\n     * @deprecated Do not use. `dragover` will automatically be performed during dragging.\n     */\n    async dragOver(data = {\n      items: [],\n      dragOperationsMask: 1\n    }) {\n      const page = this.frame.page();\n      await this.scrollIntoViewIfNeeded();\n      const target = await this.clickablePoint();\n      await page.mouse.dragOver(target, data);\n    }\n    /**\n     * @internal\n     */\n    async drop(dataOrElement = {\n      items: [],\n      dragOperationsMask: 1\n    }) {\n      const page = this.frame.page();\n      if ('items' in dataOrElement) {\n        await this.scrollIntoViewIfNeeded();\n        const destination = await this.clickablePoint();\n        await page.mouse.drop(destination, dataOrElement);\n      } else {\n        // Note if the rest errors, we still want dragging off because the errors\n        // is most likely something implying the mouse is no longer dragging.\n        await dataOrElement.drag(this);\n        page._isDragging = false;\n        await page.mouse.up();\n      }\n    }\n    /**\n     * @deprecated Use `ElementHandle.drop` instead.\n     */\n    async dragAndDrop(target, options) {\n      const page = this.frame.page();\n      assert(page.isDragInterceptionEnabled(), 'Drag Interception is not enabled!');\n      await this.scrollIntoViewIfNeeded();\n      const startPoint = await this.clickablePoint();\n      const targetPoint = await target.clickablePoint();\n      await page.mouse.dragAndDrop(startPoint, targetPoint, options);\n    }\n    /**\n     * Triggers a `change` and `input` event once all the provided options have been\n     * selected. If there's no `<select>` element matching `selector`, the method\n     * throws an error.\n     *\n     * @example\n     *\n     * ```ts\n     * handle.select('blue'); // single selection\n     * handle.select('red', 'green', 'blue'); // multiple selections\n     * ```\n     *\n     * @param values - Values of options to select. If the `<select>` has the\n     * `multiple` attribute, all values are considered, otherwise only the first\n     * one is taken into account.\n     */\n    async select(...values) {\n      for (const value of values) {\n        assert(isString(value), 'Values must be strings. Found value \"' + value + '\" of type \"' + typeof value + '\"');\n      }\n      return await this.evaluate((element, vals) => {\n        const values = new Set(vals);\n        if (!(element instanceof HTMLSelectElement)) {\n          throw new Error('Element is not a <select> element.');\n        }\n        const selectedValues = new Set();\n        if (!element.multiple) {\n          for (const option of element.options) {\n            option.selected = false;\n          }\n          for (const option of element.options) {\n            if (values.has(option.value)) {\n              option.selected = true;\n              selectedValues.add(option.value);\n              break;\n            }\n          }\n        } else {\n          for (const option of element.options) {\n            option.selected = values.has(option.value);\n            if (option.selected) {\n              selectedValues.add(option.value);\n            }\n          }\n        }\n        element.dispatchEvent(new Event('input', {\n          bubbles: true\n        }));\n        element.dispatchEvent(new Event('change', {\n          bubbles: true\n        }));\n        return [...selectedValues.values()];\n      }, values);\n    }\n    /**\n     * This method scrolls element into view if needed, and then uses\n     * {@link Touchscreen.tap} to tap in the center of the element.\n     * If the element is detached from DOM, the method throws an error.\n     */\n    async tap() {\n      await this.scrollIntoViewIfNeeded();\n      const {\n        x,\n        y\n      } = await this.clickablePoint();\n      await this.frame.page().touchscreen.tap(x, y);\n    }\n    async touchStart() {\n      await this.scrollIntoViewIfNeeded();\n      const {\n        x,\n        y\n      } = await this.clickablePoint();\n      await this.frame.page().touchscreen.touchStart(x, y);\n    }\n    async touchMove() {\n      await this.scrollIntoViewIfNeeded();\n      const {\n        x,\n        y\n      } = await this.clickablePoint();\n      await this.frame.page().touchscreen.touchMove(x, y);\n    }\n    async touchEnd() {\n      await this.scrollIntoViewIfNeeded();\n      await this.frame.page().touchscreen.touchEnd();\n    }\n    /**\n     * Calls {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus | focus} on the element.\n     */\n    async focus() {\n      await this.evaluate(element => {\n        if (!(element instanceof HTMLElement)) {\n          throw new Error('Cannot focus non-HTMLElement');\n        }\n        return element.focus();\n      });\n    }\n    /**\n     * Focuses the element, and then sends a `keydown`, `keypress`/`input`, and\n     * `keyup` event for each character in the text.\n     *\n     * To press a special key, like `Control` or `ArrowDown`,\n     * use {@link ElementHandle.press}.\n     *\n     * @example\n     *\n     * ```ts\n     * await elementHandle.type('Hello'); // Types instantly\n     * await elementHandle.type('World', {delay: 100}); // Types slower, like a user\n     * ```\n     *\n     * @example\n     * An example of typing into a text field and then submitting the form:\n     *\n     * ```ts\n     * const elementHandle = await page.$('input');\n     * await elementHandle.type('some text');\n     * await elementHandle.press('Enter');\n     * ```\n     *\n     * @param options - Delay in milliseconds. Defaults to 0.\n     */\n    async type(text, options) {\n      await this.focus();\n      await this.frame.page().keyboard.type(text, options);\n    }\n    /**\n     * Focuses the element, and then uses {@link Keyboard.down} and {@link Keyboard.up}.\n     *\n     * @remarks\n     * If `key` is a single character and no modifier keys besides `Shift`\n     * are being held down, a `keypress`/`input` event will also be generated.\n     * The `text` option can be specified to force an input event to be generated.\n     *\n     * **NOTE** Modifier keys DO affect `elementHandle.press`. Holding down `Shift`\n     * will type the text in upper case.\n     *\n     * @param key - Name of key to press, such as `ArrowLeft`.\n     * See {@link KeyInput} for a list of all key names.\n     */\n    async press(key, options) {\n      await this.focus();\n      await this.frame.page().keyboard.press(key, options);\n    }\n    async #clickableBox() {\n      const boxes = await this.evaluate(element => {\n        if (!(element instanceof Element)) {\n          return null;\n        }\n        return [...element.getClientRects()].map(rect => {\n          return {\n            x: rect.x,\n            y: rect.y,\n            width: rect.width,\n            height: rect.height\n          };\n        });\n      });\n      if (!boxes?.length) {\n        return null;\n      }\n      await this.#intersectBoundingBoxesWithFrame(boxes);\n      let frame = this.frame;\n      let parentFrame;\n      while (parentFrame = frame?.parentFrame()) {\n        const env_3 = {\n          stack: [],\n          error: void 0,\n          hasError: false\n        };\n        try {\n          const handle = __addDisposableResource(env_3, await frame.frameElement(), false);\n          if (!handle) {\n            throw new Error('Unsupported frame type');\n          }\n          const parentBox = await handle.evaluate(element => {\n            // Element is not visible.\n            if (element.getClientRects().length === 0) {\n              return null;\n            }\n            const rect = element.getBoundingClientRect();\n            const style = window.getComputedStyle(element);\n            return {\n              left: rect.left + parseInt(style.paddingLeft, 10) + parseInt(style.borderLeftWidth, 10),\n              top: rect.top + parseInt(style.paddingTop, 10) + parseInt(style.borderTopWidth, 10)\n            };\n          });\n          if (!parentBox) {\n            return null;\n          }\n          for (const box of boxes) {\n            box.x += parentBox.left;\n            box.y += parentBox.top;\n          }\n          await handle.#intersectBoundingBoxesWithFrame(boxes);\n          frame = parentFrame;\n        } catch (e_3) {\n          env_3.error = e_3;\n          env_3.hasError = true;\n        } finally {\n          __disposeResources(env_3);\n        }\n      }\n      const box = boxes.find(box => {\n        return box.width >= 1 && box.height >= 1;\n      });\n      if (!box) {\n        return null;\n      }\n      return {\n        x: box.x,\n        y: box.y,\n        height: box.height,\n        width: box.width\n      };\n    }\n    async #intersectBoundingBoxesWithFrame(boxes) {\n      const {\n        documentWidth,\n        documentHeight\n      } = await this.frame.isolatedRealm().evaluate(() => {\n        return {\n          documentWidth: document.documentElement.clientWidth,\n          documentHeight: document.documentElement.clientHeight\n        };\n      });\n      for (const box of boxes) {\n        intersectBoundingBox(box, documentWidth, documentHeight);\n      }\n    }\n    /**\n     * This method returns the bounding box of the element (relative to the main frame),\n     * or `null` if the element is {@link https://drafts.csswg.org/css-display-4/#box-generation | not part of the layout}\n     * (example: `display: none`).\n     */\n    async boundingBox() {\n      const box = await this.evaluate(element => {\n        if (!(element instanceof Element)) {\n          return null;\n        }\n        // Element is not visible.\n        if (element.getClientRects().length === 0) {\n          return null;\n        }\n        const rect = element.getBoundingClientRect();\n        return {\n          x: rect.x,\n          y: rect.y,\n          width: rect.width,\n          height: rect.height\n        };\n      });\n      if (!box) {\n        return null;\n      }\n      const offset = await this.#getTopLeftCornerOfFrame();\n      if (!offset) {\n        return null;\n      }\n      return {\n        x: box.x + offset.x,\n        y: box.y + offset.y,\n        height: box.height,\n        width: box.width\n      };\n    }\n    /**\n     * This method returns boxes of the element,\n     * or `null` if the element is {@link https://drafts.csswg.org/css-display-4/#box-generation | not part of the layout}\n     * (example: `display: none`).\n     *\n     * @remarks\n     *\n     * Boxes are represented as an array of points;\n     * Each Point is an object `{x, y}`. Box points are sorted clock-wise.\n     */\n    async boxModel() {\n      const model = await this.evaluate(element => {\n        if (!(element instanceof Element)) {\n          return null;\n        }\n        // Element is not visible.\n        if (element.getClientRects().length === 0) {\n          return null;\n        }\n        const rect = element.getBoundingClientRect();\n        const style = window.getComputedStyle(element);\n        const offsets = {\n          padding: {\n            left: parseInt(style.paddingLeft, 10),\n            top: parseInt(style.paddingTop, 10),\n            right: parseInt(style.paddingRight, 10),\n            bottom: parseInt(style.paddingBottom, 10)\n          },\n          margin: {\n            left: -parseInt(style.marginLeft, 10),\n            top: -parseInt(style.marginTop, 10),\n            right: -parseInt(style.marginRight, 10),\n            bottom: -parseInt(style.marginBottom, 10)\n          },\n          border: {\n            left: parseInt(style.borderLeft, 10),\n            top: parseInt(style.borderTop, 10),\n            right: parseInt(style.borderRight, 10),\n            bottom: parseInt(style.borderBottom, 10)\n          }\n        };\n        const border = [{\n          x: rect.left,\n          y: rect.top\n        }, {\n          x: rect.left + rect.width,\n          y: rect.top\n        }, {\n          x: rect.left + rect.width,\n          y: rect.top + rect.bottom\n        }, {\n          x: rect.left,\n          y: rect.top + rect.bottom\n        }];\n        const padding = transformQuadWithOffsets(border, offsets.border);\n        const content = transformQuadWithOffsets(padding, offsets.padding);\n        const margin = transformQuadWithOffsets(border, offsets.margin);\n        return {\n          content,\n          padding,\n          border,\n          margin,\n          width: rect.width,\n          height: rect.height\n        };\n        function transformQuadWithOffsets(quad, offsets) {\n          return [{\n            x: quad[0].x + offsets.left,\n            y: quad[0].y + offsets.top\n          }, {\n            x: quad[1].x - offsets.right,\n            y: quad[1].y + offsets.top\n          }, {\n            x: quad[2].x - offsets.right,\n            y: quad[2].y - offsets.bottom\n          }, {\n            x: quad[3].x + offsets.left,\n            y: quad[3].y - offsets.bottom\n          }];\n        }\n      });\n      if (!model) {\n        return null;\n      }\n      const offset = await this.#getTopLeftCornerOfFrame();\n      if (!offset) {\n        return null;\n      }\n      for (const attribute of ['content', 'padding', 'border', 'margin']) {\n        for (const point of model[attribute]) {\n          point.x += offset.x;\n          point.y += offset.y;\n        }\n      }\n      return model;\n    }\n    async #getTopLeftCornerOfFrame() {\n      const point = {\n        x: 0,\n        y: 0\n      };\n      let frame = this.frame;\n      let parentFrame;\n      while (parentFrame = frame?.parentFrame()) {\n        const env_4 = {\n          stack: [],\n          error: void 0,\n          hasError: false\n        };\n        try {\n          const handle = __addDisposableResource(env_4, await frame.frameElement(), false);\n          if (!handle) {\n            throw new Error('Unsupported frame type');\n          }\n          const parentBox = await handle.evaluate(element => {\n            // Element is not visible.\n            if (element.getClientRects().length === 0) {\n              return null;\n            }\n            const rect = element.getBoundingClientRect();\n            const style = window.getComputedStyle(element);\n            return {\n              left: rect.left + parseInt(style.paddingLeft, 10) + parseInt(style.borderLeftWidth, 10),\n              top: rect.top + parseInt(style.paddingTop, 10) + parseInt(style.borderTopWidth, 10)\n            };\n          });\n          if (!parentBox) {\n            return null;\n          }\n          point.x += parentBox.left;\n          point.y += parentBox.top;\n          frame = parentFrame;\n        } catch (e_4) {\n          env_4.error = e_4;\n          env_4.hasError = true;\n        } finally {\n          __disposeResources(env_4);\n        }\n      }\n      return point;\n    }\n    async screenshot(options = {}) {\n      const {\n        scrollIntoView = true,\n        clip\n      } = options;\n      const page = this.frame.page();\n      // Only scroll the element into view if the user wants it.\n      if (scrollIntoView) {\n        await this.scrollIntoViewIfNeeded();\n      }\n      const elementClip = await this.#nonEmptyVisibleBoundingBox();\n      const [pageLeft, pageTop] = await this.evaluate(() => {\n        if (!window.visualViewport) {\n          throw new Error('window.visualViewport is not supported.');\n        }\n        return [window.visualViewport.pageLeft, window.visualViewport.pageTop];\n      });\n      elementClip.x += pageLeft;\n      elementClip.y += pageTop;\n      if (clip) {\n        elementClip.x += clip.x;\n        elementClip.y += clip.y;\n        elementClip.height = clip.height;\n        elementClip.width = clip.width;\n      }\n      return await page.screenshot({\n        ...options,\n        clip: elementClip\n      });\n    }\n    async #nonEmptyVisibleBoundingBox() {\n      const box = await this.boundingBox();\n      assert(box, 'Node is either not visible or not an HTMLElement');\n      assert(box.width !== 0, 'Node has 0 width.');\n      assert(box.height !== 0, 'Node has 0 height.');\n      return box;\n    }\n    /**\n     * @internal\n     */\n    async assertConnectedElement() {\n      const error = await this.evaluate(async element => {\n        if (!element.isConnected) {\n          return 'Node is detached from document';\n        }\n        if (element.nodeType !== Node.ELEMENT_NODE) {\n          return 'Node is not of type HTMLElement';\n        }\n        return;\n      });\n      if (error) {\n        throw new Error(error);\n      }\n    }\n    /**\n     * @internal\n     */\n    async scrollIntoViewIfNeeded() {\n      if (await this.isIntersectingViewport({\n        threshold: 1\n      })) {\n        return;\n      }\n      await this.scrollIntoView();\n    }\n    /**\n     * Resolves to true if the element is visible in the current viewport. If an\n     * element is an SVG, we check if the svg owner element is in the viewport\n     * instead. See https://crbug.com/963246.\n     *\n     * @param options - Threshold for the intersection between 0 (no intersection) and 1\n     * (full intersection). Defaults to 1.\n     */\n    async isIntersectingViewport(options = {}) {\n      const env_5 = {\n        stack: [],\n        error: void 0,\n        hasError: false\n      };\n      try {\n        await this.assertConnectedElement();\n        // eslint-disable-next-line rulesdir/use-using -- Returns `this`.\n        const handle = await this.#asSVGElementHandle();\n        const target = __addDisposableResource(env_5, handle && (await handle.#getOwnerSVGElement()), false);\n        return await (target ?? this).evaluate(async (element, threshold) => {\n          const visibleRatio = await new Promise(resolve => {\n            const observer = new IntersectionObserver(entries => {\n              resolve(entries[0].intersectionRatio);\n              observer.disconnect();\n            });\n            observer.observe(element);\n          });\n          return threshold === 1 ? visibleRatio === 1 : visibleRatio > threshold;\n        }, options.threshold ?? 0);\n      } catch (e_5) {\n        env_5.error = e_5;\n        env_5.hasError = true;\n      } finally {\n        __disposeResources(env_5);\n      }\n    }\n    /**\n     * Scrolls the element into view using either the automation protocol client\n     * or by calling element.scrollIntoView.\n     */\n    async scrollIntoView() {\n      await this.assertConnectedElement();\n      await this.evaluate(async element => {\n        element.scrollIntoView({\n          block: 'center',\n          inline: 'center',\n          behavior: 'instant'\n        });\n      });\n    }\n    /**\n     * Returns true if an element is an SVGElement (included svg, path, rect\n     * etc.).\n     */\n    async #asSVGElementHandle() {\n      if (await this.evaluate(element => {\n        return element instanceof SVGElement;\n      })) {\n        return this;\n      } else {\n        return null;\n      }\n    }\n    async #getOwnerSVGElement() {\n      // SVGSVGElement.ownerSVGElement === null.\n      return await this.evaluateHandle(element => {\n        if (element instanceof SVGSVGElement) {\n          return element;\n        }\n        return element.ownerSVGElement;\n      });\n    }\n  };\n})();\nexport { ElementHandle };\nfunction intersectBoundingBox(box, width, height) {\n  box.width = Math.max(box.x >= 0 ? Math.min(width - box.x, box.width) : Math.min(width, box.width + box.x), 0);\n  box.height = Math.max(box.y >= 0 ? Math.min(height - box.y, box.height) : Math.min(height, box.height + box.y), 0);\n}","map":{"version":3,"names":["getQueryHandlerAndSelector","LazyArg","isString","withSourcePuppeteerURLIfNone","assert","AsyncIterableUtil","throwIfDisposed","_isElementHandle","JSHandle","ElementHandle","_classSuper","_a","bindIsolatedHandle","bind","_b","_c","_d","_e","_f","_g","_h","_j","_k","_l","_m","_o","_p","_q","_r","_s","_t","_u","_v","_w","_x","_y","_z","_0","_1","_2","_3","_4","_5","__esDecorate","_getProperty_decorators","kind","name","static","private","access","has","obj","get","getProperty","metadata","_metadata","_instanceExtraInitializers","_getProperties_decorators","getProperties","_jsonValue_decorators","jsonValue","_$_decorators","$","_$$_decorators","$$","_private_$$_descriptor","value","__setFunctionName","selector","$$impl","_private_$$_decorators","_waitForSelector_decorators","waitForSelector","_isVisible_decorators","isVisible","_isHidden_decorators","isHidden","_toElement_decorators","toElement","_clickablePoint_decorators","clickablePoint","_hover_decorators","hover","_click_decorators","click","_drag_decorators","drag","_dragEnter_decorators","dragEnter","_dragOver_decorators","dragOver","_drop_decorators","drop","_dragAndDrop_decorators","dragAndDrop","_select_decorators","select","_tap_decorators","tap","_touchStart_decorators","touchStart","_touchMove_decorators","touchMove","_touchEnd_decorators","touchEnd","_focus_decorators","focus","_type_decorators","type","_press_decorators","press","_boundingBox_decorators","boundingBox","_boxModel_decorators","boxModel","_screenshot_decorators","screenshot","_isIntersectingViewport_decorators","isIntersectingViewport","_scrollIntoView_decorators","scrollIntoView","isolatedHandle","__runInitializers","target","_","args","realm","frame","isolatedRealm","call","adoptedThis","adoptHandle","result","transferHandle","Array","isArray","Promise","all","map","item","index","Map","entries","key","set","handle","constructor","id","disposed","propertyName","evaluate","pageFunction","evaluateHandle","toString","remoteObject","dispose","asElement","updatedSelector","QueryHandler","queryOne","options","isolate","#$$","#$$impl","collect","queryAll","$eval","elementHandle","__addDisposableResource","env_1","Error","$$eval","results","elements","env_2","polling","waitFor","checkVisibility","#checkVisibility","visibility","element","PuppeteerUtil","Boolean","create","context","puppeteerUtil","tagName","isMatchingTagName","node","nodeName","toUpperCase","offset","box","clickableBox","undefined","x","y","width","height","scrollIntoViewIfNeeded","page","mouse","move","isDragInterceptionEnabled","source","_isDragging","down","error","data","items","dragOperationsMask","dataOrElement","destination","up","startPoint","targetPoint","values","vals","Set","HTMLSelectElement","selectedValues","multiple","option","selected","add","dispatchEvent","Event","bubbles","touchscreen","HTMLElement","text","keyboard","#clickableBox","boxes","Element","getClientRects","rect","length","intersectBoundingBoxesWithFrame","parentFrame","env_3","frameElement","parentBox","getBoundingClientRect","style","window","getComputedStyle","left","parseInt","paddingLeft","borderLeftWidth","top","paddingTop","borderTopWidth","find","#intersectBoundingBoxesWithFrame","documentWidth","documentHeight","document","documentElement","clientWidth","clientHeight","intersectBoundingBox","getTopLeftCornerOfFrame","model","offsets","padding","right","paddingRight","bottom","paddingBottom","margin","marginLeft","marginTop","marginRight","marginBottom","border","borderLeft","borderTop","borderRight","borderBottom","transformQuadWithOffsets","content","quad","attribute","point","#getTopLeftCornerOfFrame","env_4","clip","elementClip","nonEmptyVisibleBoundingBox","pageLeft","pageTop","visualViewport","#nonEmptyVisibleBoundingBox","assertConnectedElement","isConnected","nodeType","Node","ELEMENT_NODE","threshold","asSVGElementHandle","env_5","getOwnerSVGElement","visibleRatio","resolve","observer","IntersectionObserver","intersectionRatio","disconnect","observe","block","inline","behavior","#asSVGElementHandle","SVGElement","#getOwnerSVGElement","SVGSVGElement","ownerSVGElement","Math","max","min"],"sources":["C:\\Users\\raffy\\Desktop\\test\\node_modules\\puppeteer-core\\src\\api\\ElementHandle.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2023 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport type {Protocol} from 'devtools-protocol';\n\nimport type {Frame} from '../api/Frame.js';\nimport {getQueryHandlerAndSelector} from '../common/GetQueryHandler.js';\nimport {LazyArg} from '../common/LazyArg.js';\nimport type {\n  AwaitableIterable,\n  ElementFor,\n  EvaluateFuncWith,\n  HandleFor,\n  HandleOr,\n  NodeFor,\n} from '../common/types.js';\nimport type {KeyInput} from '../common/USKeyboardLayout.js';\nimport {isString, withSourcePuppeteerURLIfNone} from '../common/util.js';\nimport {assert} from '../util/assert.js';\nimport {AsyncIterableUtil} from '../util/AsyncIterableUtil.js';\nimport {throwIfDisposed} from '../util/decorators.js';\n\nimport {_isElementHandle} from './ElementHandleSymbol.js';\nimport type {\n  KeyboardTypeOptions,\n  KeyPressOptions,\n  MouseClickOptions,\n} from './Input.js';\nimport {JSHandle} from './JSHandle.js';\nimport type {\n  QueryOptions,\n  ScreenshotOptions,\n  WaitForSelectorOptions,\n} from './Page.js';\n\n/**\n * @public\n */\nexport type Quad = [Point, Point, Point, Point];\n\n/**\n * @public\n */\nexport interface BoxModel {\n  content: Quad;\n  padding: Quad;\n  border: Quad;\n  margin: Quad;\n  width: number;\n  height: number;\n}\n\n/**\n * @public\n */\nexport interface BoundingBox extends Point {\n  /**\n   * the width of the element in pixels.\n   */\n  width: number;\n  /**\n   * the height of the element in pixels.\n   */\n  height: number;\n}\n\n/**\n * @public\n */\nexport interface Offset {\n  /**\n   * x-offset for the clickable point relative to the top-left corner of the border box.\n   */\n  x: number;\n  /**\n   * y-offset for the clickable point relative to the top-left corner of the border box.\n   */\n  y: number;\n}\n\n/**\n * @public\n */\nexport interface ClickOptions extends MouseClickOptions {\n  /**\n   * Offset for the clickable point relative to the top-left corner of the border box.\n   */\n  offset?: Offset;\n}\n\n/**\n * @public\n */\nexport interface Point {\n  x: number;\n  y: number;\n}\n\n/**\n * @public\n */\nexport interface ElementScreenshotOptions extends ScreenshotOptions {\n  /**\n   * @defaultValue `true`\n   */\n  scrollIntoView?: boolean;\n}\n\n/**\n * ElementHandle represents an in-page DOM element.\n *\n * @remarks\n * ElementHandles can be created with the {@link Page.$} method.\n *\n * ```ts\n * import puppeteer from 'puppeteer';\n *\n * (async () => {\n *   const browser = await puppeteer.launch();\n *   const page = await browser.newPage();\n *   await page.goto('https://example.com');\n *   const hrefElement = await page.$('a');\n *   await hrefElement.click();\n *   // ...\n * })();\n * ```\n *\n * ElementHandle prevents the DOM element from being garbage-collected unless the\n * handle is {@link JSHandle.dispose | disposed}. ElementHandles are auto-disposed\n * when their origin frame gets navigated.\n *\n * ElementHandle instances can be used as arguments in {@link Page.$eval} and\n * {@link Page.evaluate} methods.\n *\n * If you're using TypeScript, ElementHandle takes a generic argument that\n * denotes the type of element the handle is holding within. For example, if you\n * have a handle to a `<select>` element, you can type it as\n * `ElementHandle<HTMLSelectElement>` and you get some nicer type checks.\n *\n * @public\n */\nexport abstract class ElementHandle<\n  ElementType extends Node = Element,\n> extends JSHandle<ElementType> {\n  /**\n   * @internal\n   */\n  declare [_isElementHandle]: boolean;\n\n  /**\n   * @internal\n   * Cached isolatedHandle to prevent\n   * trying to adopt it multiple times\n   */\n  isolatedHandle?: typeof this;\n\n  /**\n   * A given method will have it's `this` replaced with an isolated version of\n   * `this` when decorated with this decorator.\n   *\n   * All changes of isolated `this` are reflected on the actual `this`.\n   *\n   * @internal\n   */\n  static bindIsolatedHandle<This extends ElementHandle<Node>>(\n    target: (this: This, ...args: any[]) => Promise<any>,\n    _: unknown\n  ): typeof target {\n    return async function (...args) {\n      // If the handle is already isolated, then we don't need to adopt it\n      // again.\n      if (this.realm === this.frame.isolatedRealm()) {\n        return await target.call(this, ...args);\n      }\n      let adoptedThis: This;\n      if (this['isolatedHandle']) {\n        adoptedThis = this['isolatedHandle'];\n      } else {\n        this['isolatedHandle'] = adoptedThis = await this.frame\n          .isolatedRealm()\n          .adoptHandle(this);\n      }\n      const result = await target.call(adoptedThis, ...args);\n      // If the function returns `adoptedThis`, then we return `this`.\n      if (result === adoptedThis) {\n        return this;\n      }\n      // If the function returns a handle, transfer it into the current realm.\n      if (result instanceof JSHandle) {\n        return await this.realm.transferHandle(result);\n      }\n      // If the function returns an array of handlers, transfer them into the\n      // current realm.\n      if (Array.isArray(result)) {\n        await Promise.all(\n          result.map(async (item, index, result) => {\n            if (item instanceof JSHandle) {\n              result[index] = await this.realm.transferHandle(item);\n            }\n          })\n        );\n      }\n      if (result instanceof Map) {\n        await Promise.all(\n          [...result.entries()].map(async ([key, value]) => {\n            if (value instanceof JSHandle) {\n              result.set(key, await this.realm.transferHandle(value));\n            }\n          })\n        );\n      }\n      return result;\n    };\n  }\n\n  /**\n   * @internal\n   */\n  protected readonly handle;\n\n  /**\n   * @internal\n   */\n  constructor(handle: JSHandle<ElementType>) {\n    super();\n    this.handle = handle;\n    this[_isElementHandle] = true;\n  }\n\n  /**\n   * @internal\n   */\n  override get id(): string | undefined {\n    return this.handle.id;\n  }\n\n  /**\n   * @internal\n   */\n  override get disposed(): boolean {\n    return this.handle.disposed;\n  }\n\n  /**\n   * @internal\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  override async getProperty<K extends keyof ElementType>(\n    propertyName: HandleOr<K>\n  ): Promise<HandleFor<ElementType[K]>> {\n    return await this.handle.getProperty(propertyName);\n  }\n\n  /**\n   * @internal\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  override async getProperties(): Promise<Map<string, JSHandle>> {\n    return await this.handle.getProperties();\n  }\n\n  /**\n   * @internal\n   */\n  override async evaluate<\n    Params extends unknown[],\n    Func extends EvaluateFuncWith<ElementType, Params> = EvaluateFuncWith<\n      ElementType,\n      Params\n    >,\n  >(\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<Awaited<ReturnType<Func>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(\n      this.evaluate.name,\n      pageFunction\n    );\n    return await this.handle.evaluate(pageFunction, ...args);\n  }\n\n  /**\n   * @internal\n   */\n  override async evaluateHandle<\n    Params extends unknown[],\n    Func extends EvaluateFuncWith<ElementType, Params> = EvaluateFuncWith<\n      ElementType,\n      Params\n    >,\n  >(\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<HandleFor<Awaited<ReturnType<Func>>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(\n      this.evaluateHandle.name,\n      pageFunction\n    );\n    return await this.handle.evaluateHandle(pageFunction, ...args);\n  }\n\n  /**\n   * @internal\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  override async jsonValue(): Promise<ElementType> {\n    return await this.handle.jsonValue();\n  }\n\n  /**\n   * @internal\n   */\n  override toString(): string {\n    return this.handle.toString();\n  }\n\n  /**\n   * @internal\n   */\n  override remoteObject(): Protocol.Runtime.RemoteObject {\n    return this.handle.remoteObject();\n  }\n\n  /**\n   * @internal\n   */\n  override dispose(): Promise<void> {\n    return this.handle.dispose();\n  }\n\n  /**\n   * @internal\n   */\n  override asElement(): ElementHandle<ElementType> {\n    return this;\n  }\n\n  /**\n   * Frame corresponding to the current handle.\n   */\n  abstract get frame(): Frame;\n\n  /**\n   * Queries the current element for an element matching the given selector.\n   *\n   * @param selector -\n   * {@link https://pptr.dev/guides/page-interactions#selectors | selector}\n   * to query the page for.\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}\n   * can be passed as-is and a\n   * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}\n   * allows quering by\n   * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},\n   * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},\n   * and\n   * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}\n   * and\n   * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.\n   * Alternatively, you can specify the selector type using a\n   * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.\n   * @returns A {@link ElementHandle | element handle} to the first element\n   * matching the given selector. Otherwise, `null`.\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async $<Selector extends string>(\n    selector: Selector\n  ): Promise<ElementHandle<NodeFor<Selector>> | null> {\n    const {updatedSelector, QueryHandler} =\n      getQueryHandlerAndSelector(selector);\n    return (await QueryHandler.queryOne(\n      this,\n      updatedSelector\n    )) as ElementHandle<NodeFor<Selector>> | null;\n  }\n\n  /**\n   * Queries the current element for all elements matching the given selector.\n   *\n   * @param selector -\n   * {@link https://pptr.dev/guides/page-interactions#selectors | selector}\n   * to query the page for.\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}\n   * can be passed as-is and a\n   * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}\n   * allows quering by\n   * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},\n   * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},\n   * and\n   * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}\n   * and\n   * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.\n   * Alternatively, you can specify the selector type using a\n   * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.\n   * @returns An array of {@link ElementHandle | element handles} that point to\n   * elements matching the given selector.\n   */\n  @throwIfDisposed()\n  async $$<Selector extends string>(\n    selector: Selector,\n    options?: QueryOptions\n  ): Promise<Array<ElementHandle<NodeFor<Selector>>>> {\n    if (options?.isolate === false) {\n      return await this.#$$impl(selector);\n    }\n    return await this.#$$(selector);\n  }\n\n  /**\n   * Isolates {@link ElementHandle.$$} if needed.\n   *\n   * @internal\n   */\n  @ElementHandle.bindIsolatedHandle\n  async #$$<Selector extends string>(\n    selector: Selector\n  ): Promise<Array<ElementHandle<NodeFor<Selector>>>> {\n    return await this.#$$impl(selector);\n  }\n\n  /**\n   * Implementation for {@link ElementHandle.$$}.\n   *\n   * @internal\n   */\n  async #$$impl<Selector extends string>(\n    selector: Selector\n  ): Promise<Array<ElementHandle<NodeFor<Selector>>>> {\n    const {updatedSelector, QueryHandler} =\n      getQueryHandlerAndSelector(selector);\n    return await (AsyncIterableUtil.collect(\n      QueryHandler.queryAll(this, updatedSelector)\n    ) as Promise<Array<ElementHandle<NodeFor<Selector>>>>);\n  }\n\n  /**\n   * Runs the given function on the first element matching the given selector in\n   * the current element.\n   *\n   * If the given function returns a promise, then this method will wait till\n   * the promise resolves.\n   *\n   * @example\n   *\n   * ```ts\n   * const tweetHandle = await page.$('.tweet');\n   * expect(await tweetHandle.$eval('.like', node => node.innerText)).toBe(\n   *   '100'\n   * );\n   * expect(await tweetHandle.$eval('.retweets', node => node.innerText)).toBe(\n   *   '10'\n   * );\n   * ```\n   *\n   * @param selector -\n   * {@link https://pptr.dev/guides/page-interactions#selectors | selector}\n   * to query the page for.\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}\n   * can be passed as-is and a\n   * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}\n   * allows quering by\n   * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},\n   * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},\n   * and\n   * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}\n   * and\n   * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.\n   * Alternatively, you can specify the selector type using a\n   * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.\n   * @param pageFunction - The function to be evaluated in this element's page's\n   * context. The first element matching the selector will be passed in as the\n   * first argument.\n   * @param args - Additional arguments to pass to `pageFunction`.\n   * @returns A promise to the result of the function.\n   */\n  async $eval<\n    Selector extends string,\n    Params extends unknown[],\n    Func extends EvaluateFuncWith<NodeFor<Selector>, Params> = EvaluateFuncWith<\n      NodeFor<Selector>,\n      Params\n    >,\n  >(\n    selector: Selector,\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<Awaited<ReturnType<Func>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(this.$eval.name, pageFunction);\n    using elementHandle = await this.$(selector);\n    if (!elementHandle) {\n      throw new Error(\n        `Error: failed to find element matching selector \"${selector}\"`\n      );\n    }\n    return await elementHandle.evaluate(pageFunction, ...args);\n  }\n\n  /**\n   * Runs the given function on an array of elements matching the given selector\n   * in the current element.\n   *\n   * If the given function returns a promise, then this method will wait till\n   * the promise resolves.\n   *\n   * @example\n   * HTML:\n   *\n   * ```html\n   * <div class=\"feed\">\n   *   <div class=\"tweet\">Hello!</div>\n   *   <div class=\"tweet\">Hi!</div>\n   * </div>\n   * ```\n   *\n   * JavaScript:\n   *\n   * ```ts\n   * const feedHandle = await page.$('.feed');\n   * expect(\n   *   await feedHandle.$$eval('.tweet', nodes => nodes.map(n => n.innerText))\n   * ).toEqual(['Hello!', 'Hi!']);\n   * ```\n   *\n   * @param selector -\n   * {@link https://pptr.dev/guides/page-interactions#selectors | selector}\n   * to query the page for.\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}\n   * can be passed as-is and a\n   * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}\n   * allows quering by\n   * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},\n   * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},\n   * and\n   * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}\n   * and\n   * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.\n   * Alternatively, you can specify the selector type using a\n   * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.\n   * @param pageFunction - The function to be evaluated in the element's page's\n   * context. An array of elements matching the given selector will be passed to\n   * the function as its first argument.\n   * @param args - Additional arguments to pass to `pageFunction`.\n   * @returns A promise to the result of the function.\n   */\n  async $$eval<\n    Selector extends string,\n    Params extends unknown[],\n    Func extends EvaluateFuncWith<\n      Array<NodeFor<Selector>>,\n      Params\n    > = EvaluateFuncWith<Array<NodeFor<Selector>>, Params>,\n  >(\n    selector: Selector,\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<Awaited<ReturnType<Func>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(this.$$eval.name, pageFunction);\n    const results = await this.$$(selector);\n    using elements = await this.evaluateHandle(\n      (_, ...elements) => {\n        return elements;\n      },\n      ...results\n    );\n    const [result] = await Promise.all([\n      elements.evaluate(pageFunction, ...args),\n      ...results.map(results => {\n        return results.dispose();\n      }),\n    ]);\n    return result;\n  }\n\n  /**\n   * Wait for an element matching the given selector to appear in the current\n   * element.\n   *\n   * Unlike {@link Frame.waitForSelector}, this method does not work across\n   * navigations or if the element is detached from DOM.\n   *\n   * @example\n   *\n   * ```ts\n   * import puppeteer from 'puppeteer';\n   *\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   const page = await browser.newPage();\n   *   let currentURL;\n   *   page\n   *     .mainFrame()\n   *     .waitForSelector('img')\n   *     .then(() => console.log('First URL with image: ' + currentURL));\n   *\n   *   for (currentURL of [\n   *     'https://example.com',\n   *     'https://google.com',\n   *     'https://bbc.com',\n   *   ]) {\n   *     await page.goto(currentURL);\n   *   }\n   *   await browser.close();\n   * })();\n   * ```\n   *\n   * @param selector - The selector to query and wait for.\n   * @param options - Options for customizing waiting behavior.\n   * @returns An element matching the given selector.\n   * @throws Throws if an element matching the given selector doesn't appear.\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async waitForSelector<Selector extends string>(\n    selector: Selector,\n    options: WaitForSelectorOptions = {}\n  ): Promise<ElementHandle<NodeFor<Selector>> | null> {\n    const {updatedSelector, QueryHandler, polling} =\n      getQueryHandlerAndSelector(selector);\n    return (await QueryHandler.waitFor(this, updatedSelector, {\n      polling,\n      ...options,\n    })) as ElementHandle<NodeFor<Selector>> | null;\n  }\n\n  async #checkVisibility(visibility: boolean): Promise<boolean> {\n    return await this.evaluate(\n      async (element, PuppeteerUtil, visibility) => {\n        return Boolean(PuppeteerUtil.checkVisibility(element, visibility));\n      },\n      LazyArg.create(context => {\n        return context.puppeteerUtil;\n      }),\n      visibility\n    );\n  }\n\n  /**\n   * An element is considered to be visible if all of the following is\n   * true:\n   *\n   * - the element has\n   *   {@link https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle | computed styles}.\n   *\n   * - the element has a non-empty\n   *   {@link https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect | bounding client rect}.\n   *\n   * - the element's {@link https://developer.mozilla.org/en-US/docs/Web/CSS/visibility | visibility}\n   *   is not `hidden` or `collapse`.\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async isVisible(): Promise<boolean> {\n    return await this.#checkVisibility(true);\n  }\n\n  /**\n   * An element is considered to be hidden if at least one of the following is true:\n   *\n   * - the element has no\n   *   {@link https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle | computed styles}.\n   *\n   * - the element has an empty\n   *   {@link https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect | bounding client rect}.\n   *\n   * - the element's {@link https://developer.mozilla.org/en-US/docs/Web/CSS/visibility | visibility}\n   *   is `hidden` or `collapse`.\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async isHidden(): Promise<boolean> {\n    return await this.#checkVisibility(false);\n  }\n\n  /**\n   * Converts the current handle to the given element type.\n   *\n   * @example\n   *\n   * ```ts\n   * const element: ElementHandle<Element> = await page.$(\n   *   '.class-name-of-anchor'\n   * );\n   * // DO NOT DISPOSE `element`, this will be always be the same handle.\n   * const anchor: ElementHandle<HTMLAnchorElement> =\n   *   await element.toElement('a');\n   * ```\n   *\n   * @param tagName - The tag name of the desired element type.\n   * @throws An error if the handle does not match. **The handle will not be\n   * automatically disposed.**\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async toElement<\n    K extends keyof HTMLElementTagNameMap | keyof SVGElementTagNameMap,\n  >(tagName: K): Promise<HandleFor<ElementFor<K>>> {\n    const isMatchingTagName = await this.evaluate((node, tagName) => {\n      return node.nodeName === tagName.toUpperCase();\n    }, tagName);\n    if (!isMatchingTagName) {\n      throw new Error(`Element is not a(n) \\`${tagName}\\` element`);\n    }\n    return this as unknown as HandleFor<ElementFor<K>>;\n  }\n\n  /**\n   * Resolves the frame associated with the element, if any. Always exists for\n   * HTMLIFrameElements.\n   */\n  abstract contentFrame(this: ElementHandle<HTMLIFrameElement>): Promise<Frame>;\n  abstract contentFrame(): Promise<Frame | null>;\n\n  /**\n   * Returns the middle point within an element unless a specific offset is provided.\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async clickablePoint(offset?: Offset): Promise<Point> {\n    const box = await this.#clickableBox();\n    if (!box) {\n      throw new Error('Node is either not clickable or not an Element');\n    }\n    if (offset !== undefined) {\n      return {\n        x: box.x + offset.x,\n        y: box.y + offset.y,\n      };\n    }\n    return {\n      x: box.x + box.width / 2,\n      y: box.y + box.height / 2,\n    };\n  }\n\n  /**\n   * This method scrolls element into view if needed, and then\n   * uses {@link Page.mouse} to hover over the center of the element.\n   * If the element is detached from DOM, the method throws an error.\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async hover(this: ElementHandle<Element>): Promise<void> {\n    await this.scrollIntoViewIfNeeded();\n    const {x, y} = await this.clickablePoint();\n    await this.frame.page().mouse.move(x, y);\n  }\n\n  /**\n   * This method scrolls element into view if needed, and then\n   * uses {@link Page.mouse} to click in the center of the element.\n   * If the element is detached from DOM, the method throws an error.\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async click(\n    this: ElementHandle<Element>,\n    options: Readonly<ClickOptions> = {}\n  ): Promise<void> {\n    await this.scrollIntoViewIfNeeded();\n    const {x, y} = await this.clickablePoint(options.offset);\n    await this.frame.page().mouse.click(x, y, options);\n  }\n\n  /**\n   * Drags an element over the given element or point.\n   *\n   * @returns DEPRECATED. When drag interception is enabled, the drag payload is\n   * returned.\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async drag(\n    this: ElementHandle<Element>,\n    target: Point | ElementHandle<Element>\n  ): Promise<Protocol.Input.DragData | void> {\n    await this.scrollIntoViewIfNeeded();\n    const page = this.frame.page();\n    if (page.isDragInterceptionEnabled()) {\n      const source = await this.clickablePoint();\n      if (target instanceof ElementHandle) {\n        target = await target.clickablePoint();\n      }\n      return await page.mouse.drag(source, target);\n    }\n    try {\n      if (!page._isDragging) {\n        page._isDragging = true;\n        await this.hover();\n        await page.mouse.down();\n      }\n      if (target instanceof ElementHandle) {\n        await target.hover();\n      } else {\n        await page.mouse.move(target.x, target.y);\n      }\n    } catch (error) {\n      page._isDragging = false;\n      throw error;\n    }\n  }\n\n  /**\n   * @deprecated Do not use. `dragenter` will automatically be performed during dragging.\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async dragEnter(\n    this: ElementHandle<Element>,\n    data: Protocol.Input.DragData = {items: [], dragOperationsMask: 1}\n  ): Promise<void> {\n    const page = this.frame.page();\n    await this.scrollIntoViewIfNeeded();\n    const target = await this.clickablePoint();\n    await page.mouse.dragEnter(target, data);\n  }\n\n  /**\n   * @deprecated Do not use. `dragover` will automatically be performed during dragging.\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async dragOver(\n    this: ElementHandle<Element>,\n    data: Protocol.Input.DragData = {items: [], dragOperationsMask: 1}\n  ): Promise<void> {\n    const page = this.frame.page();\n    await this.scrollIntoViewIfNeeded();\n    const target = await this.clickablePoint();\n    await page.mouse.dragOver(target, data);\n  }\n\n  /**\n   * Drops the given element onto the current one.\n   */\n  async drop(\n    this: ElementHandle<Element>,\n    element: ElementHandle<Element>\n  ): Promise<void>;\n\n  /**\n   * @deprecated No longer supported.\n   */\n  async drop(\n    this: ElementHandle<Element>,\n    data?: Protocol.Input.DragData\n  ): Promise<void>;\n\n  /**\n   * @internal\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async drop(\n    this: ElementHandle<Element>,\n    dataOrElement: ElementHandle<Element> | Protocol.Input.DragData = {\n      items: [],\n      dragOperationsMask: 1,\n    }\n  ): Promise<void> {\n    const page = this.frame.page();\n    if ('items' in dataOrElement) {\n      await this.scrollIntoViewIfNeeded();\n      const destination = await this.clickablePoint();\n      await page.mouse.drop(destination, dataOrElement);\n    } else {\n      // Note if the rest errors, we still want dragging off because the errors\n      // is most likely something implying the mouse is no longer dragging.\n      await dataOrElement.drag(this);\n      page._isDragging = false;\n      await page.mouse.up();\n    }\n  }\n\n  /**\n   * @deprecated Use `ElementHandle.drop` instead.\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async dragAndDrop(\n    this: ElementHandle<Element>,\n    target: ElementHandle<Node>,\n    options?: {delay: number}\n  ): Promise<void> {\n    const page = this.frame.page();\n    assert(\n      page.isDragInterceptionEnabled(),\n      'Drag Interception is not enabled!'\n    );\n    await this.scrollIntoViewIfNeeded();\n    const startPoint = await this.clickablePoint();\n    const targetPoint = await target.clickablePoint();\n    await page.mouse.dragAndDrop(startPoint, targetPoint, options);\n  }\n\n  /**\n   * Triggers a `change` and `input` event once all the provided options have been\n   * selected. If there's no `<select>` element matching `selector`, the method\n   * throws an error.\n   *\n   * @example\n   *\n   * ```ts\n   * handle.select('blue'); // single selection\n   * handle.select('red', 'green', 'blue'); // multiple selections\n   * ```\n   *\n   * @param values - Values of options to select. If the `<select>` has the\n   * `multiple` attribute, all values are considered, otherwise only the first\n   * one is taken into account.\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async select(...values: string[]): Promise<string[]> {\n    for (const value of values) {\n      assert(\n        isString(value),\n        'Values must be strings. Found value \"' +\n          value +\n          '\" of type \"' +\n          typeof value +\n          '\"'\n      );\n    }\n\n    return await this.evaluate((element, vals): string[] => {\n      const values = new Set(vals);\n      if (!(element instanceof HTMLSelectElement)) {\n        throw new Error('Element is not a <select> element.');\n      }\n\n      const selectedValues = new Set<string>();\n      if (!element.multiple) {\n        for (const option of element.options) {\n          option.selected = false;\n        }\n        for (const option of element.options) {\n          if (values.has(option.value)) {\n            option.selected = true;\n            selectedValues.add(option.value);\n            break;\n          }\n        }\n      } else {\n        for (const option of element.options) {\n          option.selected = values.has(option.value);\n          if (option.selected) {\n            selectedValues.add(option.value);\n          }\n        }\n      }\n      element.dispatchEvent(new Event('input', {bubbles: true}));\n      element.dispatchEvent(new Event('change', {bubbles: true}));\n      return [...selectedValues.values()];\n    }, values);\n  }\n\n  /**\n   * Sets the value of an\n   * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input | input element}\n   * to the given file paths.\n   *\n   * @remarks This will not validate whether the file paths exists. Also, if a\n   * path is relative, then it is resolved against the\n   * {@link https://nodejs.org/api/process.html#process_process_cwd | current working directory}.\n   * For locals script connecting to remote chrome environments, paths must be\n   * absolute.\n   */\n  abstract uploadFile(\n    this: ElementHandle<HTMLInputElement>,\n    ...paths: string[]\n  ): Promise<void>;\n\n  /**\n   * @internal\n   */\n  abstract queryAXTree(\n    name?: string,\n    role?: string\n  ): AwaitableIterable<ElementHandle<Node>>;\n\n  /**\n   * This method scrolls element into view if needed, and then uses\n   * {@link Touchscreen.tap} to tap in the center of the element.\n   * If the element is detached from DOM, the method throws an error.\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async tap(this: ElementHandle<Element>): Promise<void> {\n    await this.scrollIntoViewIfNeeded();\n    const {x, y} = await this.clickablePoint();\n    await this.frame.page().touchscreen.tap(x, y);\n  }\n\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async touchStart(this: ElementHandle<Element>): Promise<void> {\n    await this.scrollIntoViewIfNeeded();\n    const {x, y} = await this.clickablePoint();\n    await this.frame.page().touchscreen.touchStart(x, y);\n  }\n\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async touchMove(this: ElementHandle<Element>): Promise<void> {\n    await this.scrollIntoViewIfNeeded();\n    const {x, y} = await this.clickablePoint();\n    await this.frame.page().touchscreen.touchMove(x, y);\n  }\n\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async touchEnd(this: ElementHandle<Element>): Promise<void> {\n    await this.scrollIntoViewIfNeeded();\n    await this.frame.page().touchscreen.touchEnd();\n  }\n\n  /**\n   * Calls {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus | focus} on the element.\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async focus(): Promise<void> {\n    await this.evaluate(element => {\n      if (!(element instanceof HTMLElement)) {\n        throw new Error('Cannot focus non-HTMLElement');\n      }\n      return element.focus();\n    });\n  }\n\n  /**\n   * Focuses the element, and then sends a `keydown`, `keypress`/`input`, and\n   * `keyup` event for each character in the text.\n   *\n   * To press a special key, like `Control` or `ArrowDown`,\n   * use {@link ElementHandle.press}.\n   *\n   * @example\n   *\n   * ```ts\n   * await elementHandle.type('Hello'); // Types instantly\n   * await elementHandle.type('World', {delay: 100}); // Types slower, like a user\n   * ```\n   *\n   * @example\n   * An example of typing into a text field and then submitting the form:\n   *\n   * ```ts\n   * const elementHandle = await page.$('input');\n   * await elementHandle.type('some text');\n   * await elementHandle.press('Enter');\n   * ```\n   *\n   * @param options - Delay in milliseconds. Defaults to 0.\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async type(\n    text: string,\n    options?: Readonly<KeyboardTypeOptions>\n  ): Promise<void> {\n    await this.focus();\n    await this.frame.page().keyboard.type(text, options);\n  }\n\n  /**\n   * Focuses the element, and then uses {@link Keyboard.down} and {@link Keyboard.up}.\n   *\n   * @remarks\n   * If `key` is a single character and no modifier keys besides `Shift`\n   * are being held down, a `keypress`/`input` event will also be generated.\n   * The `text` option can be specified to force an input event to be generated.\n   *\n   * **NOTE** Modifier keys DO affect `elementHandle.press`. Holding down `Shift`\n   * will type the text in upper case.\n   *\n   * @param key - Name of key to press, such as `ArrowLeft`.\n   * See {@link KeyInput} for a list of all key names.\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async press(\n    key: KeyInput,\n    options?: Readonly<KeyPressOptions>\n  ): Promise<void> {\n    await this.focus();\n    await this.frame.page().keyboard.press(key, options);\n  }\n\n  async #clickableBox(): Promise<BoundingBox | null> {\n    const boxes = await this.evaluate(element => {\n      if (!(element instanceof Element)) {\n        return null;\n      }\n      return [...element.getClientRects()].map(rect => {\n        return {x: rect.x, y: rect.y, width: rect.width, height: rect.height};\n      });\n    });\n    if (!boxes?.length) {\n      return null;\n    }\n    await this.#intersectBoundingBoxesWithFrame(boxes);\n    let frame = this.frame;\n    let parentFrame: Frame | null | undefined;\n    while ((parentFrame = frame?.parentFrame())) {\n      using handle = await frame.frameElement();\n      if (!handle) {\n        throw new Error('Unsupported frame type');\n      }\n      const parentBox = await handle.evaluate(element => {\n        // Element is not visible.\n        if (element.getClientRects().length === 0) {\n          return null;\n        }\n        const rect = element.getBoundingClientRect();\n        const style = window.getComputedStyle(element);\n        return {\n          left:\n            rect.left +\n            parseInt(style.paddingLeft, 10) +\n            parseInt(style.borderLeftWidth, 10),\n          top:\n            rect.top +\n            parseInt(style.paddingTop, 10) +\n            parseInt(style.borderTopWidth, 10),\n        };\n      });\n      if (!parentBox) {\n        return null;\n      }\n      for (const box of boxes) {\n        box.x += parentBox.left;\n        box.y += parentBox.top;\n      }\n      await handle.#intersectBoundingBoxesWithFrame(boxes);\n      frame = parentFrame;\n    }\n    const box = boxes.find(box => {\n      return box.width >= 1 && box.height >= 1;\n    });\n    if (!box) {\n      return null;\n    }\n    return {\n      x: box.x,\n      y: box.y,\n      height: box.height,\n      width: box.width,\n    };\n  }\n\n  async #intersectBoundingBoxesWithFrame(boxes: BoundingBox[]) {\n    const {documentWidth, documentHeight} = await this.frame\n      .isolatedRealm()\n      .evaluate(() => {\n        return {\n          documentWidth: document.documentElement.clientWidth,\n          documentHeight: document.documentElement.clientHeight,\n        };\n      });\n    for (const box of boxes) {\n      intersectBoundingBox(box, documentWidth, documentHeight);\n    }\n  }\n\n  /**\n   * This method returns the bounding box of the element (relative to the main frame),\n   * or `null` if the element is {@link https://drafts.csswg.org/css-display-4/#box-generation | not part of the layout}\n   * (example: `display: none`).\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async boundingBox(): Promise<BoundingBox | null> {\n    const box = await this.evaluate(element => {\n      if (!(element instanceof Element)) {\n        return null;\n      }\n      // Element is not visible.\n      if (element.getClientRects().length === 0) {\n        return null;\n      }\n      const rect = element.getBoundingClientRect();\n      return {x: rect.x, y: rect.y, width: rect.width, height: rect.height};\n    });\n    if (!box) {\n      return null;\n    }\n    const offset = await this.#getTopLeftCornerOfFrame();\n    if (!offset) {\n      return null;\n    }\n    return {\n      x: box.x + offset.x,\n      y: box.y + offset.y,\n      height: box.height,\n      width: box.width,\n    };\n  }\n\n  /**\n   * This method returns boxes of the element,\n   * or `null` if the element is {@link https://drafts.csswg.org/css-display-4/#box-generation | not part of the layout}\n   * (example: `display: none`).\n   *\n   * @remarks\n   *\n   * Boxes are represented as an array of points;\n   * Each Point is an object `{x, y}`. Box points are sorted clock-wise.\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async boxModel(): Promise<BoxModel | null> {\n    const model = await this.evaluate(element => {\n      if (!(element instanceof Element)) {\n        return null;\n      }\n      // Element is not visible.\n      if (element.getClientRects().length === 0) {\n        return null;\n      }\n      const rect = element.getBoundingClientRect();\n      const style = window.getComputedStyle(element);\n      const offsets = {\n        padding: {\n          left: parseInt(style.paddingLeft, 10),\n          top: parseInt(style.paddingTop, 10),\n          right: parseInt(style.paddingRight, 10),\n          bottom: parseInt(style.paddingBottom, 10),\n        },\n        margin: {\n          left: -parseInt(style.marginLeft, 10),\n          top: -parseInt(style.marginTop, 10),\n          right: -parseInt(style.marginRight, 10),\n          bottom: -parseInt(style.marginBottom, 10),\n        },\n        border: {\n          left: parseInt(style.borderLeft, 10),\n          top: parseInt(style.borderTop, 10),\n          right: parseInt(style.borderRight, 10),\n          bottom: parseInt(style.borderBottom, 10),\n        },\n      };\n      const border: Quad = [\n        {x: rect.left, y: rect.top},\n        {x: rect.left + rect.width, y: rect.top},\n        {x: rect.left + rect.width, y: rect.top + rect.bottom},\n        {x: rect.left, y: rect.top + rect.bottom},\n      ];\n      const padding = transformQuadWithOffsets(border, offsets.border);\n      const content = transformQuadWithOffsets(padding, offsets.padding);\n      const margin = transformQuadWithOffsets(border, offsets.margin);\n      return {\n        content,\n        padding,\n        border,\n        margin,\n        width: rect.width,\n        height: rect.height,\n      };\n\n      function transformQuadWithOffsets(\n        quad: Quad,\n        offsets: {top: number; left: number; right: number; bottom: number}\n      ): Quad {\n        return [\n          {\n            x: quad[0].x + offsets.left,\n            y: quad[0].y + offsets.top,\n          },\n          {\n            x: quad[1].x - offsets.right,\n            y: quad[1].y + offsets.top,\n          },\n          {\n            x: quad[2].x - offsets.right,\n            y: quad[2].y - offsets.bottom,\n          },\n          {\n            x: quad[3].x + offsets.left,\n            y: quad[3].y - offsets.bottom,\n          },\n        ];\n      }\n    });\n    if (!model) {\n      return null;\n    }\n    const offset = await this.#getTopLeftCornerOfFrame();\n    if (!offset) {\n      return null;\n    }\n    for (const attribute of [\n      'content',\n      'padding',\n      'border',\n      'margin',\n    ] as const) {\n      for (const point of model[attribute]) {\n        point.x += offset.x;\n        point.y += offset.y;\n      }\n    }\n    return model;\n  }\n\n  async #getTopLeftCornerOfFrame() {\n    const point = {x: 0, y: 0};\n    let frame = this.frame;\n    let parentFrame: Frame | null | undefined;\n    while ((parentFrame = frame?.parentFrame())) {\n      using handle = await frame.frameElement();\n      if (!handle) {\n        throw new Error('Unsupported frame type');\n      }\n      const parentBox = await handle.evaluate(element => {\n        // Element is not visible.\n        if (element.getClientRects().length === 0) {\n          return null;\n        }\n        const rect = element.getBoundingClientRect();\n        const style = window.getComputedStyle(element);\n        return {\n          left:\n            rect.left +\n            parseInt(style.paddingLeft, 10) +\n            parseInt(style.borderLeftWidth, 10),\n          top:\n            rect.top +\n            parseInt(style.paddingTop, 10) +\n            parseInt(style.borderTopWidth, 10),\n        };\n      });\n      if (!parentBox) {\n        return null;\n      }\n      point.x += parentBox.left;\n      point.y += parentBox.top;\n      frame = parentFrame;\n    }\n    return point;\n  }\n\n  /**\n   * This method scrolls element into view if needed, and then uses\n   * {@link Page.(screenshot:2) } to take a screenshot of the element.\n   * If the element is detached from DOM, the method throws an error.\n   */\n  async screenshot(\n    options: Readonly<ScreenshotOptions> & {encoding: 'base64'}\n  ): Promise<string>;\n  async screenshot(options?: Readonly<ScreenshotOptions>): Promise<Uint8Array>;\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async screenshot(\n    this: ElementHandle<Element>,\n    options: Readonly<ElementScreenshotOptions> = {}\n  ): Promise<string | Uint8Array> {\n    const {scrollIntoView = true, clip} = options;\n\n    const page = this.frame.page();\n\n    // Only scroll the element into view if the user wants it.\n    if (scrollIntoView) {\n      await this.scrollIntoViewIfNeeded();\n    }\n    const elementClip = await this.#nonEmptyVisibleBoundingBox();\n\n    const [pageLeft, pageTop] = await this.evaluate(() => {\n      if (!window.visualViewport) {\n        throw new Error('window.visualViewport is not supported.');\n      }\n      return [\n        window.visualViewport.pageLeft,\n        window.visualViewport.pageTop,\n      ] as const;\n    });\n    elementClip.x += pageLeft;\n    elementClip.y += pageTop;\n    if (clip) {\n      elementClip.x += clip.x;\n      elementClip.y += clip.y;\n      elementClip.height = clip.height;\n      elementClip.width = clip.width;\n    }\n\n    return await page.screenshot({...options, clip: elementClip});\n  }\n\n  async #nonEmptyVisibleBoundingBox() {\n    const box = await this.boundingBox();\n    assert(box, 'Node is either not visible or not an HTMLElement');\n    assert(box.width !== 0, 'Node has 0 width.');\n    assert(box.height !== 0, 'Node has 0 height.');\n    return box;\n  }\n\n  /**\n   * @internal\n   */\n  protected async assertConnectedElement(): Promise<void> {\n    const error = await this.evaluate(async element => {\n      if (!element.isConnected) {\n        return 'Node is detached from document';\n      }\n      if (element.nodeType !== Node.ELEMENT_NODE) {\n        return 'Node is not of type HTMLElement';\n      }\n      return;\n    });\n\n    if (error) {\n      throw new Error(error);\n    }\n  }\n\n  /**\n   * @internal\n   */\n  protected async scrollIntoViewIfNeeded(\n    this: ElementHandle<Element>\n  ): Promise<void> {\n    if (\n      await this.isIntersectingViewport({\n        threshold: 1,\n      })\n    ) {\n      return;\n    }\n    await this.scrollIntoView();\n  }\n\n  /**\n   * Resolves to true if the element is visible in the current viewport. If an\n   * element is an SVG, we check if the svg owner element is in the viewport\n   * instead. See https://crbug.com/963246.\n   *\n   * @param options - Threshold for the intersection between 0 (no intersection) and 1\n   * (full intersection). Defaults to 1.\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async isIntersectingViewport(\n    this: ElementHandle<Element>,\n    options: {\n      threshold?: number;\n    } = {}\n  ): Promise<boolean> {\n    await this.assertConnectedElement();\n    // eslint-disable-next-line rulesdir/use-using -- Returns `this`.\n    const handle = await this.#asSVGElementHandle();\n    using target = handle && (await handle.#getOwnerSVGElement());\n    return await ((target ?? this) as ElementHandle<Element>).evaluate(\n      async (element, threshold) => {\n        const visibleRatio = await new Promise<number>(resolve => {\n          const observer = new IntersectionObserver(entries => {\n            resolve(entries[0]!.intersectionRatio);\n            observer.disconnect();\n          });\n          observer.observe(element);\n        });\n        return threshold === 1 ? visibleRatio === 1 : visibleRatio > threshold;\n      },\n      options.threshold ?? 0\n    );\n  }\n\n  /**\n   * Scrolls the element into view using either the automation protocol client\n   * or by calling element.scrollIntoView.\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async scrollIntoView(this: ElementHandle<Element>): Promise<void> {\n    await this.assertConnectedElement();\n    await this.evaluate(async (element): Promise<void> => {\n      element.scrollIntoView({\n        block: 'center',\n        inline: 'center',\n        behavior: 'instant',\n      });\n    });\n  }\n\n  /**\n   * Returns true if an element is an SVGElement (included svg, path, rect\n   * etc.).\n   */\n  async #asSVGElementHandle(\n    this: ElementHandle<Element>\n  ): Promise<ElementHandle<SVGElement> | null> {\n    if (\n      await this.evaluate(element => {\n        return element instanceof SVGElement;\n      })\n    ) {\n      return this as ElementHandle<SVGElement>;\n    } else {\n      return null;\n    }\n  }\n\n  async #getOwnerSVGElement(\n    this: ElementHandle<SVGElement>\n  ): Promise<ElementHandle<SVGSVGElement>> {\n    // SVGSVGElement.ownerSVGElement === null.\n    return await this.evaluateHandle(element => {\n      if (element instanceof SVGSVGElement) {\n        return element;\n      }\n      return element.ownerSVGElement!;\n    });\n  }\n\n  /**\n   * If the element is a form input, you can use {@link ElementHandle.autofill}\n   * to test if the form is compatible with the browser's autofill\n   * implementation. Throws an error if the form cannot be autofilled.\n   *\n   * @remarks\n   *\n   * Currently, Puppeteer supports auto-filling credit card information only and\n   * in Chrome in the new headless and headful modes only.\n   *\n   * ```ts\n   * // Select an input on the credit card form.\n   * const name = await page.waitForSelector('form #name');\n   * // Trigger autofill with the desired data.\n   * await name.autofill({\n   *   creditCard: {\n   *     number: '4444444444444444',\n   *     name: 'John Smith',\n   *     expiryMonth: '01',\n   *     expiryYear: '2030',\n   *     cvc: '123',\n   *   },\n   * });\n   * ```\n   */\n  abstract autofill(data: AutofillData): Promise<void>;\n}\n\n/**\n * @public\n */\nexport interface AutofillData {\n  creditCard: {\n    // See https://chromedevtools.github.io/devtools-protocol/tot/Autofill/#type-CreditCard.\n    number: string;\n    name: string;\n    expiryMonth: string;\n    expiryYear: string;\n    cvc: string;\n  };\n}\n\nfunction intersectBoundingBox(\n  box: BoundingBox,\n  width: number,\n  height: number\n): void {\n  box.width = Math.max(\n    box.x >= 0\n      ? Math.min(width - box.x, box.width)\n      : Math.min(width, box.width + box.x),\n    0\n  );\n  box.height = Math.max(\n    box.y >= 0\n      ? Math.min(height - box.y, box.height)\n      : Math.min(height, box.height + box.y),\n    0\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}