{"ast":null,"code":"/**\n * @license\n * Copyright 2017 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\nvar __runInitializers = this && this.__runInitializers || function (thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\nvar __esDecorate = this && this.__esDecorate || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) {\n    if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\");\n    return f;\n  }\n  var kind = contextIn.kind,\n    key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _,\n    done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n    var context = {};\n    for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n    for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n    context.addInitializer = function (f) {\n      if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\");\n      extraInitializers.push(accept(f || null));\n    };\n    var result = (0, decorators[i])(kind === \"accessor\" ? {\n      get: descriptor.get,\n      set: descriptor.set\n    } : descriptor[key], context);\n    if (kind === \"accessor\") {\n      if (result === void 0) continue;\n      if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n      if (_ = accept(result.get)) descriptor.get = _;\n      if (_ = accept(result.set)) descriptor.set = _;\n      if (_ = accept(result.init)) initializers.unshift(_);\n    } else if (_ = accept(result)) {\n      if (kind === \"field\") initializers.unshift(_);else descriptor[key] = _;\n    }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\nvar __addDisposableResource = this && this.__addDisposableResource || function (env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose;\n    if (async) {\n      if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n      dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n      if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n      dispose = value[Symbol.dispose];\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    env.stack.push({\n      value: value,\n      dispose: dispose,\n      async: async\n    });\n  } else if (async) {\n    env.stack.push({\n      async: true\n    });\n  }\n  return value;\n};\nvar __disposeResources = this && this.__disposeResources || function (SuppressedError) {\n  return function (env) {\n    function fail(e) {\n      env.error = env.hasError ? new SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n      env.hasError = true;\n    }\n    function next() {\n      while (env.stack.length) {\n        var rec = env.stack.pop();\n        try {\n          var result = rec.dispose && rec.dispose.call(rec.value);\n          if (rec.async) return Promise.resolve(result).then(next, function (e) {\n            fail(e);\n            return next();\n          });\n        } catch (e) {\n          fail(e);\n        }\n      }\n      if (env.hasError) throw env.error;\n    }\n    return next();\n  };\n}(typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n});\nimport { concat, EMPTY, filter, first, firstValueFrom, from, map, merge, mergeMap, mergeScan, of, raceWith, ReplaySubject, startWith, switchMap, take, takeUntil, timer } from '../../third_party/rxjs/rxjs.js';\nimport { TargetCloseError } from '../common/Errors.js';\nimport { EventEmitter } from '../common/EventEmitter.js';\nimport { TimeoutSettings } from '../common/TimeoutSettings.js';\nimport { debugError, fromEmitterEvent, filterAsync, isString, NETWORK_IDLE_TIME, timeout, withSourcePuppeteerURLIfNone, fromAbortSignal } from '../common/util.js';\nimport { environment } from '../environment.js';\nimport { guarded } from '../util/decorators.js';\nimport { AsyncDisposableStack, asyncDisposeSymbol, DisposableStack, disposeSymbol } from '../util/disposable.js';\nimport { stringToTypedArray } from '../util/encoding.js';\nimport { FunctionLocator, Locator, NodeLocator } from './locators/locators.js';\n/**\n * @internal\n */\nexport function setDefaultScreenshotOptions(options) {\n  options.optimizeForSpeed ??= false;\n  options.type ??= 'png';\n  options.fromSurface ??= true;\n  options.fullPage ??= false;\n  options.omitBackground ??= false;\n  options.encoding ??= 'binary';\n  options.captureBeyondViewport ??= true;\n}\n/**\n * Page provides methods to interact with a single tab or\n * {@link https://developer.chrome.com/extensions/background_pages | extension background page}\n * in the browser.\n *\n * :::note\n *\n * One Browser instance might have multiple Page instances.\n *\n * :::\n *\n * @example\n * This example creates a page, navigates it to a URL, and then saves a screenshot:\n *\n * ```ts\n * import puppeteer from 'puppeteer';\n *\n * (async () => {\n *   const browser = await puppeteer.launch();\n *   const page = await browser.newPage();\n *   await page.goto('https://example.com');\n *   await page.screenshot({path: 'screenshot.png'});\n *   await browser.close();\n * })();\n * ```\n *\n * The Page class extends from Puppeteer's {@link EventEmitter} class and will\n * emit various events which are documented in the {@link PageEvent} enum.\n *\n * @example\n * This example logs a message for a single page `load` event:\n *\n * ```ts\n * page.once('load', () => console.log('Page loaded!'));\n * ```\n *\n * To unsubscribe from events use the {@link EventEmitter.off} method:\n *\n * ```ts\n * function logRequest(interceptedRequest) {\n *   console.log('A request was made:', interceptedRequest.url());\n * }\n * page.on('request', logRequest);\n * // Sometime later...\n * page.off('request', logRequest);\n * ```\n *\n * @public\n */\nlet Page = (() => {\n  let _classSuper = EventEmitter;\n  let _instanceExtraInitializers = [];\n  let _screenshot_decorators;\n  return class Page extends _classSuper {\n    static {\n      const _metadata = typeof Symbol === \"function\" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;\n      __esDecorate(this, null, _screenshot_decorators, {\n        kind: \"method\",\n        name: \"screenshot\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"screenshot\" in obj,\n          get: obj => obj.screenshot\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      if (_metadata) Object.defineProperty(this, Symbol.metadata, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value: _metadata\n      });\n    }\n    /**\n     * @internal\n     */\n    _isDragging = (__runInitializers(this, _instanceExtraInitializers), false);\n    /**\n     * @internal\n     */\n    _timeoutSettings = new TimeoutSettings();\n    #requestHandlers = new WeakMap();\n    #inflight$ = new ReplaySubject(1);\n    /**\n     * @internal\n     */\n    constructor() {\n      super();\n      fromEmitterEvent(this, \"request\" /* PageEvent.Request */).pipe(mergeMap(originalRequest => {\n        return concat(of(1), merge(fromEmitterEvent(this, \"requestfailed\" /* PageEvent.RequestFailed */), fromEmitterEvent(this, \"requestfinished\" /* PageEvent.RequestFinished */), fromEmitterEvent(this, \"response\" /* PageEvent.Response */).pipe(map(response => {\n          return response.request();\n        }))).pipe(filter(request => {\n          return request.id === originalRequest.id;\n        }), take(1), map(() => {\n          return -1;\n        })));\n      }), mergeScan((acc, addend) => {\n        return of(acc + addend);\n      }, 0), takeUntil(fromEmitterEvent(this, \"close\" /* PageEvent.Close */)), startWith(0)).subscribe(this.#inflight$);\n    }\n    /**\n     * Listen to page events.\n     *\n     * @remarks\n     * This method exists to define event typings and handle proper wireup of\n     * cooperative request interception. Actual event listening and dispatching is\n     * delegated to {@link EventEmitter}.\n     *\n     * @internal\n     */\n    on(type, handler) {\n      if (type !== \"request\" /* PageEvent.Request */) {\n        return super.on(type, handler);\n      }\n      let wrapper = this.#requestHandlers.get(handler);\n      if (wrapper === undefined) {\n        wrapper = event => {\n          event.enqueueInterceptAction(() => {\n            return handler(event);\n          });\n        };\n        this.#requestHandlers.set(handler, wrapper);\n      }\n      return super.on(type, wrapper);\n    }\n    /**\n     * @internal\n     */\n    off(type, handler) {\n      if (type === \"request\" /* PageEvent.Request */) {\n        handler = this.#requestHandlers.get(handler) || handler;\n      }\n      return super.off(type, handler);\n    }\n    /**\n     * {@inheritDoc Accessibility}\n     */\n    get accessibility() {\n      return this.mainFrame().accessibility;\n    }\n    locator(selectorOrFunc) {\n      if (typeof selectorOrFunc === 'string') {\n        return NodeLocator.create(this, selectorOrFunc);\n      } else {\n        return FunctionLocator.create(this, selectorOrFunc);\n      }\n    }\n    /**\n     * A shortcut for {@link Locator.race} that does not require static imports.\n     *\n     * @internal\n     */\n    locatorRace(locators) {\n      return Locator.race(locators);\n    }\n    /**\n     * Finds the first element that matches the selector. If no element matches\n     * the selector, the return value resolves to `null`.\n     *\n     * @param selector -\n     * {@link https://pptr.dev/guides/page-interactions#selectors | selector}\n     * to query the page for.\n     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}\n     * can be passed as-is and a\n     * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}\n     * allows quering by\n     * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},\n     * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},\n     * and\n     * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}\n     * and\n     * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.\n     * Alternatively, you can specify the selector type using a\n     * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.\n     *\n     * @remarks\n     *\n     * Shortcut for {@link Frame.$ | Page.mainFrame().$(selector) }.\n     */\n    async $(selector) {\n      return await this.mainFrame().$(selector);\n    }\n    /**\n     * Finds elements on the page that match the selector. If no elements\n     * match the selector, the return value resolves to `[]`.\n     *\n     * @param selector -\n     * {@link https://pptr.dev/guides/page-interactions#selectors | selector}\n     * to query the page for.\n     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}\n     * can be passed as-is and a\n     * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}\n     * allows quering by\n     * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},\n     * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},\n     * and\n     * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}\n     * and\n     * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.\n     * Alternatively, you can specify the selector type using a\n     * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.\n     *\n     * @remarks\n     *\n     * Shortcut for {@link Frame.$$ | Page.mainFrame().$$(selector) }.\n     */\n    async $$(selector, options) {\n      return await this.mainFrame().$$(selector, options);\n    }\n    /**\n     * @remarks\n     *\n     * The only difference between {@link Page.evaluate | page.evaluate} and\n     * `page.evaluateHandle` is that `evaluateHandle` will return the value\n     * wrapped in an in-page object.\n     *\n     * If the function passed to `page.evaluateHandle` returns a Promise, the\n     * function will wait for the promise to resolve and return its value.\n     *\n     * You can pass a string instead of a function (although functions are\n     * recommended as they are easier to debug and use with TypeScript):\n     *\n     * @example\n     *\n     * ```ts\n     * const aHandle = await page.evaluateHandle('document');\n     * ```\n     *\n     * @example\n     * {@link JSHandle} instances can be passed as arguments to the `pageFunction`:\n     *\n     * ```ts\n     * const aHandle = await page.evaluateHandle(() => document.body);\n     * const resultHandle = await page.evaluateHandle(\n     *   body => body.innerHTML,\n     *   aHandle\n     * );\n     * console.log(await resultHandle.jsonValue());\n     * await resultHandle.dispose();\n     * ```\n     *\n     * Most of the time this function returns a {@link JSHandle},\n     * but if `pageFunction` returns a reference to an element,\n     * you instead get an {@link ElementHandle} back:\n     *\n     * @example\n     *\n     * ```ts\n     * const button = await page.evaluateHandle(() =>\n     *   document.querySelector('button')\n     * );\n     * // can call `click` because `button` is an `ElementHandle`\n     * await button.click();\n     * ```\n     *\n     * The TypeScript definitions assume that `evaluateHandle` returns\n     * a `JSHandle`, but if you know it's going to return an\n     * `ElementHandle`, pass it as the generic argument:\n     *\n     * ```ts\n     * const button = await page.evaluateHandle<ElementHandle>(...);\n     * ```\n     *\n     * @param pageFunction - a function that is run within the page\n     * @param args - arguments to be passed to the pageFunction\n     */\n    async evaluateHandle(pageFunction, ...args) {\n      pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);\n      return await this.mainFrame().evaluateHandle(pageFunction, ...args);\n    }\n    /**\n     * This method finds the first element within the page that matches the selector\n     * and passes the result as the first argument to the `pageFunction`.\n     *\n     * @remarks\n     *\n     * If no element is found matching `selector`, the method will throw an error.\n     *\n     * If `pageFunction` returns a promise `$eval` will wait for the promise to\n     * resolve and then return its value.\n     *\n     * @example\n     *\n     * ```ts\n     * const searchValue = await page.$eval('#search', el => el.value);\n     * const preloadHref = await page.$eval('link[rel=preload]', el => el.href);\n     * const html = await page.$eval('.main-container', el => el.outerHTML);\n     * ```\n     *\n     * If you are using TypeScript, you may have to provide an explicit type to the\n     * first argument of the `pageFunction`.\n     * By default it is typed as `Element`, but you may need to provide a more\n     * specific sub-type:\n     *\n     * @example\n     *\n     * ```ts\n     * // if you don't provide HTMLInputElement here, TS will error\n     * // as `value` is not on `Element`\n     * const searchValue = await page.$eval(\n     *   '#search',\n     *   (el: HTMLInputElement) => el.value\n     * );\n     * ```\n     *\n     * The compiler should be able to infer the return type\n     * from the `pageFunction` you provide. If it is unable to, you can use the generic\n     * type to tell the compiler what return type you expect from `$eval`:\n     *\n     * @example\n     *\n     * ```ts\n     * // The compiler can infer the return type in this case, but if it can't\n     * // or if you want to be more explicit, provide it as the generic type.\n     * const searchValue = await page.$eval<string>(\n     *   '#search',\n     *   (el: HTMLInputElement) => el.value\n     * );\n     * ```\n     *\n     * @param selector -\n     * {@link https://pptr.dev/guides/page-interactions#selectors | selector}\n     * to query the page for.\n     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}\n     * can be passed as-is and a\n     * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}\n     * allows quering by\n     * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},\n     * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},\n     * and\n     * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}\n     * and\n     * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.\n     * Alternatively, you can specify the selector type using a\n     * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.\n     * @param pageFunction - the function to be evaluated in the page context.\n     * Will be passed the result of the element matching the selector as its\n     * first argument.\n     * @param args - any additional arguments to pass through to `pageFunction`.\n     *\n     * @returns The result of calling `pageFunction`. If it returns an element it\n     * is wrapped in an {@link ElementHandle}, else the raw value itself is\n     * returned.\n     */\n    async $eval(selector, pageFunction, ...args) {\n      pageFunction = withSourcePuppeteerURLIfNone(this.$eval.name, pageFunction);\n      return await this.mainFrame().$eval(selector, pageFunction, ...args);\n    }\n    /**\n     * This method returns all elements matching the selector and passes the\n     * resulting array as the first argument to the `pageFunction`.\n     *\n     * @remarks\n     * If `pageFunction` returns a promise `$$eval` will wait for the promise to\n     * resolve and then return its value.\n     *\n     * @example\n     *\n     * ```ts\n     * // get the amount of divs on the page\n     * const divCount = await page.$$eval('div', divs => divs.length);\n     *\n     * // get the text content of all the `.options` elements:\n     * const options = await page.$$eval('div > span.options', options => {\n     *   return options.map(option => option.textContent);\n     * });\n     * ```\n     *\n     * If you are using TypeScript, you may have to provide an explicit type to the\n     * first argument of the `pageFunction`.\n     * By default it is typed as `Element[]`, but you may need to provide a more\n     * specific sub-type:\n     *\n     * @example\n     *\n     * ```ts\n     * await page.$$eval('input', elements => {\n     *   return elements.map(e => e.value);\n     * });\n     * ```\n     *\n     * The compiler should be able to infer the return type\n     * from the `pageFunction` you provide. If it is unable to, you can use the generic\n     * type to tell the compiler what return type you expect from `$$eval`:\n     *\n     * @example\n     *\n     * ```ts\n     * const allInputValues = await page.$$eval('input', elements =>\n     *   elements.map(e => e.textContent)\n     * );\n     * ```\n     *\n     * @param selector -\n     * {@link https://pptr.dev/guides/page-interactions#selectors | selector}\n     * to query the page for.\n     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}\n     * can be passed as-is and a\n     * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}\n     * allows quering by\n     * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},\n     * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},\n     * and\n     * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}\n     * and\n     * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.\n     * Alternatively, you can specify the selector type using a\n     * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.\n     * @param pageFunction - the function to be evaluated in the page context.\n     * Will be passed an array of matching elements as its first argument.\n     * @param args - any additional arguments to pass through to `pageFunction`.\n     *\n     * @returns The result of calling `pageFunction`. If it returns an element it\n     * is wrapped in an {@link ElementHandle}, else the raw value itself is\n     * returned.\n     */\n    async $$eval(selector, pageFunction, ...args) {\n      pageFunction = withSourcePuppeteerURLIfNone(this.$$eval.name, pageFunction);\n      return await this.mainFrame().$$eval(selector, pageFunction, ...args);\n    }\n    /**\n     * Adds a `<script>` tag into the page with the desired URL or content.\n     *\n     * @remarks\n     * Shortcut for\n     * {@link Frame.addScriptTag | page.mainFrame().addScriptTag(options)}.\n     *\n     * @param options - Options for the script.\n     * @returns An {@link ElementHandle | element handle} to the injected\n     * `<script>` element.\n     */\n    async addScriptTag(options) {\n      return await this.mainFrame().addScriptTag(options);\n    }\n    async addStyleTag(options) {\n      return await this.mainFrame().addStyleTag(options);\n    }\n    /**\n     * The page's URL.\n     *\n     * @remarks\n     *\n     * Shortcut for {@link Frame.url | page.mainFrame().url()}.\n     */\n    url() {\n      return this.mainFrame().url();\n    }\n    /**\n     * The full HTML contents of the page, including the DOCTYPE.\n     */\n    async content() {\n      return await this.mainFrame().content();\n    }\n    /**\n     * Set the content of the page.\n     *\n     * @param html - HTML markup to assign to the page.\n     * @param options - Parameters that has some properties.\n     */\n    async setContent(html, options) {\n      await this.mainFrame().setContent(html, options);\n    }\n    /**\n     * {@inheritDoc Frame.goto}\n     */\n    async goto(url, options) {\n      return await this.mainFrame().goto(url, options);\n    }\n    /**\n     * Waits for the page to navigate to a new URL or to reload. It is useful when\n     * you run code that will indirectly cause the page to navigate.\n     *\n     * @example\n     *\n     * ```ts\n     * const [response] = await Promise.all([\n     *   page.waitForNavigation(), // The promise resolves after navigation has finished\n     *   page.click('a.my-link'), // Clicking the link will indirectly cause a navigation\n     * ]);\n     * ```\n     *\n     * @remarks\n     *\n     * Usage of the\n     * {@link https://developer.mozilla.org/en-US/docs/Web/API/History_API | History API}\n     * to change the URL is considered a navigation.\n     *\n     * @param options - Navigation parameters which might have the following\n     * properties:\n     * @returns A `Promise` which resolves to the main resource response.\n     *\n     * - In case of multiple redirects, the navigation will resolve with the\n     *   response of the last redirect.\n     * - In case of navigation to a different anchor or navigation due to History\n     *   API usage, the navigation will resolve with `null`.\n     */\n    async waitForNavigation(options = {}) {\n      return await this.mainFrame().waitForNavigation(options);\n    }\n    /**\n     * @param urlOrPredicate - A URL or predicate to wait for\n     * @param options - Optional waiting parameters\n     * @returns Promise which resolves to the matched request\n     * @example\n     *\n     * ```ts\n     * const firstRequest = await page.waitForRequest(\n     *   'https://example.com/resource'\n     * );\n     * const finalRequest = await page.waitForRequest(\n     *   request => request.url() === 'https://example.com'\n     * );\n     * return finalRequest.response()?.ok();\n     * ```\n     *\n     * @remarks\n     * Optional Waiting Parameters have:\n     *\n     * - `timeout`: Maximum wait time in milliseconds, defaults to `30` seconds, pass\n     *   `0` to disable the timeout. The default value can be changed by using the\n     *   {@link Page.setDefaultTimeout} method.\n     */\n    waitForRequest(urlOrPredicate, options = {}) {\n      const {\n        timeout: ms = this._timeoutSettings.timeout(),\n        signal\n      } = options;\n      if (typeof urlOrPredicate === 'string') {\n        const url = urlOrPredicate;\n        urlOrPredicate = request => {\n          return request.url() === url;\n        };\n      }\n      const observable$ = fromEmitterEvent(this, \"request\" /* PageEvent.Request */).pipe(filterAsync(urlOrPredicate), raceWith(timeout(ms), fromAbortSignal(signal), fromEmitterEvent(this, \"close\" /* PageEvent.Close */).pipe(map(() => {\n        throw new TargetCloseError('Page closed!');\n      }))));\n      return firstValueFrom(observable$);\n    }\n    /**\n     * @param urlOrPredicate - A URL or predicate to wait for.\n     * @param options - Optional waiting parameters\n     * @returns Promise which resolves to the matched response.\n     * @example\n     *\n     * ```ts\n     * const firstResponse = await page.waitForResponse(\n     *   'https://example.com/resource'\n     * );\n     * const finalResponse = await page.waitForResponse(\n     *   response =>\n     *     response.url() === 'https://example.com' && response.status() === 200\n     * );\n     * const finalResponse = await page.waitForResponse(async response => {\n     *   return (await response.text()).includes('<html>');\n     * });\n     * return finalResponse.ok();\n     * ```\n     *\n     * @remarks\n     * Optional Parameter have:\n     *\n     * - `timeout`: Maximum wait time in milliseconds, defaults to `30` seconds,\n     *   pass `0` to disable the timeout. The default value can be changed by using\n     *   the {@link Page.setDefaultTimeout} method.\n     */\n    waitForResponse(urlOrPredicate, options = {}) {\n      const {\n        timeout: ms = this._timeoutSettings.timeout(),\n        signal\n      } = options;\n      if (typeof urlOrPredicate === 'string') {\n        const url = urlOrPredicate;\n        urlOrPredicate = response => {\n          return response.url() === url;\n        };\n      }\n      const observable$ = fromEmitterEvent(this, \"response\" /* PageEvent.Response */).pipe(filterAsync(urlOrPredicate), raceWith(timeout(ms), fromAbortSignal(signal), fromEmitterEvent(this, \"close\" /* PageEvent.Close */).pipe(map(() => {\n        throw new TargetCloseError('Page closed!');\n      }))));\n      return firstValueFrom(observable$);\n    }\n    /**\n     * Waits for the network to be idle.\n     *\n     * @param options - Options to configure waiting behavior.\n     * @returns A promise which resolves once the network is idle.\n     */\n    waitForNetworkIdle(options = {}) {\n      return firstValueFrom(this.waitForNetworkIdle$(options));\n    }\n    /**\n     * @internal\n     */\n    waitForNetworkIdle$(options = {}) {\n      const {\n        timeout: ms = this._timeoutSettings.timeout(),\n        idleTime = NETWORK_IDLE_TIME,\n        concurrency = 0,\n        signal\n      } = options;\n      return this.#inflight$.pipe(switchMap(inflight => {\n        if (inflight > concurrency) {\n          return EMPTY;\n        }\n        return timer(idleTime);\n      }), map(() => {}), raceWith(timeout(ms), fromAbortSignal(signal), fromEmitterEvent(this, \"close\" /* PageEvent.Close */).pipe(map(() => {\n        throw new TargetCloseError('Page closed!');\n      }))));\n    }\n    /**\n     * Waits for a frame matching the given conditions to appear.\n     *\n     * @example\n     *\n     * ```ts\n     * const frame = await page.waitForFrame(async frame => {\n     *   return frame.name() === 'Test';\n     * });\n     * ```\n     */\n    async waitForFrame(urlOrPredicate, options = {}) {\n      const {\n        timeout: ms = this.getDefaultTimeout(),\n        signal\n      } = options;\n      const predicate = isString(urlOrPredicate) ? frame => {\n        return urlOrPredicate === frame.url();\n      } : urlOrPredicate;\n      return await firstValueFrom(merge(fromEmitterEvent(this, \"frameattached\" /* PageEvent.FrameAttached */), fromEmitterEvent(this, \"framenavigated\" /* PageEvent.FrameNavigated */), from(this.frames())).pipe(filterAsync(predicate), first(), raceWith(timeout(ms), fromAbortSignal(signal), fromEmitterEvent(this, \"close\" /* PageEvent.Close */).pipe(map(() => {\n        throw new TargetCloseError('Page closed.');\n      })))));\n    }\n    /**\n     * Emulates a given device's metrics and user agent.\n     *\n     * To aid emulation, Puppeteer provides a list of known devices that can be\n     * via {@link KnownDevices}.\n     *\n     * @remarks\n     * This method is a shortcut for calling two methods:\n     * {@link Page.setUserAgent} and {@link Page.setViewport}.\n     *\n     * This method will resize the page. A lot of websites don't expect phones to\n     * change size, so you should emulate before navigating to the page.\n     *\n     * @example\n     *\n     * ```ts\n     * import {KnownDevices} from 'puppeteer';\n     * const iPhone = KnownDevices['iPhone 15 Pro'];\n     *\n     * (async () => {\n     *   const browser = await puppeteer.launch();\n     *   const page = await browser.newPage();\n     *   await page.emulate(iPhone);\n     *   await page.goto('https://www.google.com');\n     *   // other actions...\n     *   await browser.close();\n     * })();\n     * ```\n     */\n    async emulate(device) {\n      await Promise.all([this.setUserAgent(device.userAgent), this.setViewport(device.viewport)]);\n    }\n    /**\n     * Evaluates a function in the page's context and returns the result.\n     *\n     * If the function passed to `page.evaluate` returns a Promise, the\n     * function will wait for the promise to resolve and return its value.\n     *\n     * @example\n     *\n     * ```ts\n     * const result = await frame.evaluate(() => {\n     *   return Promise.resolve(8 * 7);\n     * });\n     * console.log(result); // prints \"56\"\n     * ```\n     *\n     * You can pass a string instead of a function (although functions are\n     * recommended as they are easier to debug and use with TypeScript):\n     *\n     * @example\n     *\n     * ```ts\n     * const aHandle = await page.evaluate('1 + 2');\n     * ```\n     *\n     * To get the best TypeScript experience, you should pass in as the\n     * generic the type of `pageFunction`:\n     *\n     * ```ts\n     * const aHandle = await page.evaluate(() => 2);\n     * ```\n     *\n     * @example\n     *\n     * {@link ElementHandle} instances (including {@link JSHandle}s) can be passed\n     * as arguments to the `pageFunction`:\n     *\n     * ```ts\n     * const bodyHandle = await page.$('body');\n     * const html = await page.evaluate(body => body.innerHTML, bodyHandle);\n     * await bodyHandle.dispose();\n     * ```\n     *\n     * @param pageFunction - a function that is run within the page\n     * @param args - arguments to be passed to the pageFunction\n     *\n     * @returns the return value of `pageFunction`.\n     */\n    async evaluate(pageFunction, ...args) {\n      pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);\n      return await this.mainFrame().evaluate(pageFunction, ...args);\n    }\n    /**\n     * @internal\n     */\n    async _maybeWriteTypedArrayToFile(path, typedArray) {\n      if (!path) {\n        return;\n      }\n      await environment.value.fs.promises.writeFile(path, typedArray);\n    }\n    /**\n     * Captures a screencast of this {@link Page | page}.\n     *\n     * @example\n     * Recording a {@link Page | page}:\n     *\n     * ```\n     * import puppeteer from 'puppeteer';\n     *\n     * // Launch a browser\n     * const browser = await puppeteer.launch();\n     *\n     * // Create a new page\n     * const page = await browser.newPage();\n     *\n     * // Go to your site.\n     * await page.goto(\"https://www.example.com\");\n     *\n     * // Start recording.\n     * const recorder = await page.screencast({path: 'recording.webm'});\n     *\n     * // Do something.\n     *\n     * // Stop recording.\n     * await recorder.stop();\n     *\n     * browser.close();\n     * ```\n     *\n     * @param options - Configures screencast behavior.\n     *\n     * @experimental\n     *\n     * @remarks\n     *\n     * All recordings will be {@link https://www.webmproject.org/ | WebM} format using\n     * the {@link https://www.webmproject.org/vp9/ | VP9} video codec. The FPS is 30.\n     *\n     * You must have {@link https://ffmpeg.org/ | ffmpeg} installed on your system.\n     */\n    async screencast(options = {}) {\n      const ScreenRecorder = environment.value.ScreenRecorder;\n      const [width, height, devicePixelRatio] = await this.#getNativePixelDimensions();\n      let crop;\n      if (options.crop) {\n        const {\n          x,\n          y,\n          width: cropWidth,\n          height: cropHeight\n        } = roundRectangle(normalizeRectangle(options.crop));\n        if (x < 0 || y < 0) {\n          throw new Error(`\\`crop.x\\` and \\`crop.y\\` must be greater than or equal to 0.`);\n        }\n        if (cropWidth <= 0 || cropHeight <= 0) {\n          throw new Error(`\\`crop.height\\` and \\`crop.width\\` must be greater than or equal to 0.`);\n        }\n        const viewportWidth = width / devicePixelRatio;\n        const viewportHeight = height / devicePixelRatio;\n        if (x + cropWidth > viewportWidth) {\n          throw new Error(`\\`crop.width\\` cannot be larger than the viewport width (${viewportWidth}).`);\n        }\n        if (y + cropHeight > viewportHeight) {\n          throw new Error(`\\`crop.height\\` cannot be larger than the viewport height (${viewportHeight}).`);\n        }\n        crop = {\n          x: x * devicePixelRatio,\n          y: y * devicePixelRatio,\n          width: cropWidth * devicePixelRatio,\n          height: cropHeight * devicePixelRatio\n        };\n      }\n      if (options.speed !== undefined && options.speed <= 0) {\n        throw new Error(`\\`speed\\` must be greater than 0.`);\n      }\n      if (options.scale !== undefined && options.scale <= 0) {\n        throw new Error(`\\`scale\\` must be greater than 0.`);\n      }\n      const recorder = new ScreenRecorder(this, width, height, {\n        ...options,\n        path: options.ffmpegPath,\n        crop\n      });\n      try {\n        await this._startScreencast();\n      } catch (error) {\n        void recorder.stop();\n        throw error;\n      }\n      if (options.path) {\n        const {\n          createWriteStream\n        } = environment.value.fs;\n        const stream = createWriteStream(options.path, 'binary');\n        recorder.pipe(stream);\n      }\n      return recorder;\n    }\n    #screencastSessionCount = 0;\n    #startScreencastPromise;\n    /**\n     * @internal\n     */\n    async _startScreencast() {\n      ++this.#screencastSessionCount;\n      if (!this.#startScreencastPromise) {\n        this.#startScreencastPromise = this.mainFrame().client.send('Page.startScreencast', {\n          format: 'png'\n        }).then(() => {\n          // Wait for the first frame.\n          return new Promise(resolve => {\n            return this.mainFrame().client.once('Page.screencastFrame', () => {\n              return resolve();\n            });\n          });\n        });\n      }\n      await this.#startScreencastPromise;\n    }\n    /**\n     * @internal\n     */\n    async _stopScreencast() {\n      --this.#screencastSessionCount;\n      if (!this.#startScreencastPromise) {\n        return;\n      }\n      this.#startScreencastPromise = undefined;\n      if (this.#screencastSessionCount === 0) {\n        await this.mainFrame().client.send('Page.stopScreencast');\n      }\n    }\n    /**\n     * Gets the native, non-emulated dimensions of the viewport.\n     */\n    async #getNativePixelDimensions() {\n      const env_1 = {\n        stack: [],\n        error: void 0,\n        hasError: false\n      };\n      try {\n        const viewport = this.viewport();\n        const stack = __addDisposableResource(env_1, new DisposableStack(), false);\n        if (viewport && viewport.deviceScaleFactor !== 0) {\n          await this.setViewport({\n            ...viewport,\n            deviceScaleFactor: 0\n          });\n          stack.defer(() => {\n            void this.setViewport(viewport).catch(debugError);\n          });\n        }\n        return await this.mainFrame().isolatedRealm().evaluate(() => {\n          return [window.visualViewport.width * window.devicePixelRatio, window.visualViewport.height * window.devicePixelRatio, window.devicePixelRatio];\n        });\n      } catch (e_1) {\n        env_1.error = e_1;\n        env_1.hasError = true;\n      } finally {\n        __disposeResources(env_1);\n      }\n    }\n    async screenshot(userOptions = {}) {\n      const env_2 = {\n        stack: [],\n        error: void 0,\n        hasError: false\n      };\n      try {\n        const _guard = __addDisposableResource(env_2, await this.browserContext().startScreenshot(), false);\n        await this.bringToFront();\n        // TODO: use structuredClone after Node 16 support is dropped.\n        const options = {\n          ...userOptions,\n          clip: userOptions.clip ? {\n            ...userOptions.clip\n          } : undefined\n        };\n        if (options.type === undefined && options.path !== undefined) {\n          const filePath = options.path;\n          // Note we cannot use Node.js here due to browser compatibility.\n          const extension = filePath.slice(filePath.lastIndexOf('.') + 1).toLowerCase();\n          switch (extension) {\n            case 'png':\n              options.type = 'png';\n              break;\n            case 'jpeg':\n            case 'jpg':\n              options.type = 'jpeg';\n              break;\n            case 'webp':\n              options.type = 'webp';\n              break;\n          }\n        }\n        if (options.quality !== undefined) {\n          if (options.quality < 0 || options.quality > 100) {\n            throw new Error(`Expected 'quality' (${options.quality}) to be between 0 and 100, inclusive.`);\n          }\n          if (options.type === undefined || !['jpeg', 'webp'].includes(options.type)) {\n            throw new Error(`${options.type ?? 'png'} screenshots do not support 'quality'.`);\n          }\n        }\n        if (options.clip) {\n          if (options.clip.width <= 0) {\n            throw new Error(\"'width' in 'clip' must be positive.\");\n          }\n          if (options.clip.height <= 0) {\n            throw new Error(\"'height' in 'clip' must be positive.\");\n          }\n        }\n        setDefaultScreenshotOptions(options);\n        const stack = __addDisposableResource(env_2, new AsyncDisposableStack(), true);\n        if (options.clip) {\n          if (options.fullPage) {\n            throw new Error(\"'clip' and 'fullPage' are mutually exclusive\");\n          }\n          options.clip = roundRectangle(normalizeRectangle(options.clip));\n        } else {\n          if (options.fullPage) {\n            // If `captureBeyondViewport` is `false`, then we set the viewport to\n            // capture the full page. Note this may be affected by on-page CSS and\n            // JavaScript.\n            if (!options.captureBeyondViewport) {\n              const scrollDimensions = await this.mainFrame().isolatedRealm().evaluate(() => {\n                const element = document.documentElement;\n                return {\n                  width: element.scrollWidth,\n                  height: element.scrollHeight\n                };\n              });\n              const viewport = this.viewport();\n              await this.setViewport({\n                ...viewport,\n                ...scrollDimensions\n              });\n              stack.defer(async () => {\n                await this.setViewport(viewport).catch(debugError);\n              });\n            }\n          } else {\n            options.captureBeyondViewport = false;\n          }\n        }\n        const data = await this._screenshot(options);\n        if (options.encoding === 'base64') {\n          return data;\n        }\n        const typedArray = stringToTypedArray(data, true);\n        await this._maybeWriteTypedArrayToFile(options.path, typedArray);\n        return typedArray;\n      } catch (e_2) {\n        env_2.error = e_2;\n        env_2.hasError = true;\n      } finally {\n        const result_1 = __disposeResources(env_2);\n        if (result_1) await result_1;\n      }\n    }\n    /**\n     * The page's title\n     *\n     * @remarks\n     *\n     * Shortcut for {@link Frame.title | page.mainFrame().title()}.\n     */\n    async title() {\n      return await this.mainFrame().title();\n    }\n    /**\n     * This method fetches an element with `selector`, scrolls it into view if\n     * needed, and then uses {@link Page.mouse} to click in the center of the\n     * element. If there's no element matching `selector`, the method throws an\n     * error.\n     *\n     * @remarks\n     *\n     * Bear in mind that if `click()` triggers a navigation event and\n     * there's a separate `page.waitForNavigation()` promise to be resolved, you\n     * may end up with a race condition that yields unexpected results. The\n     * correct pattern for click and wait for navigation is the following:\n     *\n     * ```ts\n     * const [response] = await Promise.all([\n     *   page.waitForNavigation(waitOptions),\n     *   page.click(selector, clickOptions),\n     * ]);\n     * ```\n     *\n     * Shortcut for {@link Frame.click | page.mainFrame().click(selector[, options]) }.\n     * @param selector -\n     * {@link https://pptr.dev/guides/page-interactions#selectors | selector}\n     * to query the page for.\n     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}\n     * can be passed as-is and a\n     * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}\n     * allows quering by\n     * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},\n     * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},\n     * and\n     * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}\n     * and\n     * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.\n     * Alternatively, you can specify the selector type using a\n     * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}. If there are\n     * multiple elements satisfying the `selector`, the first will be clicked\n     * @param options - `Object`\n     * @returns Promise which resolves when the element matching `selector` is\n     * successfully clicked. The Promise will be rejected if there is no element\n     * matching `selector`.\n     */\n    click(selector, options) {\n      return this.mainFrame().click(selector, options);\n    }\n    /**\n     * This method fetches an element with `selector` and focuses it. If\n     * there's no element matching `selector`, the method throws an error.\n     * @param selector -\n     * {@link https://pptr.dev/guides/page-interactions#selectors | selector}\n     * to query the page for.\n     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}\n     * can be passed as-is and a\n     * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}\n     * allows quering by\n     * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},\n     * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},\n     * and\n     * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}\n     * and\n     * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.\n     * Alternatively, you can specify the selector type using a\n     * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.\n     * If there are multiple elements satisfying the selector, the first\n     * will be focused.\n     * @returns Promise which resolves when the element matching selector\n     * is successfully focused. The promise will be rejected if there is\n     * no element matching selector.\n     *\n     * @remarks\n     *\n     * Shortcut for\n     * {@link Frame.focus | page.mainFrame().focus(selector)}.\n     */\n    focus(selector) {\n      return this.mainFrame().focus(selector);\n    }\n    /**\n     * This method fetches an element with `selector`, scrolls it into view if\n     * needed, and then uses {@link Page.mouse}\n     * to hover over the center of the element.\n     * If there's no element matching `selector`, the method throws an error.\n     * @param selector -\n     * {@link https://pptr.dev/guides/page-interactions#selectors | selector}\n     * to query the page for.\n     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}\n     * can be passed as-is and a\n     * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}\n     * allows quering by\n     * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},\n     * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},\n     * and\n     * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}\n     * and\n     * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.\n     * Alternatively, you can specify the selector type using a\n     * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}. If there are\n     * multiple elements satisfying the `selector`, the first will be hovered.\n     * @returns Promise which resolves when the element matching `selector` is\n     * successfully hovered. Promise gets rejected if there's no element matching\n     * `selector`.\n     *\n     * @remarks\n     *\n     * Shortcut for {@link Page.hover | page.mainFrame().hover(selector)}.\n     */\n    hover(selector) {\n      return this.mainFrame().hover(selector);\n    }\n    /**\n     * Triggers a `change` and `input` event once all the provided options have been\n     * selected. If there's no `<select>` element matching `selector`, the method\n     * throws an error.\n     *\n     * @example\n     *\n     * ```ts\n     * page.select('select#colors', 'blue'); // single selection\n     * page.select('select#colors', 'red', 'green', 'blue'); // multiple selections\n     * ```\n     *\n     * @param selector -\n     * {@link https://pptr.dev/guides/page-interactions#selectors | selector}\n     * to query the page for.\n     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}\n     * can be passed as-is and a\n     * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}\n     * allows quering by\n     * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},\n     * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},\n     * and\n     * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}\n     * and\n     * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.\n     * Alternatively, you can specify the selector type using a\n     * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.\n     * @param values - Values of options to select. If the `<select>` has the\n     * `multiple` attribute, all values are considered, otherwise only the first one\n     * is taken into account.\n     * @returns\n     *\n     * @remarks\n     *\n     * Shortcut for {@link Frame.select | page.mainFrame().select()}\n     */\n    select(selector, ...values) {\n      return this.mainFrame().select(selector, ...values);\n    }\n    /**\n     * This method fetches an element with `selector`, scrolls it into view if\n     * needed, and then uses {@link Page.touchscreen}\n     * to tap in the center of the element.\n     * If there's no element matching `selector`, the method throws an error.\n     * @param selector -\n     * {@link https://pptr.dev/guides/page-interactions#selectors | selector}\n     * to query the page for.\n     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}\n     * can be passed as-is and a\n     * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}\n     * allows quering by\n     * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},\n     * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},\n     * and\n     * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}\n     * and\n     * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.\n     * Alternatively, you can specify the selector type using a\n     * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}. If there are multiple elements satisfying the\n     * selector, the first will be tapped.\n     *\n     * @remarks\n     *\n     * Shortcut for {@link Frame.tap | page.mainFrame().tap(selector)}.\n     */\n    tap(selector) {\n      return this.mainFrame().tap(selector);\n    }\n    /**\n     * Sends a `keydown`, `keypress/input`, and `keyup` event for each character\n     * in the text.\n     *\n     * To press a special key, like `Control` or `ArrowDown`, use {@link Keyboard.press}.\n     * @example\n     *\n     * ```ts\n     * await page.type('#mytextarea', 'Hello');\n     * // Types instantly\n     * await page.type('#mytextarea', 'World', {delay: 100});\n     * // Types slower, like a user\n     * ```\n     *\n     * @param selector -\n     * {@link https://pptr.dev/guides/page-interactions#selectors | selector}\n     * to query the page for.\n     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}\n     * can be passed as-is and a\n     * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}\n     * allows quering by\n     * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},\n     * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},\n     * and\n     * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}\n     * and\n     * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.\n     * Alternatively, you can specify the selector type using a\n     * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.\n     * @param text - A text to type into a focused element.\n     * @param options - have property `delay` which is the Time to wait between\n     * key presses in milliseconds. Defaults to `0`.\n     * @returns\n     */\n    type(selector, text, options) {\n      return this.mainFrame().type(selector, text, options);\n    }\n    /**\n     * Wait for the `selector` to appear in page. If at the moment of calling the\n     * method the `selector` already exists, the method will return immediately. If\n     * the `selector` doesn't appear after the `timeout` milliseconds of waiting, the\n     * function will throw.\n     *\n     * @example\n     * This method works across navigations:\n     *\n     * ```ts\n     * import puppeteer from 'puppeteer';\n     * (async () => {\n     *   const browser = await puppeteer.launch();\n     *   const page = await browser.newPage();\n     *   let currentURL;\n     *   page\n     *     .waitForSelector('img')\n     *     .then(() => console.log('First URL with image: ' + currentURL));\n     *   for (currentURL of [\n     *     'https://example.com',\n     *     'https://google.com',\n     *     'https://bbc.com',\n     *   ]) {\n     *     await page.goto(currentURL);\n     *   }\n     *   await browser.close();\n     * })();\n     * ```\n     *\n     * @param selector -\n     * {@link https://pptr.dev/guides/page-interactions#selectors | selector}\n     * to query the page for.\n     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}\n     * can be passed as-is and a\n     * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}\n     * allows quering by\n     * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},\n     * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},\n     * and\n     * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}\n     * and\n     * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.\n     * Alternatively, you can specify the selector type using a\n     * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.\n     * @param options - Optional waiting parameters\n     * @returns Promise which resolves when element specified by selector string\n     * is added to DOM. Resolves to `null` if waiting for hidden: `true` and\n     * selector is not found in DOM.\n     *\n     * @remarks\n     * The optional Parameter in Arguments `options` are:\n     *\n     * - `visible`: A boolean wait for element to be present in DOM and to be\n     *   visible, i.e. to not have `display: none` or `visibility: hidden` CSS\n     *   properties. Defaults to `false`.\n     *\n     * - `hidden`: Wait for element to not be found in the DOM or to be hidden,\n     *   i.e. have `display: none` or `visibility: hidden` CSS properties. Defaults to\n     *   `false`.\n     *\n     * - `timeout`: maximum time to wait for in milliseconds. Defaults to `30000`\n     *   (30 seconds). Pass `0` to disable timeout. The default value can be changed\n     *   by using the {@link Page.setDefaultTimeout} method.\n     */\n    async waitForSelector(selector, options = {}) {\n      return await this.mainFrame().waitForSelector(selector, options);\n    }\n    /**\n     * Waits for the provided function, `pageFunction`, to return a truthy value when\n     * evaluated in the page's context.\n     *\n     * @example\n     * {@link Page.waitForFunction} can be used to observe a viewport size change:\n     *\n     * ```ts\n     * import puppeteer from 'puppeteer';\n     * (async () => {\n     *   const browser = await puppeteer.launch();\n     *   const page = await browser.newPage();\n     *   const watchDog = page.waitForFunction('window.innerWidth < 100');\n     *   await page.setViewport({width: 50, height: 50});\n     *   await watchDog;\n     *   await browser.close();\n     * })();\n     * ```\n     *\n     * @example\n     * Arguments can be passed from Node.js to `pageFunction`:\n     *\n     * ```ts\n     * const selector = '.foo';\n     * await page.waitForFunction(\n     *   selector => !!document.querySelector(selector),\n     *   {},\n     *   selector\n     * );\n     * ```\n     *\n     * @example\n     * The provided `pageFunction` can be asynchronous:\n     *\n     * ```ts\n     * const username = 'github-username';\n     * await page.waitForFunction(\n     *   async username => {\n     *     const githubResponse = await fetch(\n     *       `https://api.github.com/users/${username}`\n     *     );\n     *     const githubUser = await githubResponse.json();\n     *     // show the avatar\n     *     const img = document.createElement('img');\n     *     img.src = githubUser.avatar_url;\n     *     // wait 3 seconds\n     *     await new Promise((resolve, reject) => setTimeout(resolve, 3000));\n     *     img.remove();\n     *   },\n     *   {},\n     *   username\n     * );\n     * ```\n     *\n     * @param pageFunction - Function to be evaluated in browser context until it returns a\n     * truthy value.\n     * @param options - Options for configuring waiting behavior.\n     */\n    waitForFunction(pageFunction, options, ...args) {\n      return this.mainFrame().waitForFunction(pageFunction, options, ...args);\n    }\n    /** @internal */\n    [(_screenshot_decorators = [guarded(function () {\n      return this.browser();\n    })], disposeSymbol)]() {\n      return void this.close().catch(debugError);\n    }\n    /** @internal */\n    [asyncDisposeSymbol]() {\n      return this.close();\n    }\n  };\n})();\nexport { Page };\n/**\n * @internal\n */\nexport const supportedMetrics = new Set(['Timestamp', 'Documents', 'Frames', 'JSEventListeners', 'Nodes', 'LayoutCount', 'RecalcStyleCount', 'LayoutDuration', 'RecalcStyleDuration', 'ScriptDuration', 'TaskDuration', 'JSHeapUsedSize', 'JSHeapTotalSize']);\n/** @see https://w3c.github.io/webdriver-bidi/#normalize-rect */\nfunction normalizeRectangle(clip) {\n  return {\n    ...clip,\n    ...(clip.width < 0 ? {\n      x: clip.x + clip.width,\n      width: -clip.width\n    } : {\n      x: clip.x,\n      width: clip.width\n    }),\n    ...(clip.height < 0 ? {\n      y: clip.y + clip.height,\n      height: -clip.height\n    } : {\n      y: clip.y,\n      height: clip.height\n    })\n  };\n}\nfunction roundRectangle(clip) {\n  const x = Math.round(clip.x);\n  const y = Math.round(clip.y);\n  const width = Math.round(clip.width + clip.x - x);\n  const height = Math.round(clip.height + clip.y - y);\n  return {\n    ...clip,\n    x,\n    y,\n    width,\n    height\n  };\n}","map":{"version":3,"names":["concat","EMPTY","filter","first","firstValueFrom","from","map","merge","mergeMap","mergeScan","of","raceWith","ReplaySubject","startWith","switchMap","take","takeUntil","timer","TargetCloseError","EventEmitter","TimeoutSettings","debugError","fromEmitterEvent","filterAsync","isString","NETWORK_IDLE_TIME","timeout","withSourcePuppeteerURLIfNone","fromAbortSignal","environment","guarded","AsyncDisposableStack","asyncDisposeSymbol","DisposableStack","disposeSymbol","stringToTypedArray","FunctionLocator","Locator","NodeLocator","setDefaultScreenshotOptions","options","optimizeForSpeed","type","fromSurface","fullPage","omitBackground","encoding","captureBeyondViewport","Page","_classSuper","__esDecorate","_screenshot_decorators","kind","name","static","private","access","has","obj","get","screenshot","metadata","_metadata","_instanceExtraInitializers","_isDragging","__runInitializers","_timeoutSettings","requestHandlers","WeakMap","inflight$","constructor","pipe","originalRequest","response","request","id","acc","addend","subscribe","on","handler","wrapper","undefined","event","enqueueInterceptAction","set","off","accessibility","mainFrame","locator","selectorOrFunc","create","locatorRace","locators","race","$","selector","$$","evaluateHandle","pageFunction","args","$eval","$$eval","addScriptTag","addStyleTag","url","content","setContent","html","goto","waitForNavigation","waitForRequest","urlOrPredicate","ms","signal","observable$","waitForResponse","waitForNetworkIdle","waitForNetworkIdle$","idleTime","concurrency","inflight","waitForFrame","getDefaultTimeout","predicate","frame","frames","emulate","device","Promise","all","setUserAgent","userAgent","setViewport","viewport","evaluate","_maybeWriteTypedArrayToFile","path","typedArray","value","fs","promises","writeFile","screencast","ScreenRecorder","width","height","devicePixelRatio","getNativePixelDimensions","crop","x","y","cropWidth","cropHeight","roundRectangle","normalizeRectangle","Error","viewportWidth","viewportHeight","speed","scale","recorder","ffmpegPath","_startScreencast","error","stop","createWriteStream","stream","screencastSessionCount","startScreencastPromise","client","send","format","then","resolve","once","_stopScreencast","#getNativePixelDimensions","stack","__addDisposableResource","env_1","deviceScaleFactor","defer","catch","isolatedRealm","window","visualViewport","userOptions","_guard","env_2","browserContext","startScreenshot","bringToFront","clip","filePath","extension","slice","lastIndexOf","toLowerCase","quality","includes","scrollDimensions","element","document","documentElement","scrollWidth","scrollHeight","data","_screenshot","title","click","focus","hover","select","values","tap","text","waitForSelector","waitForFunction","browser","close","supportedMetrics","Set","Math","round"],"sources":["C:\\Users\\raffy\\Desktop\\test\\node_modules\\puppeteer-core\\src\\api\\Page.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2017 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport type {Protocol} from 'devtools-protocol';\n\nimport {\n  concat,\n  EMPTY,\n  filter,\n  first,\n  firstValueFrom,\n  from,\n  map,\n  merge,\n  mergeMap,\n  mergeScan,\n  of,\n  raceWith,\n  ReplaySubject,\n  startWith,\n  switchMap,\n  take,\n  takeUntil,\n  timer,\n  type Observable,\n} from '../../third_party/rxjs/rxjs.js';\nimport type {HTTPRequest} from '../api/HTTPRequest.js';\nimport type {HTTPResponse} from '../api/HTTPResponse.js';\nimport type {Accessibility} from '../cdp/Accessibility.js';\nimport type {Coverage} from '../cdp/Coverage.js';\nimport type {DeviceRequestPrompt} from '../cdp/DeviceRequestPrompt.js';\nimport type {NetworkConditions} from '../cdp/NetworkManager.js';\nimport type {Tracing} from '../cdp/Tracing.js';\nimport type {ConsoleMessage} from '../common/ConsoleMessage.js';\nimport type {\n  Cookie,\n  CookieParam,\n  DeleteCookiesRequest,\n} from '../common/Cookie.js';\nimport type {Device} from '../common/Device.js';\nimport {TargetCloseError} from '../common/Errors.js';\nimport {\n  EventEmitter,\n  type EventsWithWildcard,\n  type EventType,\n  type Handler,\n} from '../common/EventEmitter.js';\nimport type {FileChooser} from '../common/FileChooser.js';\nimport type {PDFOptions} from '../common/PDFOptions.js';\nimport {TimeoutSettings} from '../common/TimeoutSettings.js';\nimport type {\n  Awaitable,\n  AwaitablePredicate,\n  EvaluateFunc,\n  EvaluateFuncWith,\n  HandleFor,\n  NodeFor,\n} from '../common/types.js';\nimport {\n  debugError,\n  fromEmitterEvent,\n  filterAsync,\n  isString,\n  NETWORK_IDLE_TIME,\n  timeout,\n  withSourcePuppeteerURLIfNone,\n  fromAbortSignal,\n} from '../common/util.js';\nimport type {Viewport} from '../common/Viewport.js';\nimport {environment} from '../environment.js';\nimport type {ScreenRecorder} from '../node/ScreenRecorder.js';\nimport {guarded} from '../util/decorators.js';\nimport {\n  AsyncDisposableStack,\n  asyncDisposeSymbol,\n  DisposableStack,\n  disposeSymbol,\n} from '../util/disposable.js';\nimport {stringToTypedArray} from '../util/encoding.js';\n\nimport type {Browser} from './Browser.js';\nimport type {BrowserContext} from './BrowserContext.js';\nimport type {CDPSession} from './CDPSession.js';\nimport type {Dialog} from './Dialog.js';\nimport type {\n  BoundingBox,\n  ClickOptions,\n  ElementHandle,\n} from './ElementHandle.js';\nimport type {\n  Frame,\n  FrameAddScriptTagOptions,\n  FrameAddStyleTagOptions,\n  FrameWaitForFunctionOptions,\n  GoToOptions,\n  WaitForOptions,\n} from './Frame.js';\nimport type {\n  Keyboard,\n  KeyboardTypeOptions,\n  Mouse,\n  Touchscreen,\n} from './Input.js';\nimport type {JSHandle} from './JSHandle.js';\nimport {\n  FunctionLocator,\n  Locator,\n  NodeLocator,\n  type AwaitedLocator,\n} from './locators/locators.js';\nimport type {Target} from './Target.js';\nimport type {WebWorker} from './WebWorker.js';\n\n/**\n * @public\n */\nexport interface Metrics {\n  Timestamp?: number;\n  Documents?: number;\n  Frames?: number;\n  JSEventListeners?: number;\n  Nodes?: number;\n  LayoutCount?: number;\n  RecalcStyleCount?: number;\n  LayoutDuration?: number;\n  RecalcStyleDuration?: number;\n  ScriptDuration?: number;\n  TaskDuration?: number;\n  JSHeapUsedSize?: number;\n  JSHeapTotalSize?: number;\n}\n\n/**\n * @public\n */\nexport interface Credentials {\n  username: string;\n  password: string;\n}\n\n/**\n * @public\n */\nexport interface WaitForNetworkIdleOptions extends WaitTimeoutOptions {\n  /**\n   * Time (in milliseconds) the network should be idle.\n   *\n   * @defaultValue `500`\n   */\n  idleTime?: number;\n  /**\n   * Maximum number concurrent of network connections to be considered inactive.\n   *\n   * @defaultValue `0`\n   */\n  concurrency?: number;\n}\n\n/**\n * @public\n */\nexport interface WaitTimeoutOptions {\n  /**\n   * Maximum wait time in milliseconds. Pass 0 to disable the timeout.\n   *\n   * The default value can be changed by using the\n   * {@link Page.setDefaultTimeout} method.\n   *\n   * @defaultValue `30_000`\n   */\n  timeout?: number;\n  /**\n   * A signal object that allows you to cancel a waitFor call.\n   */\n  signal?: AbortSignal;\n}\n\n/**\n * @public\n */\nexport interface WaitForSelectorOptions {\n  /**\n   * Wait for the selected element to be present in DOM and to be visible. See\n   * {@link ElementHandle.isVisible} for the definition of element visibility.\n   *\n   * @defaultValue `false`\n   */\n  visible?: boolean;\n  /**\n   * Wait for the selected element to not be found in the DOM or to be hidden.\n   * See {@link ElementHandle.isHidden} for the definition of element\n   * invisibility.\n   *\n   * @defaultValue `false`\n   */\n  hidden?: boolean;\n  /**\n   * Maximum time to wait in milliseconds. Pass `0` to disable timeout.\n   *\n   * The default value can be changed by using {@link Page.setDefaultTimeout}\n   *\n   * @defaultValue `30_000` (30 seconds)\n   */\n  timeout?: number;\n  /**\n   * A signal object that allows you to cancel a waitForSelector call.\n   */\n  signal?: AbortSignal;\n}\n\n/**\n * @public\n */\nexport interface GeolocationOptions {\n  /**\n   * Latitude between `-90` and `90`.\n   */\n  longitude: number;\n  /**\n   * Longitude between `-180` and `180`.\n   */\n  latitude: number;\n  /**\n   * Optional non-negative accuracy value.\n   */\n  accuracy?: number;\n}\n\n/**\n * A media feature to emulate.\n *\n * @public\n */\nexport interface MediaFeature {\n  /**\n   * A name of the feature, for example, 'prefers-reduced-motion'.\n   */\n  name: string;\n  /**\n   * A value for the feature, for example, 'reduce'.\n   */\n  value: string;\n}\n\n/**\n * @public\n */\nexport interface ScreenshotClip extends BoundingBox {\n  /**\n   * @defaultValue `1`\n   */\n  scale?: number;\n}\n\n/**\n * @public\n */\nexport interface ScreenshotOptions {\n  /**\n   * @defaultValue `false`\n   */\n  optimizeForSpeed?: boolean;\n  /**\n   * @defaultValue `'png'`\n   */\n  type?: 'png' | 'jpeg' | 'webp';\n  /**\n   * Quality of the image, between 0-100. Not applicable to `png` images.\n   */\n  quality?: number;\n  /**\n   * Capture the screenshot from the surface, rather than the view.\n   *\n   * @defaultValue `true`\n   */\n  fromSurface?: boolean;\n  /**\n   * When `true`, takes a screenshot of the full page.\n   *\n   * @defaultValue `false`\n   */\n  fullPage?: boolean;\n  /**\n   * Hides default white background and allows capturing screenshots with transparency.\n   *\n   * @defaultValue `false`\n   */\n  omitBackground?: boolean;\n  /**\n   * The file path to save the image to. The screenshot type will be inferred\n   * from file extension. If path is a relative path, then it is resolved\n   * relative to current working directory. If no path is provided, the image\n   * won't be saved to the disk.\n   */\n  path?: string;\n  /**\n   * Specifies the region of the page/element to clip.\n   */\n  clip?: ScreenshotClip;\n  /**\n   * Encoding of the image.\n   *\n   * @defaultValue `'binary'`\n   */\n  encoding?: 'base64' | 'binary';\n  /**\n   * Capture the screenshot beyond the viewport.\n   *\n   * @defaultValue `false` if there is no `clip`. `true` otherwise.\n   */\n  captureBeyondViewport?: boolean;\n}\n\n/**\n * @public\n * @experimental\n */\nexport interface ScreencastOptions {\n  /**\n   * File path to save the screencast to.\n   */\n  path?: `${string}.webm`;\n  /**\n   * Specifies the region of the viewport to crop.\n   */\n  crop?: BoundingBox;\n  /**\n   * Scales the output video.\n   *\n   * For example, `0.5` will shrink the width and height of the output video by\n   * half. `2` will double the width and height of the output video.\n   *\n   * @defaultValue `1`\n   */\n  scale?: number;\n  /**\n   * Specifies the speed to record at.\n   *\n   * For example, `0.5` will slowdown the output video by 50%. `2` will double the\n   * speed of the output video.\n   *\n   * @defaultValue `1`\n   */\n  speed?: number;\n  /**\n   * Path to the {@link https://ffmpeg.org/ | ffmpeg}.\n   *\n   * Required if `ffmpeg` is not in your PATH.\n   */\n  ffmpegPath?: string;\n}\n\n/**\n * @public\n */\nexport interface QueryOptions {\n  /**\n   * Whether to run the query in isolation. When returning many elements\n   * from {@link Page.$$} or similar methods, it might be useful to turn\n   * off the isolation to improve performance. By default, the querying\n   * code will be executed in a separate sandbox realm.\n   *\n   * @defaultValue `true`\n   */\n  isolate: boolean;\n}\n\n/**\n * All the events that a page instance may emit.\n *\n * @public\n */\nexport const enum PageEvent {\n  /**\n   * Emitted when the page closes.\n   */\n  Close = 'close',\n  /**\n   * Emitted when JavaScript within the page calls one of console API methods,\n   * e.g. `console.log` or `console.dir`. Also emitted if the page throws an\n   * error or a warning.\n   *\n   * @remarks\n   * A `console` event provides a {@link ConsoleMessage} representing the\n   * console message that was logged.\n   *\n   * @example\n   * An example of handling `console` event:\n   *\n   * ```ts\n   * page.on('console', msg => {\n   *   for (let i = 0; i < msg.args().length; ++i)\n   *     console.log(`${i}: ${msg.args()[i]}`);\n   * });\n   * page.evaluate(() => console.log('hello', 5, {foo: 'bar'}));\n   * ```\n   */\n  Console = 'console',\n  /**\n   * Emitted when a JavaScript dialog appears, such as `alert`, `prompt`,\n   * `confirm` or `beforeunload`. Puppeteer can respond to the dialog via\n   * {@link Dialog.accept} or {@link Dialog.dismiss}.\n   */\n  Dialog = 'dialog',\n  /**\n   * Emitted when the JavaScript\n   * {@link https://developer.mozilla.org/en-US/docs/Web/Events/DOMContentLoaded | DOMContentLoaded }\n   * event is dispatched.\n   */\n  DOMContentLoaded = 'domcontentloaded',\n  /**\n   * Emitted when the page crashes. Will contain an `Error`.\n   */\n  Error = 'error',\n  /** Emitted when a frame is attached. Will contain a {@link Frame}. */\n  FrameAttached = 'frameattached',\n  /** Emitted when a frame is detached. Will contain a {@link Frame}. */\n  FrameDetached = 'framedetached',\n  /**\n   * Emitted when a frame is navigated to a new URL. Will contain a\n   * {@link Frame}.\n   */\n  FrameNavigated = 'framenavigated',\n  /**\n   * Emitted when the JavaScript\n   * {@link https://developer.mozilla.org/en-US/docs/Web/Events/load | load}\n   * event is dispatched.\n   */\n  Load = 'load',\n  /**\n   * Emitted when the JavaScript code makes a call to `console.timeStamp`. For\n   * the list of metrics see {@link Page.metrics | page.metrics}.\n   *\n   * @remarks\n   * Contains an object with two properties:\n   *\n   * - `title`: the title passed to `console.timeStamp`\n   * - `metrics`: object containing metrics as key/value pairs. The values will\n   *   be `number`s.\n   */\n  Metrics = 'metrics',\n  /**\n   * Emitted when an uncaught exception happens within the page. Contains an\n   * `Error`.\n   */\n  PageError = 'pageerror',\n  /**\n   * Emitted when the page opens a new tab or window.\n   *\n   * Contains a {@link Page} corresponding to the popup window.\n   *\n   * @example\n   *\n   * ```ts\n   * const [popup] = await Promise.all([\n   *   new Promise(resolve => page.once('popup', resolve)),\n   *   page.click('a[target=_blank]'),\n   * ]);\n   * ```\n   *\n   * ```ts\n   * const [popup] = await Promise.all([\n   *   new Promise(resolve => page.once('popup', resolve)),\n   *   page.evaluate(() => window.open('https://example.com')),\n   * ]);\n   * ```\n   */\n  Popup = 'popup',\n  /**\n   * Emitted when a page issues a request and contains a {@link HTTPRequest}.\n   *\n   * @remarks\n   * The object is readonly. See {@link Page.setRequestInterception} for\n   * intercepting and mutating requests.\n   */\n  Request = 'request',\n  /**\n   * Emitted when a request ended up loading from cache. Contains a\n   * {@link HTTPRequest}.\n   *\n   * @remarks\n   * For certain requests, might contain undefined.\n   * {@link https://crbug.com/750469}\n   */\n  RequestServedFromCache = 'requestservedfromcache',\n  /**\n   * Emitted when a request fails, for example by timing out.\n   *\n   * Contains a {@link HTTPRequest}.\n   *\n   * @remarks\n   * HTTP Error responses, such as 404 or 503, are still successful responses\n   * from HTTP standpoint, so request will complete with `requestfinished` event\n   * and not with `requestfailed`.\n   */\n  RequestFailed = 'requestfailed',\n  /**\n   * Emitted when a request finishes successfully. Contains a\n   * {@link HTTPRequest}.\n   */\n  RequestFinished = 'requestfinished',\n  /**\n   * Emitted when a response is received. Contains a {@link HTTPResponse}.\n   */\n  Response = 'response',\n  /**\n   * Emitted when a dedicated\n   * {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API | WebWorker}\n   * is spawned by the page.\n   */\n  WorkerCreated = 'workercreated',\n  /**\n   * Emitted when a dedicated\n   * {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API | WebWorker}\n   * is destroyed by the page.\n   */\n  WorkerDestroyed = 'workerdestroyed',\n}\n\n/**\n * Denotes the objects received by callback functions for page events.\n *\n * See {@link PageEvent} for more detail on the events and when they are\n * emitted.\n *\n * @public\n */\nexport interface PageEvents extends Record<EventType, unknown> {\n  [PageEvent.Close]: undefined;\n  [PageEvent.Console]: ConsoleMessage;\n  [PageEvent.Dialog]: Dialog;\n  [PageEvent.DOMContentLoaded]: undefined;\n  [PageEvent.Error]: Error;\n  [PageEvent.FrameAttached]: Frame;\n  [PageEvent.FrameDetached]: Frame;\n  [PageEvent.FrameNavigated]: Frame;\n  [PageEvent.Load]: undefined;\n  [PageEvent.Metrics]: {title: string; metrics: Metrics};\n  [PageEvent.PageError]: Error;\n  [PageEvent.Popup]: Page | null;\n  [PageEvent.Request]: HTTPRequest;\n  [PageEvent.Response]: HTTPResponse;\n  [PageEvent.RequestFailed]: HTTPRequest;\n  [PageEvent.RequestFinished]: HTTPRequest;\n  [PageEvent.RequestServedFromCache]: HTTPRequest;\n  [PageEvent.WorkerCreated]: WebWorker;\n  [PageEvent.WorkerDestroyed]: WebWorker;\n}\n\n/**\n * @public\n */\nexport interface NewDocumentScriptEvaluation {\n  identifier: string;\n}\n\n/**\n * @internal\n */\nexport function setDefaultScreenshotOptions(options: ScreenshotOptions): void {\n  options.optimizeForSpeed ??= false;\n  options.type ??= 'png';\n  options.fromSurface ??= true;\n  options.fullPage ??= false;\n  options.omitBackground ??= false;\n  options.encoding ??= 'binary';\n  options.captureBeyondViewport ??= true;\n}\n\n/**\n * Page provides methods to interact with a single tab or\n * {@link https://developer.chrome.com/extensions/background_pages | extension background page}\n * in the browser.\n *\n * :::note\n *\n * One Browser instance might have multiple Page instances.\n *\n * :::\n *\n * @example\n * This example creates a page, navigates it to a URL, and then saves a screenshot:\n *\n * ```ts\n * import puppeteer from 'puppeteer';\n *\n * (async () => {\n *   const browser = await puppeteer.launch();\n *   const page = await browser.newPage();\n *   await page.goto('https://example.com');\n *   await page.screenshot({path: 'screenshot.png'});\n *   await browser.close();\n * })();\n * ```\n *\n * The Page class extends from Puppeteer's {@link EventEmitter} class and will\n * emit various events which are documented in the {@link PageEvent} enum.\n *\n * @example\n * This example logs a message for a single page `load` event:\n *\n * ```ts\n * page.once('load', () => console.log('Page loaded!'));\n * ```\n *\n * To unsubscribe from events use the {@link EventEmitter.off} method:\n *\n * ```ts\n * function logRequest(interceptedRequest) {\n *   console.log('A request was made:', interceptedRequest.url());\n * }\n * page.on('request', logRequest);\n * // Sometime later...\n * page.off('request', logRequest);\n * ```\n *\n * @public\n */\nexport abstract class Page extends EventEmitter<PageEvents> {\n  /**\n   * @internal\n   */\n  _isDragging = false;\n  /**\n   * @internal\n   */\n  _timeoutSettings = new TimeoutSettings();\n\n  #requestHandlers = new WeakMap<Handler<HTTPRequest>, Handler<HTTPRequest>>();\n\n  #inflight$ = new ReplaySubject<number>(1);\n\n  /**\n   * @internal\n   */\n  constructor() {\n    super();\n\n    fromEmitterEvent(this, PageEvent.Request)\n      .pipe(\n        mergeMap(originalRequest => {\n          return concat(\n            of(1),\n            merge(\n              fromEmitterEvent(this, PageEvent.RequestFailed),\n              fromEmitterEvent(this, PageEvent.RequestFinished),\n              fromEmitterEvent(this, PageEvent.Response).pipe(\n                map(response => {\n                  return response.request();\n                })\n              )\n            ).pipe(\n              filter(request => {\n                return request.id === originalRequest.id;\n              }),\n              take(1),\n              map(() => {\n                return -1;\n              })\n            )\n          );\n        }),\n        mergeScan((acc, addend) => {\n          return of(acc + addend);\n        }, 0),\n        takeUntil(fromEmitterEvent(this, PageEvent.Close)),\n        startWith(0)\n      )\n      .subscribe(this.#inflight$);\n  }\n\n  /**\n   * `true` if the service worker are being bypassed, `false` otherwise.\n   */\n  abstract isServiceWorkerBypassed(): boolean;\n\n  /**\n   * `true` if drag events are being intercepted, `false` otherwise.\n   *\n   * @deprecated We no longer support intercepting drag payloads. Use the new\n   * drag APIs found on {@link ElementHandle} to drag (or just use the\n   * {@link Page.mouse}).\n   */\n  abstract isDragInterceptionEnabled(): boolean;\n\n  /**\n   * `true` if the page has JavaScript enabled, `false` otherwise.\n   */\n  abstract isJavaScriptEnabled(): boolean;\n\n  /**\n   * Listen to page events.\n   *\n   * @remarks\n   * This method exists to define event typings and handle proper wireup of\n   * cooperative request interception. Actual event listening and dispatching is\n   * delegated to {@link EventEmitter}.\n   *\n   * @internal\n   */\n  override on<K extends keyof EventsWithWildcard<PageEvents>>(\n    type: K,\n    handler: (event: EventsWithWildcard<PageEvents>[K]) => void\n  ): this {\n    if (type !== PageEvent.Request) {\n      return super.on(type, handler);\n    }\n    let wrapper = this.#requestHandlers.get(\n      handler as (event: PageEvents[PageEvent.Request]) => void\n    );\n    if (wrapper === undefined) {\n      wrapper = (event: HTTPRequest) => {\n        event.enqueueInterceptAction(() => {\n          return handler(event as EventsWithWildcard<PageEvents>[K]);\n        });\n      };\n      this.#requestHandlers.set(\n        handler as (event: PageEvents[PageEvent.Request]) => void,\n        wrapper\n      );\n    }\n    return super.on(\n      type,\n      wrapper as (event: EventsWithWildcard<PageEvents>[K]) => void\n    );\n  }\n\n  /**\n   * @internal\n   */\n  override off<K extends keyof EventsWithWildcard<PageEvents>>(\n    type: K,\n    handler: (event: EventsWithWildcard<PageEvents>[K]) => void\n  ): this {\n    if (type === PageEvent.Request) {\n      handler =\n        (this.#requestHandlers.get(\n          handler as (\n            event: EventsWithWildcard<PageEvents>[PageEvent.Request]\n          ) => void\n        ) as (event: EventsWithWildcard<PageEvents>[K]) => void) || handler;\n    }\n    return super.off(type, handler);\n  }\n\n  /**\n   * This method is typically coupled with an action that triggers file\n   * choosing.\n   *\n   * :::caution\n   *\n   * This must be called before the file chooser is launched. It will not return\n   * a currently active file chooser.\n   *\n   * :::\n   *\n   * :::caution\n   *\n   * Interception of file dialogs triggered via DOM APIs such as\n   * window.showOpenFilePicker is currently not supported.\n   *\n   * :::\n   *\n   * @remarks\n   * In the \"headful\" browser, this method results in the native file picker\n   * dialog `not showing up` for the user.\n   *\n   * @example\n   * The following example clicks a button that issues a file chooser\n   * and then responds with `/tmp/myfile.pdf` as if a user has selected this file.\n   *\n   * ```ts\n   * const [fileChooser] = await Promise.all([\n   *   page.waitForFileChooser(),\n   *   page.click('#upload-file-button'),\n   *   // some button that triggers file selection\n   * ]);\n   * await fileChooser.accept(['/tmp/myfile.pdf']);\n   * ```\n   */\n  abstract waitForFileChooser(\n    options?: WaitTimeoutOptions\n  ): Promise<FileChooser>;\n\n  /**\n   * Sets the page's geolocation.\n   *\n   * @remarks\n   * Consider using {@link BrowserContext.overridePermissions} to grant\n   * permissions for the page to read its geolocation.\n   *\n   * @example\n   *\n   * ```ts\n   * await page.setGeolocation({latitude: 59.95, longitude: 30.31667});\n   * ```\n   */\n  abstract setGeolocation(options: GeolocationOptions): Promise<void>;\n\n  /**\n   * A target this page was created from.\n   *\n   * @deprecated Use {@link Page.createCDPSession} directly.\n   */\n  abstract target(): Target;\n\n  /**\n   * Get the browser the page belongs to.\n   */\n  abstract browser(): Browser;\n\n  /**\n   * Get the browser context that the page belongs to.\n   */\n  abstract browserContext(): BrowserContext;\n\n  /**\n   * The page's main frame.\n   */\n  abstract mainFrame(): Frame;\n\n  /**\n   * Creates a Chrome Devtools Protocol session attached to the page.\n   */\n  abstract createCDPSession(): Promise<CDPSession>;\n\n  /**\n   * {@inheritDoc Keyboard}\n   */\n  abstract get keyboard(): Keyboard;\n\n  /**\n   * {@inheritDoc Touchscreen}\n   */\n  abstract get touchscreen(): Touchscreen;\n\n  /**\n   * {@inheritDoc Coverage}\n   */\n  abstract get coverage(): Coverage;\n\n  /**\n   * {@inheritDoc Tracing}\n   */\n  abstract get tracing(): Tracing;\n\n  /**\n   * {@inheritDoc Accessibility}\n   */\n  get accessibility(): Accessibility {\n    return this.mainFrame().accessibility;\n  }\n\n  /**\n   * An array of all frames attached to the page.\n   */\n  abstract frames(): Frame[];\n\n  /**\n   * All of the dedicated {@link\n   * https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API |\n   * WebWorkers} associated with the page.\n   *\n   * @remarks\n   * This does not contain ServiceWorkers\n   */\n  abstract workers(): WebWorker[];\n\n  /**\n   * Activating request interception enables {@link HTTPRequest.abort},\n   * {@link HTTPRequest.continue} and {@link HTTPRequest.respond} methods. This\n   * provides the capability to modify network requests that are made by a page.\n   *\n   * Once request interception is enabled, every request will stall unless it's\n   * continued, responded or aborted; or completed using the browser cache.\n   *\n   * See the\n   * {@link https://pptr.dev/guides/network-interception|Request interception guide}\n   * for more details.\n   *\n   * @example\n   * An example of a naïve request interceptor that aborts all image requests:\n   *\n   * ```ts\n   * import puppeteer from 'puppeteer';\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   const page = await browser.newPage();\n   *   await page.setRequestInterception(true);\n   *   page.on('request', interceptedRequest => {\n   *     if (\n   *       interceptedRequest.url().endsWith('.png') ||\n   *       interceptedRequest.url().endsWith('.jpg')\n   *     )\n   *       interceptedRequest.abort();\n   *     else interceptedRequest.continue();\n   *   });\n   *   await page.goto('https://example.com');\n   *   await browser.close();\n   * })();\n   * ```\n   *\n   * @param value - Whether to enable request interception.\n   */\n  abstract setRequestInterception(value: boolean): Promise<void>;\n\n  /**\n   * Toggles ignoring of service worker for each request.\n   *\n   * @param bypass - Whether to bypass service worker and load from network.\n   */\n  abstract setBypassServiceWorker(bypass: boolean): Promise<void>;\n\n  /**\n   * @param enabled - Whether to enable drag interception.\n   *\n   * @deprecated We no longer support intercepting drag payloads. Use the new\n   * drag APIs found on {@link ElementHandle} to drag (or just use the\n   * {@link Page.mouse}).\n   */\n  abstract setDragInterception(enabled: boolean): Promise<void>;\n\n  /**\n   * Sets the network connection to offline.\n   *\n   * It does not change the parameters used in {@link Page.emulateNetworkConditions}\n   *\n   * @param enabled - When `true`, enables offline mode for the page.\n   */\n  abstract setOfflineMode(enabled: boolean): Promise<void>;\n\n  /**\n   * This does not affect WebSockets and WebRTC PeerConnections (see\n   * https://crbug.com/563644). To set the page offline, you can use\n   * {@link Page.setOfflineMode}.\n   *\n   * A list of predefined network conditions can be used by importing\n   * {@link PredefinedNetworkConditions}.\n   *\n   * @example\n   *\n   * ```ts\n   * import {PredefinedNetworkConditions} from 'puppeteer';\n   * const slow3G = PredefinedNetworkConditions['Slow 3G'];\n   *\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   const page = await browser.newPage();\n   *   await page.emulateNetworkConditions(slow3G);\n   *   await page.goto('https://www.google.com');\n   *   // other actions...\n   *   await browser.close();\n   * })();\n   * ```\n   *\n   * @param networkConditions - Passing `null` disables network condition\n   * emulation.\n   */\n  abstract emulateNetworkConditions(\n    networkConditions: NetworkConditions | null\n  ): Promise<void>;\n\n  /**\n   * This setting will change the default maximum navigation time for the\n   * following methods and related shortcuts:\n   *\n   * - {@link Page.goBack | page.goBack(options)}\n   *\n   * - {@link Page.goForward | page.goForward(options)}\n   *\n   * - {@link Page.goto | page.goto(url,options)}\n   *\n   * - {@link Page.reload | page.reload(options)}\n   *\n   * - {@link Page.setContent | page.setContent(html,options)}\n   *\n   * - {@link Page.waitForNavigation | page.waitForNavigation(options)}\n   *   @param timeout - Maximum navigation time in milliseconds.\n   */\n  abstract setDefaultNavigationTimeout(timeout: number): void;\n\n  /**\n   * @param timeout - Maximum time in milliseconds.\n   */\n  abstract setDefaultTimeout(timeout: number): void;\n\n  /**\n   * Maximum time in milliseconds.\n   */\n  abstract getDefaultTimeout(): number;\n\n  /**\n   * Creates a locator for the provided selector. See {@link Locator} for\n   * details and supported actions.\n   *\n   * @param selector -\n   * {@link https://pptr.dev/guides/page-interactions#selectors | selector}\n   * to query the page for.\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}\n   * can be passed as-is and a\n   * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}\n   * allows quering by\n   * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},\n   * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},\n   * and\n   * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}\n   * and\n   * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.\n   * Alternatively, you can specify the selector type using a\n   * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.\n   */\n  locator<Selector extends string>(\n    selector: Selector\n  ): Locator<NodeFor<Selector>>;\n\n  /**\n   * Creates a locator for the provided function. See {@link Locator} for\n   * details and supported actions.\n   *\n   * @param selector -\n   * {@link https://pptr.dev/guides/page-interactions#selectors | selector}\n   * to query the page for.\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}\n   * can be passed as-is and a\n   * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}\n   * allows quering by\n   * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},\n   * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},\n   * and\n   * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}\n   * and\n   * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.\n   * Alternatively, you can specify the selector type using a\n   * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.\n   */\n  locator<Ret>(func: () => Awaitable<Ret>): Locator<Ret>;\n  locator<Selector extends string, Ret>(\n    selectorOrFunc: Selector | (() => Awaitable<Ret>)\n  ): Locator<NodeFor<Selector>> | Locator<Ret> {\n    if (typeof selectorOrFunc === 'string') {\n      return NodeLocator.create(this, selectorOrFunc);\n    } else {\n      return FunctionLocator.create(this, selectorOrFunc);\n    }\n  }\n\n  /**\n   * A shortcut for {@link Locator.race} that does not require static imports.\n   *\n   * @internal\n   */\n  locatorRace<Locators extends readonly unknown[] | []>(\n    locators: Locators\n  ): Locator<AwaitedLocator<Locators[number]>> {\n    return Locator.race(locators);\n  }\n\n  /**\n   * Finds the first element that matches the selector. If no element matches\n   * the selector, the return value resolves to `null`.\n   *\n   * @param selector -\n   * {@link https://pptr.dev/guides/page-interactions#selectors | selector}\n   * to query the page for.\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}\n   * can be passed as-is and a\n   * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}\n   * allows quering by\n   * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},\n   * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},\n   * and\n   * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}\n   * and\n   * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.\n   * Alternatively, you can specify the selector type using a\n   * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.\n   *\n   * @remarks\n   *\n   * Shortcut for {@link Frame.$ | Page.mainFrame().$(selector) }.\n   */\n  async $<Selector extends string>(\n    selector: Selector\n  ): Promise<ElementHandle<NodeFor<Selector>> | null> {\n    return await this.mainFrame().$(selector);\n  }\n\n  /**\n   * Finds elements on the page that match the selector. If no elements\n   * match the selector, the return value resolves to `[]`.\n   *\n   * @param selector -\n   * {@link https://pptr.dev/guides/page-interactions#selectors | selector}\n   * to query the page for.\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}\n   * can be passed as-is and a\n   * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}\n   * allows quering by\n   * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},\n   * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},\n   * and\n   * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}\n   * and\n   * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.\n   * Alternatively, you can specify the selector type using a\n   * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.\n   *\n   * @remarks\n   *\n   * Shortcut for {@link Frame.$$ | Page.mainFrame().$$(selector) }.\n   */\n  async $$<Selector extends string>(\n    selector: Selector,\n    options?: QueryOptions\n  ): Promise<Array<ElementHandle<NodeFor<Selector>>>> {\n    return await this.mainFrame().$$(selector, options);\n  }\n\n  /**\n   * @remarks\n   *\n   * The only difference between {@link Page.evaluate | page.evaluate} and\n   * `page.evaluateHandle` is that `evaluateHandle` will return the value\n   * wrapped in an in-page object.\n   *\n   * If the function passed to `page.evaluateHandle` returns a Promise, the\n   * function will wait for the promise to resolve and return its value.\n   *\n   * You can pass a string instead of a function (although functions are\n   * recommended as they are easier to debug and use with TypeScript):\n   *\n   * @example\n   *\n   * ```ts\n   * const aHandle = await page.evaluateHandle('document');\n   * ```\n   *\n   * @example\n   * {@link JSHandle} instances can be passed as arguments to the `pageFunction`:\n   *\n   * ```ts\n   * const aHandle = await page.evaluateHandle(() => document.body);\n   * const resultHandle = await page.evaluateHandle(\n   *   body => body.innerHTML,\n   *   aHandle\n   * );\n   * console.log(await resultHandle.jsonValue());\n   * await resultHandle.dispose();\n   * ```\n   *\n   * Most of the time this function returns a {@link JSHandle},\n   * but if `pageFunction` returns a reference to an element,\n   * you instead get an {@link ElementHandle} back:\n   *\n   * @example\n   *\n   * ```ts\n   * const button = await page.evaluateHandle(() =>\n   *   document.querySelector('button')\n   * );\n   * // can call `click` because `button` is an `ElementHandle`\n   * await button.click();\n   * ```\n   *\n   * The TypeScript definitions assume that `evaluateHandle` returns\n   * a `JSHandle`, but if you know it's going to return an\n   * `ElementHandle`, pass it as the generic argument:\n   *\n   * ```ts\n   * const button = await page.evaluateHandle<ElementHandle>(...);\n   * ```\n   *\n   * @param pageFunction - a function that is run within the page\n   * @param args - arguments to be passed to the pageFunction\n   */\n  async evaluateHandle<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<HandleFor<Awaited<ReturnType<Func>>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(\n      this.evaluateHandle.name,\n      pageFunction\n    );\n    return await this.mainFrame().evaluateHandle(pageFunction, ...args);\n  }\n\n  /**\n   * This method iterates the JavaScript heap and finds all objects with the\n   * given prototype.\n   *\n   * @example\n   *\n   * ```ts\n   * // Create a Map object\n   * await page.evaluate(() => (window.map = new Map()));\n   * // Get a handle to the Map object prototype\n   * const mapPrototype = await page.evaluateHandle(() => Map.prototype);\n   * // Query all map instances into an array\n   * const mapInstances = await page.queryObjects(mapPrototype);\n   * // Count amount of map objects in heap\n   * const count = await page.evaluate(maps => maps.length, mapInstances);\n   * await mapInstances.dispose();\n   * await mapPrototype.dispose();\n   * ```\n   *\n   * @param prototypeHandle - a handle to the object prototype.\n   * @returns Promise which resolves to a handle to an array of objects with\n   * this prototype.\n   */\n  abstract queryObjects<Prototype>(\n    prototypeHandle: JSHandle<Prototype>\n  ): Promise<JSHandle<Prototype[]>>;\n\n  /**\n   * This method finds the first element within the page that matches the selector\n   * and passes the result as the first argument to the `pageFunction`.\n   *\n   * @remarks\n   *\n   * If no element is found matching `selector`, the method will throw an error.\n   *\n   * If `pageFunction` returns a promise `$eval` will wait for the promise to\n   * resolve and then return its value.\n   *\n   * @example\n   *\n   * ```ts\n   * const searchValue = await page.$eval('#search', el => el.value);\n   * const preloadHref = await page.$eval('link[rel=preload]', el => el.href);\n   * const html = await page.$eval('.main-container', el => el.outerHTML);\n   * ```\n   *\n   * If you are using TypeScript, you may have to provide an explicit type to the\n   * first argument of the `pageFunction`.\n   * By default it is typed as `Element`, but you may need to provide a more\n   * specific sub-type:\n   *\n   * @example\n   *\n   * ```ts\n   * // if you don't provide HTMLInputElement here, TS will error\n   * // as `value` is not on `Element`\n   * const searchValue = await page.$eval(\n   *   '#search',\n   *   (el: HTMLInputElement) => el.value\n   * );\n   * ```\n   *\n   * The compiler should be able to infer the return type\n   * from the `pageFunction` you provide. If it is unable to, you can use the generic\n   * type to tell the compiler what return type you expect from `$eval`:\n   *\n   * @example\n   *\n   * ```ts\n   * // The compiler can infer the return type in this case, but if it can't\n   * // or if you want to be more explicit, provide it as the generic type.\n   * const searchValue = await page.$eval<string>(\n   *   '#search',\n   *   (el: HTMLInputElement) => el.value\n   * );\n   * ```\n   *\n   * @param selector -\n   * {@link https://pptr.dev/guides/page-interactions#selectors | selector}\n   * to query the page for.\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}\n   * can be passed as-is and a\n   * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}\n   * allows quering by\n   * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},\n   * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},\n   * and\n   * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}\n   * and\n   * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.\n   * Alternatively, you can specify the selector type using a\n   * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.\n   * @param pageFunction - the function to be evaluated in the page context.\n   * Will be passed the result of the element matching the selector as its\n   * first argument.\n   * @param args - any additional arguments to pass through to `pageFunction`.\n   *\n   * @returns The result of calling `pageFunction`. If it returns an element it\n   * is wrapped in an {@link ElementHandle}, else the raw value itself is\n   * returned.\n   */\n  async $eval<\n    Selector extends string,\n    Params extends unknown[],\n    Func extends EvaluateFuncWith<NodeFor<Selector>, Params> = EvaluateFuncWith<\n      NodeFor<Selector>,\n      Params\n    >,\n  >(\n    selector: Selector,\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<Awaited<ReturnType<Func>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(this.$eval.name, pageFunction);\n    return await this.mainFrame().$eval(selector, pageFunction, ...args);\n  }\n\n  /**\n   * This method returns all elements matching the selector and passes the\n   * resulting array as the first argument to the `pageFunction`.\n   *\n   * @remarks\n   * If `pageFunction` returns a promise `$$eval` will wait for the promise to\n   * resolve and then return its value.\n   *\n   * @example\n   *\n   * ```ts\n   * // get the amount of divs on the page\n   * const divCount = await page.$$eval('div', divs => divs.length);\n   *\n   * // get the text content of all the `.options` elements:\n   * const options = await page.$$eval('div > span.options', options => {\n   *   return options.map(option => option.textContent);\n   * });\n   * ```\n   *\n   * If you are using TypeScript, you may have to provide an explicit type to the\n   * first argument of the `pageFunction`.\n   * By default it is typed as `Element[]`, but you may need to provide a more\n   * specific sub-type:\n   *\n   * @example\n   *\n   * ```ts\n   * await page.$$eval('input', elements => {\n   *   return elements.map(e => e.value);\n   * });\n   * ```\n   *\n   * The compiler should be able to infer the return type\n   * from the `pageFunction` you provide. If it is unable to, you can use the generic\n   * type to tell the compiler what return type you expect from `$$eval`:\n   *\n   * @example\n   *\n   * ```ts\n   * const allInputValues = await page.$$eval('input', elements =>\n   *   elements.map(e => e.textContent)\n   * );\n   * ```\n   *\n   * @param selector -\n   * {@link https://pptr.dev/guides/page-interactions#selectors | selector}\n   * to query the page for.\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}\n   * can be passed as-is and a\n   * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}\n   * allows quering by\n   * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},\n   * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},\n   * and\n   * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}\n   * and\n   * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.\n   * Alternatively, you can specify the selector type using a\n   * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.\n   * @param pageFunction - the function to be evaluated in the page context.\n   * Will be passed an array of matching elements as its first argument.\n   * @param args - any additional arguments to pass through to `pageFunction`.\n   *\n   * @returns The result of calling `pageFunction`. If it returns an element it\n   * is wrapped in an {@link ElementHandle}, else the raw value itself is\n   * returned.\n   */\n  async $$eval<\n    Selector extends string,\n    Params extends unknown[],\n    Func extends EvaluateFuncWith<\n      Array<NodeFor<Selector>>,\n      Params\n    > = EvaluateFuncWith<Array<NodeFor<Selector>>, Params>,\n  >(\n    selector: Selector,\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<Awaited<ReturnType<Func>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(this.$$eval.name, pageFunction);\n    return await this.mainFrame().$$eval(selector, pageFunction, ...args);\n  }\n\n  /**\n   * If no URLs are specified, this method returns cookies for the current page\n   * URL. If URLs are specified, only cookies for those URLs are returned.\n   */\n  abstract cookies(...urls: string[]): Promise<Cookie[]>;\n\n  abstract deleteCookie(...cookies: DeleteCookiesRequest[]): Promise<void>;\n\n  /**\n   * @example\n   *\n   * ```ts\n   * await page.setCookie(cookieObject1, cookieObject2);\n   * ```\n   */\n  abstract setCookie(...cookies: CookieParam[]): Promise<void>;\n\n  /**\n   * Adds a `<script>` tag into the page with the desired URL or content.\n   *\n   * @remarks\n   * Shortcut for\n   * {@link Frame.addScriptTag | page.mainFrame().addScriptTag(options)}.\n   *\n   * @param options - Options for the script.\n   * @returns An {@link ElementHandle | element handle} to the injected\n   * `<script>` element.\n   */\n  async addScriptTag(\n    options: FrameAddScriptTagOptions\n  ): Promise<ElementHandle<HTMLScriptElement>> {\n    return await this.mainFrame().addScriptTag(options);\n  }\n\n  /**\n   * Adds a `<link rel=\"stylesheet\">` tag into the page with the desired URL or\n   * a `<style type=\"text/css\">` tag with the content.\n   *\n   * Shortcut for\n   * {@link Frame.(addStyleTag:2) | page.mainFrame().addStyleTag(options)}.\n   *\n   * @returns An {@link ElementHandle | element handle} to the injected `<link>`\n   * or `<style>` element.\n   */\n  async addStyleTag(\n    options: Omit<FrameAddStyleTagOptions, 'url'>\n  ): Promise<ElementHandle<HTMLStyleElement>>;\n  async addStyleTag(\n    options: FrameAddStyleTagOptions\n  ): Promise<ElementHandle<HTMLLinkElement>>;\n  async addStyleTag(\n    options: FrameAddStyleTagOptions\n  ): Promise<ElementHandle<HTMLStyleElement | HTMLLinkElement>> {\n    return await this.mainFrame().addStyleTag(options);\n  }\n\n  /**\n   * The method adds a function called `name` on the page's `window` object.\n   * When called, the function executes `puppeteerFunction` in node.js and\n   * returns a `Promise` which resolves to the return value of\n   * `puppeteerFunction`.\n   *\n   * If the puppeteerFunction returns a `Promise`, it will be awaited.\n   *\n   * :::note\n   *\n   * Functions installed via `page.exposeFunction` survive navigations.\n   *\n   * :::\n   *\n   * @example\n   * An example of adding an `md5` function into the page:\n   *\n   * ```ts\n   * import puppeteer from 'puppeteer';\n   * import crypto from 'crypto';\n   *\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   const page = await browser.newPage();\n   *   page.on('console', msg => console.log(msg.text()));\n   *   await page.exposeFunction('md5', text =>\n   *     crypto.createHash('md5').update(text).digest('hex')\n   *   );\n   *   await page.evaluate(async () => {\n   *     // use window.md5 to compute hashes\n   *     const myString = 'PUPPETEER';\n   *     const myHash = await window.md5(myString);\n   *     console.log(`md5 of ${myString} is ${myHash}`);\n   *   });\n   *   await browser.close();\n   * })();\n   * ```\n   *\n   * @example\n   * An example of adding a `window.readfile` function into the page:\n   *\n   * ```ts\n   * import puppeteer from 'puppeteer';\n   * import fs from 'fs';\n   *\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   const page = await browser.newPage();\n   *   page.on('console', msg => console.log(msg.text()));\n   *   await page.exposeFunction('readfile', async filePath => {\n   *     return new Promise((resolve, reject) => {\n   *       fs.readFile(filePath, 'utf8', (err, text) => {\n   *         if (err) reject(err);\n   *         else resolve(text);\n   *       });\n   *     });\n   *   });\n   *   await page.evaluate(async () => {\n   *     // use window.readfile to read contents of a file\n   *     const content = await window.readfile('/etc/hosts');\n   *     console.log(content);\n   *   });\n   *   await browser.close();\n   * })();\n   * ```\n   *\n   * @param name - Name of the function on the window object\n   * @param pptrFunction - Callback function which will be called in Puppeteer's\n   * context.\n   */\n  abstract exposeFunction(\n    name: string,\n    pptrFunction: Function | {default: Function}\n  ): Promise<void>;\n\n  /**\n   * The method removes a previously added function via ${@link Page.exposeFunction}\n   * called `name` from the page's `window` object.\n   */\n  abstract removeExposedFunction(name: string): Promise<void>;\n\n  /**\n   * Provide credentials for `HTTP authentication`.\n   *\n   * :::note\n   *\n   * Request interception will be turned on behind the scenes to\n   * implement authentication. This might affect performance.\n   *\n   * :::\n   *\n   * @remarks\n   * To disable authentication, pass `null`.\n   */\n  abstract authenticate(credentials: Credentials | null): Promise<void>;\n\n  /**\n   * The extra HTTP headers will be sent with every request the page initiates.\n   *\n   * :::tip\n   *\n   * All HTTP header names are lowercased. (HTTP headers are\n   * case-insensitive, so this shouldn’t impact your server code.)\n   *\n   * :::\n   *\n   * :::note\n   *\n   * page.setExtraHTTPHeaders does not guarantee the order of headers in\n   * the outgoing requests.\n   *\n   * :::\n   *\n   * @param headers - An object containing additional HTTP headers to be sent\n   * with every request. All header values must be strings.\n   */\n  abstract setExtraHTTPHeaders(headers: Record<string, string>): Promise<void>;\n\n  /**\n   * @param userAgent - Specific user agent to use in this page\n   * @param userAgentData - Specific user agent client hint data to use in this\n   * page\n   * @returns Promise which resolves when the user agent is set.\n   */\n  abstract setUserAgent(\n    userAgent: string,\n    userAgentMetadata?: Protocol.Emulation.UserAgentMetadata\n  ): Promise<void>;\n\n  /**\n   * Object containing metrics as key/value pairs.\n   *\n   * @returns\n   *\n   * - `Timestamp` : The timestamp when the metrics sample was taken.\n   *\n   * - `Documents` : Number of documents in the page.\n   *\n   * - `Frames` : Number of frames in the page.\n   *\n   * - `JSEventListeners` : Number of events in the page.\n   *\n   * - `Nodes` : Number of DOM nodes in the page.\n   *\n   * - `LayoutCount` : Total number of full or partial page layout.\n   *\n   * - `RecalcStyleCount` : Total number of page style recalculations.\n   *\n   * - `LayoutDuration` : Combined durations of all page layouts.\n   *\n   * - `RecalcStyleDuration` : Combined duration of all page style\n   *   recalculations.\n   *\n   * - `ScriptDuration` : Combined duration of JavaScript execution.\n   *\n   * - `TaskDuration` : Combined duration of all tasks performed by the browser.\n   *\n   * - `JSHeapUsedSize` : Used JavaScript heap size.\n   *\n   * - `JSHeapTotalSize` : Total JavaScript heap size.\n   *\n   * @remarks\n   * All timestamps are in monotonic time: monotonically increasing time\n   * in seconds since an arbitrary point in the past.\n   */\n  abstract metrics(): Promise<Metrics>;\n\n  /**\n   * The page's URL.\n   *\n   * @remarks\n   *\n   * Shortcut for {@link Frame.url | page.mainFrame().url()}.\n   */\n  url(): string {\n    return this.mainFrame().url();\n  }\n\n  /**\n   * The full HTML contents of the page, including the DOCTYPE.\n   */\n  async content(): Promise<string> {\n    return await this.mainFrame().content();\n  }\n\n  /**\n   * Set the content of the page.\n   *\n   * @param html - HTML markup to assign to the page.\n   * @param options - Parameters that has some properties.\n   */\n  async setContent(html: string, options?: WaitForOptions): Promise<void> {\n    await this.mainFrame().setContent(html, options);\n  }\n\n  /**\n   * {@inheritDoc Frame.goto}\n   */\n  async goto(url: string, options?: GoToOptions): Promise<HTTPResponse | null> {\n    return await this.mainFrame().goto(url, options);\n  }\n\n  /**\n   * Reloads the page.\n   *\n   * @param options - Options to configure waiting behavior.\n   * @returns A promise which resolves to the main resource response. In case of\n   * multiple redirects, the navigation will resolve with the response of the\n   * last redirect.\n   */\n  abstract reload(options?: WaitForOptions): Promise<HTTPResponse | null>;\n\n  /**\n   * Waits for the page to navigate to a new URL or to reload. It is useful when\n   * you run code that will indirectly cause the page to navigate.\n   *\n   * @example\n   *\n   * ```ts\n   * const [response] = await Promise.all([\n   *   page.waitForNavigation(), // The promise resolves after navigation has finished\n   *   page.click('a.my-link'), // Clicking the link will indirectly cause a navigation\n   * ]);\n   * ```\n   *\n   * @remarks\n   *\n   * Usage of the\n   * {@link https://developer.mozilla.org/en-US/docs/Web/API/History_API | History API}\n   * to change the URL is considered a navigation.\n   *\n   * @param options - Navigation parameters which might have the following\n   * properties:\n   * @returns A `Promise` which resolves to the main resource response.\n   *\n   * - In case of multiple redirects, the navigation will resolve with the\n   *   response of the last redirect.\n   * - In case of navigation to a different anchor or navigation due to History\n   *   API usage, the navigation will resolve with `null`.\n   */\n  async waitForNavigation(\n    options: WaitForOptions = {}\n  ): Promise<HTTPResponse | null> {\n    return await this.mainFrame().waitForNavigation(options);\n  }\n\n  /**\n   * @param urlOrPredicate - A URL or predicate to wait for\n   * @param options - Optional waiting parameters\n   * @returns Promise which resolves to the matched request\n   * @example\n   *\n   * ```ts\n   * const firstRequest = await page.waitForRequest(\n   *   'https://example.com/resource'\n   * );\n   * const finalRequest = await page.waitForRequest(\n   *   request => request.url() === 'https://example.com'\n   * );\n   * return finalRequest.response()?.ok();\n   * ```\n   *\n   * @remarks\n   * Optional Waiting Parameters have:\n   *\n   * - `timeout`: Maximum wait time in milliseconds, defaults to `30` seconds, pass\n   *   `0` to disable the timeout. The default value can be changed by using the\n   *   {@link Page.setDefaultTimeout} method.\n   */\n  waitForRequest(\n    urlOrPredicate: string | AwaitablePredicate<HTTPRequest>,\n    options: WaitTimeoutOptions = {}\n  ): Promise<HTTPRequest> {\n    const {timeout: ms = this._timeoutSettings.timeout(), signal} = options;\n    if (typeof urlOrPredicate === 'string') {\n      const url = urlOrPredicate;\n      urlOrPredicate = (request: HTTPRequest) => {\n        return request.url() === url;\n      };\n    }\n    const observable$ = fromEmitterEvent(this, PageEvent.Request).pipe(\n      filterAsync(urlOrPredicate),\n      raceWith(\n        timeout(ms),\n        fromAbortSignal(signal),\n        fromEmitterEvent(this, PageEvent.Close).pipe(\n          map(() => {\n            throw new TargetCloseError('Page closed!');\n          })\n        )\n      )\n    );\n    return firstValueFrom(observable$);\n  }\n\n  /**\n   * @param urlOrPredicate - A URL or predicate to wait for.\n   * @param options - Optional waiting parameters\n   * @returns Promise which resolves to the matched response.\n   * @example\n   *\n   * ```ts\n   * const firstResponse = await page.waitForResponse(\n   *   'https://example.com/resource'\n   * );\n   * const finalResponse = await page.waitForResponse(\n   *   response =>\n   *     response.url() === 'https://example.com' && response.status() === 200\n   * );\n   * const finalResponse = await page.waitForResponse(async response => {\n   *   return (await response.text()).includes('<html>');\n   * });\n   * return finalResponse.ok();\n   * ```\n   *\n   * @remarks\n   * Optional Parameter have:\n   *\n   * - `timeout`: Maximum wait time in milliseconds, defaults to `30` seconds,\n   *   pass `0` to disable the timeout. The default value can be changed by using\n   *   the {@link Page.setDefaultTimeout} method.\n   */\n  waitForResponse(\n    urlOrPredicate: string | AwaitablePredicate<HTTPResponse>,\n    options: WaitTimeoutOptions = {}\n  ): Promise<HTTPResponse> {\n    const {timeout: ms = this._timeoutSettings.timeout(), signal} = options;\n    if (typeof urlOrPredicate === 'string') {\n      const url = urlOrPredicate;\n      urlOrPredicate = (response: HTTPResponse) => {\n        return response.url() === url;\n      };\n    }\n    const observable$ = fromEmitterEvent(this, PageEvent.Response).pipe(\n      filterAsync(urlOrPredicate),\n      raceWith(\n        timeout(ms),\n        fromAbortSignal(signal),\n        fromEmitterEvent(this, PageEvent.Close).pipe(\n          map(() => {\n            throw new TargetCloseError('Page closed!');\n          })\n        )\n      )\n    );\n    return firstValueFrom(observable$);\n  }\n\n  /**\n   * Waits for the network to be idle.\n   *\n   * @param options - Options to configure waiting behavior.\n   * @returns A promise which resolves once the network is idle.\n   */\n  waitForNetworkIdle(options: WaitForNetworkIdleOptions = {}): Promise<void> {\n    return firstValueFrom(this.waitForNetworkIdle$(options));\n  }\n\n  /**\n   * @internal\n   */\n  waitForNetworkIdle$(\n    options: WaitForNetworkIdleOptions = {}\n  ): Observable<void> {\n    const {\n      timeout: ms = this._timeoutSettings.timeout(),\n      idleTime = NETWORK_IDLE_TIME,\n      concurrency = 0,\n      signal,\n    } = options;\n\n    return this.#inflight$.pipe(\n      switchMap(inflight => {\n        if (inflight > concurrency) {\n          return EMPTY;\n        }\n        return timer(idleTime);\n      }),\n      map(() => {}),\n      raceWith(\n        timeout(ms),\n        fromAbortSignal(signal),\n        fromEmitterEvent(this, PageEvent.Close).pipe(\n          map(() => {\n            throw new TargetCloseError('Page closed!');\n          })\n        )\n      )\n    );\n  }\n\n  /**\n   * Waits for a frame matching the given conditions to appear.\n   *\n   * @example\n   *\n   * ```ts\n   * const frame = await page.waitForFrame(async frame => {\n   *   return frame.name() === 'Test';\n   * });\n   * ```\n   */\n  async waitForFrame(\n    urlOrPredicate: string | ((frame: Frame) => Awaitable<boolean>),\n    options: WaitTimeoutOptions = {}\n  ): Promise<Frame> {\n    const {timeout: ms = this.getDefaultTimeout(), signal} = options;\n\n    const predicate = isString(urlOrPredicate)\n      ? (frame: Frame) => {\n          return urlOrPredicate === frame.url();\n        }\n      : urlOrPredicate;\n\n    return await firstValueFrom(\n      merge(\n        fromEmitterEvent(this, PageEvent.FrameAttached),\n        fromEmitterEvent(this, PageEvent.FrameNavigated),\n        from(this.frames())\n      ).pipe(\n        filterAsync(predicate),\n        first(),\n        raceWith(\n          timeout(ms),\n          fromAbortSignal(signal),\n          fromEmitterEvent(this, PageEvent.Close).pipe(\n            map(() => {\n              throw new TargetCloseError('Page closed.');\n            })\n          )\n        )\n      )\n    );\n  }\n\n  /**\n   * This method navigate to the previous page in history.\n   * @param options - Navigation parameters\n   * @returns Promise which resolves to the main resource response. In case of\n   * multiple redirects, the navigation will resolve with the response of the\n   * last redirect. If can not go back, resolves to `null`.\n   */\n  abstract goBack(options?: WaitForOptions): Promise<HTTPResponse | null>;\n\n  /**\n   * This method navigate to the next page in history.\n   * @param options - Navigation Parameter\n   * @returns Promise which resolves to the main resource response. In case of\n   * multiple redirects, the navigation will resolve with the response of the\n   * last redirect. If can not go forward, resolves to `null`.\n   */\n  abstract goForward(options?: WaitForOptions): Promise<HTTPResponse | null>;\n\n  /**\n   * Brings page to front (activates tab).\n   */\n  abstract bringToFront(): Promise<void>;\n\n  /**\n   * Emulates a given device's metrics and user agent.\n   *\n   * To aid emulation, Puppeteer provides a list of known devices that can be\n   * via {@link KnownDevices}.\n   *\n   * @remarks\n   * This method is a shortcut for calling two methods:\n   * {@link Page.setUserAgent} and {@link Page.setViewport}.\n   *\n   * This method will resize the page. A lot of websites don't expect phones to\n   * change size, so you should emulate before navigating to the page.\n   *\n   * @example\n   *\n   * ```ts\n   * import {KnownDevices} from 'puppeteer';\n   * const iPhone = KnownDevices['iPhone 15 Pro'];\n   *\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   const page = await browser.newPage();\n   *   await page.emulate(iPhone);\n   *   await page.goto('https://www.google.com');\n   *   // other actions...\n   *   await browser.close();\n   * })();\n   * ```\n   */\n  async emulate(device: Device): Promise<void> {\n    await Promise.all([\n      this.setUserAgent(device.userAgent),\n      this.setViewport(device.viewport),\n    ]);\n  }\n\n  /**\n   * @param enabled - Whether or not to enable JavaScript on the page.\n   * @remarks\n   * NOTE: changing this value won't affect scripts that have already been run.\n   * It will take full effect on the next navigation.\n   */\n  abstract setJavaScriptEnabled(enabled: boolean): Promise<void>;\n\n  /**\n   * Toggles bypassing page's Content-Security-Policy.\n   * @param enabled - sets bypassing of page's Content-Security-Policy.\n   * @remarks\n   * NOTE: CSP bypassing happens at the moment of CSP initialization rather than\n   * evaluation. Usually, this means that `page.setBypassCSP` should be called\n   * before navigating to the domain.\n   */\n  abstract setBypassCSP(enabled: boolean): Promise<void>;\n\n  /**\n   * @param type - Changes the CSS media type of the page. The only allowed\n   * values are `screen`, `print` and `null`. Passing `null` disables CSS media\n   * emulation.\n   * @example\n   *\n   * ```ts\n   * await page.evaluate(() => matchMedia('screen').matches);\n   * // → true\n   * await page.evaluate(() => matchMedia('print').matches);\n   * // → false\n   *\n   * await page.emulateMediaType('print');\n   * await page.evaluate(() => matchMedia('screen').matches);\n   * // → false\n   * await page.evaluate(() => matchMedia('print').matches);\n   * // → true\n   *\n   * await page.emulateMediaType(null);\n   * await page.evaluate(() => matchMedia('screen').matches);\n   * // → true\n   * await page.evaluate(() => matchMedia('print').matches);\n   * // → false\n   * ```\n   */\n  abstract emulateMediaType(type?: string): Promise<void>;\n\n  /**\n   * Enables CPU throttling to emulate slow CPUs.\n   * @param factor - slowdown factor (1 is no throttle, 2 is 2x slowdown, etc).\n   */\n  abstract emulateCPUThrottling(factor: number | null): Promise<void>;\n\n  /**\n   * @param features - `<?Array<Object>>` Given an array of media feature\n   * objects, emulates CSS media features on the page. Each media feature object\n   * must have the following properties:\n   * @example\n   *\n   * ```ts\n   * await page.emulateMediaFeatures([\n   *   {name: 'prefers-color-scheme', value: 'dark'},\n   * ]);\n   * await page.evaluate(\n   *   () => matchMedia('(prefers-color-scheme: dark)').matches\n   * );\n   * // → true\n   * await page.evaluate(\n   *   () => matchMedia('(prefers-color-scheme: light)').matches\n   * );\n   * // → false\n   *\n   * await page.emulateMediaFeatures([\n   *   {name: 'prefers-reduced-motion', value: 'reduce'},\n   * ]);\n   * await page.evaluate(\n   *   () => matchMedia('(prefers-reduced-motion: reduce)').matches\n   * );\n   * // → true\n   * await page.evaluate(\n   *   () => matchMedia('(prefers-reduced-motion: no-preference)').matches\n   * );\n   * // → false\n   *\n   * await page.emulateMediaFeatures([\n   *   {name: 'prefers-color-scheme', value: 'dark'},\n   *   {name: 'prefers-reduced-motion', value: 'reduce'},\n   * ]);\n   * await page.evaluate(\n   *   () => matchMedia('(prefers-color-scheme: dark)').matches\n   * );\n   * // → true\n   * await page.evaluate(\n   *   () => matchMedia('(prefers-color-scheme: light)').matches\n   * );\n   * // → false\n   * await page.evaluate(\n   *   () => matchMedia('(prefers-reduced-motion: reduce)').matches\n   * );\n   * // → true\n   * await page.evaluate(\n   *   () => matchMedia('(prefers-reduced-motion: no-preference)').matches\n   * );\n   * // → false\n   *\n   * await page.emulateMediaFeatures([{name: 'color-gamut', value: 'p3'}]);\n   * await page.evaluate(() => matchMedia('(color-gamut: srgb)').matches);\n   * // → true\n   * await page.evaluate(() => matchMedia('(color-gamut: p3)').matches);\n   * // → true\n   * await page.evaluate(() => matchMedia('(color-gamut: rec2020)').matches);\n   * // → false\n   * ```\n   */\n  abstract emulateMediaFeatures(features?: MediaFeature[]): Promise<void>;\n\n  /**\n   * @param timezoneId - Changes the timezone of the page. See\n   * {@link https://source.chromium.org/chromium/chromium/deps/icu.git/+/faee8bc70570192d82d2978a71e2a615788597d1:source/data/misc/metaZones.txt | ICU’s metaZones.txt}\n   * for a list of supported timezone IDs. Passing\n   * `null` disables timezone emulation.\n   */\n  abstract emulateTimezone(timezoneId?: string): Promise<void>;\n\n  /**\n   * Emulates the idle state.\n   * If no arguments set, clears idle state emulation.\n   *\n   * @example\n   *\n   * ```ts\n   * // set idle emulation\n   * await page.emulateIdleState({isUserActive: true, isScreenUnlocked: false});\n   *\n   * // do some checks here\n   * ...\n   *\n   * // clear idle emulation\n   * await page.emulateIdleState();\n   * ```\n   *\n   * @param overrides - Mock idle state. If not set, clears idle overrides\n   */\n  abstract emulateIdleState(overrides?: {\n    isUserActive: boolean;\n    isScreenUnlocked: boolean;\n  }): Promise<void>;\n\n  /**\n   * Simulates the given vision deficiency on the page.\n   *\n   * @example\n   *\n   * ```ts\n   * import puppeteer from 'puppeteer';\n   *\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   const page = await browser.newPage();\n   *   await page.goto('https://v8.dev/blog/10-years');\n   *\n   *   await page.emulateVisionDeficiency('achromatopsia');\n   *   await page.screenshot({path: 'achromatopsia.png'});\n   *\n   *   await page.emulateVisionDeficiency('deuteranopia');\n   *   await page.screenshot({path: 'deuteranopia.png'});\n   *\n   *   await page.emulateVisionDeficiency('blurredVision');\n   *   await page.screenshot({path: 'blurred-vision.png'});\n   *\n   *   await browser.close();\n   * })();\n   * ```\n   *\n   * @param type - the type of deficiency to simulate, or `'none'` to reset.\n   */\n  abstract emulateVisionDeficiency(\n    type?: Protocol.Emulation.SetEmulatedVisionDeficiencyRequest['type']\n  ): Promise<void>;\n\n  /**\n   * `page.setViewport` will resize the page. A lot of websites don't expect\n   * phones to change size, so you should set the viewport before navigating to\n   * the page.\n   *\n   * In the case of multiple pages in a single browser, each page can have its\n   * own viewport size. Setting the viewport to `null` resets the viewport to\n   * its default value.\n   *\n   * @example\n   *\n   * ```ts\n   * const page = await browser.newPage();\n   * await page.setViewport({\n   *   width: 640,\n   *   height: 480,\n   *   deviceScaleFactor: 1,\n   * });\n   * await page.goto('https://example.com');\n   * ```\n   *\n   * @param viewport -\n   * @remarks\n   * NOTE: in certain cases, setting viewport will reload the page in order to\n   * set the isMobile or hasTouch properties.\n   */\n  abstract setViewport(viewport: Viewport | null): Promise<void>;\n\n  /**\n   * Returns the current page viewport settings without checking the actual page\n   * viewport.\n   *\n   * This is either the viewport set with the previous {@link Page.setViewport}\n   * call or the default viewport set via\n   * {@link BrowserConnectOptions.defaultViewport |\n   * BrowserConnectOptions.defaultViewport}.\n   */\n  abstract viewport(): Viewport | null;\n\n  /**\n   * Evaluates a function in the page's context and returns the result.\n   *\n   * If the function passed to `page.evaluate` returns a Promise, the\n   * function will wait for the promise to resolve and return its value.\n   *\n   * @example\n   *\n   * ```ts\n   * const result = await frame.evaluate(() => {\n   *   return Promise.resolve(8 * 7);\n   * });\n   * console.log(result); // prints \"56\"\n   * ```\n   *\n   * You can pass a string instead of a function (although functions are\n   * recommended as they are easier to debug and use with TypeScript):\n   *\n   * @example\n   *\n   * ```ts\n   * const aHandle = await page.evaluate('1 + 2');\n   * ```\n   *\n   * To get the best TypeScript experience, you should pass in as the\n   * generic the type of `pageFunction`:\n   *\n   * ```ts\n   * const aHandle = await page.evaluate(() => 2);\n   * ```\n   *\n   * @example\n   *\n   * {@link ElementHandle} instances (including {@link JSHandle}s) can be passed\n   * as arguments to the `pageFunction`:\n   *\n   * ```ts\n   * const bodyHandle = await page.$('body');\n   * const html = await page.evaluate(body => body.innerHTML, bodyHandle);\n   * await bodyHandle.dispose();\n   * ```\n   *\n   * @param pageFunction - a function that is run within the page\n   * @param args - arguments to be passed to the pageFunction\n   *\n   * @returns the return value of `pageFunction`.\n   */\n  async evaluate<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<Awaited<ReturnType<Func>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(\n      this.evaluate.name,\n      pageFunction\n    );\n    return await this.mainFrame().evaluate(pageFunction, ...args);\n  }\n\n  /**\n   * Adds a function which would be invoked in one of the following scenarios:\n   *\n   * - whenever the page is navigated\n   *\n   * - whenever the child frame is attached or navigated. In this case, the\n   *   function is invoked in the context of the newly attached frame.\n   *\n   * The function is invoked after the document was created but before any of\n   * its scripts were run. This is useful to amend the JavaScript environment,\n   * e.g. to seed `Math.random`.\n   * @param pageFunction - Function to be evaluated in browser context\n   * @param args - Arguments to pass to `pageFunction`\n   * @example\n   * An example of overriding the navigator.languages property before the page loads:\n   *\n   * ```ts\n   * // preload.js\n   *\n   * // overwrite the `languages` property to use a custom getter\n   * Object.defineProperty(navigator, 'languages', {\n   *   get: function () {\n   *     return ['en-US', 'en', 'bn'];\n   *   },\n   * });\n   *\n   * // In your puppeteer script, assuming the preload.js file is\n   * // in same folder of our script.\n   * const preloadFile = fs.readFileSync('./preload.js', 'utf8');\n   * await page.evaluateOnNewDocument(preloadFile);\n   * ```\n   */\n  abstract evaluateOnNewDocument<\n    Params extends unknown[],\n    Func extends (...args: Params) => unknown = (...args: Params) => unknown,\n  >(\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<NewDocumentScriptEvaluation>;\n\n  /**\n   * Removes script that injected into page by Page.evaluateOnNewDocument.\n   *\n   * @param identifier - script identifier\n   */\n  abstract removeScriptToEvaluateOnNewDocument(\n    identifier: string\n  ): Promise<void>;\n\n  /**\n   * Toggles ignoring cache for each request based on the enabled state. By\n   * default, caching is enabled.\n   * @param enabled - sets the `enabled` state of cache\n   * @defaultValue `true`\n   */\n  abstract setCacheEnabled(enabled?: boolean): Promise<void>;\n\n  /**\n   * @internal\n   */\n  async _maybeWriteTypedArrayToFile(\n    path: string | undefined,\n    typedArray: Uint8Array\n  ): Promise<void> {\n    if (!path) {\n      return;\n    }\n\n    await environment.value.fs.promises.writeFile(path, typedArray);\n  }\n\n  /**\n   * Captures a screencast of this {@link Page | page}.\n   *\n   * @example\n   * Recording a {@link Page | page}:\n   *\n   * ```\n   * import puppeteer from 'puppeteer';\n   *\n   * // Launch a browser\n   * const browser = await puppeteer.launch();\n   *\n   * // Create a new page\n   * const page = await browser.newPage();\n   *\n   * // Go to your site.\n   * await page.goto(\"https://www.example.com\");\n   *\n   * // Start recording.\n   * const recorder = await page.screencast({path: 'recording.webm'});\n   *\n   * // Do something.\n   *\n   * // Stop recording.\n   * await recorder.stop();\n   *\n   * browser.close();\n   * ```\n   *\n   * @param options - Configures screencast behavior.\n   *\n   * @experimental\n   *\n   * @remarks\n   *\n   * All recordings will be {@link https://www.webmproject.org/ | WebM} format using\n   * the {@link https://www.webmproject.org/vp9/ | VP9} video codec. The FPS is 30.\n   *\n   * You must have {@link https://ffmpeg.org/ | ffmpeg} installed on your system.\n   */\n  async screencast(\n    options: Readonly<ScreencastOptions> = {}\n  ): Promise<ScreenRecorder> {\n    const ScreenRecorder = environment.value.ScreenRecorder;\n    const [width, height, devicePixelRatio] =\n      await this.#getNativePixelDimensions();\n    let crop: BoundingBox | undefined;\n    if (options.crop) {\n      const {\n        x,\n        y,\n        width: cropWidth,\n        height: cropHeight,\n      } = roundRectangle(normalizeRectangle(options.crop));\n      if (x < 0 || y < 0) {\n        throw new Error(\n          `\\`crop.x\\` and \\`crop.y\\` must be greater than or equal to 0.`\n        );\n      }\n      if (cropWidth <= 0 || cropHeight <= 0) {\n        throw new Error(\n          `\\`crop.height\\` and \\`crop.width\\` must be greater than or equal to 0.`\n        );\n      }\n\n      const viewportWidth = width / devicePixelRatio;\n      const viewportHeight = height / devicePixelRatio;\n      if (x + cropWidth > viewportWidth) {\n        throw new Error(\n          `\\`crop.width\\` cannot be larger than the viewport width (${viewportWidth}).`\n        );\n      }\n      if (y + cropHeight > viewportHeight) {\n        throw new Error(\n          `\\`crop.height\\` cannot be larger than the viewport height (${viewportHeight}).`\n        );\n      }\n\n      crop = {\n        x: x * devicePixelRatio,\n        y: y * devicePixelRatio,\n        width: cropWidth * devicePixelRatio,\n        height: cropHeight * devicePixelRatio,\n      };\n    }\n    if (options.speed !== undefined && options.speed <= 0) {\n      throw new Error(`\\`speed\\` must be greater than 0.`);\n    }\n    if (options.scale !== undefined && options.scale <= 0) {\n      throw new Error(`\\`scale\\` must be greater than 0.`);\n    }\n\n    const recorder = new ScreenRecorder(this, width, height, {\n      ...options,\n      path: options.ffmpegPath,\n      crop,\n    });\n    try {\n      await this._startScreencast();\n    } catch (error) {\n      void recorder.stop();\n      throw error;\n    }\n    if (options.path) {\n      const {createWriteStream} = environment.value.fs;\n      const stream = createWriteStream(options.path, 'binary');\n      recorder.pipe(stream);\n    }\n    return recorder;\n  }\n\n  #screencastSessionCount = 0;\n  #startScreencastPromise: Promise<void> | undefined;\n\n  /**\n   * @internal\n   */\n  async _startScreencast(): Promise<void> {\n    ++this.#screencastSessionCount;\n    if (!this.#startScreencastPromise) {\n      this.#startScreencastPromise = this.mainFrame()\n        .client.send('Page.startScreencast', {format: 'png'})\n        .then(() => {\n          // Wait for the first frame.\n          return new Promise(resolve => {\n            return this.mainFrame().client.once('Page.screencastFrame', () => {\n              return resolve();\n            });\n          });\n        });\n    }\n    await this.#startScreencastPromise;\n  }\n\n  /**\n   * @internal\n   */\n  async _stopScreencast(): Promise<void> {\n    --this.#screencastSessionCount;\n    if (!this.#startScreencastPromise) {\n      return;\n    }\n    this.#startScreencastPromise = undefined;\n    if (this.#screencastSessionCount === 0) {\n      await this.mainFrame().client.send('Page.stopScreencast');\n    }\n  }\n\n  /**\n   * Gets the native, non-emulated dimensions of the viewport.\n   */\n  async #getNativePixelDimensions(): Promise<\n    readonly [width: number, height: number, devicePixelRatio: number]\n  > {\n    const viewport = this.viewport();\n    using stack = new DisposableStack();\n    if (viewport && viewport.deviceScaleFactor !== 0) {\n      await this.setViewport({...viewport, deviceScaleFactor: 0});\n      stack.defer(() => {\n        void this.setViewport(viewport).catch(debugError);\n      });\n    }\n    return await this.mainFrame()\n      .isolatedRealm()\n      .evaluate(() => {\n        return [\n          window.visualViewport!.width * window.devicePixelRatio,\n          window.visualViewport!.height * window.devicePixelRatio,\n          window.devicePixelRatio,\n        ] as const;\n      });\n  }\n\n  /**\n   * Captures a screenshot of this {@link Page | page}.\n   *\n   * @param options - Configures screenshot behavior.\n   *\n   * @remarks\n   *\n   * While a screenshot is being taken in a {@link BrowserContext}, the\n   * following methods will automatically wait for the screenshot to\n   * finish to prevent interference with the screenshot process:\n   * {@link BrowserContext.newPage}, {@link Browser.newPage},\n   * {@link Page.close}.\n   *\n   * Calling {@link Page.bringToFront} will not wait for existing\n   * screenshot operations.\n   *\n   */\n  async screenshot(\n    options: Readonly<ScreenshotOptions> & {encoding: 'base64'}\n  ): Promise<string>;\n  async screenshot(options?: Readonly<ScreenshotOptions>): Promise<Uint8Array>;\n  @guarded(function () {\n    return this.browser();\n  })\n  async screenshot(\n    userOptions: Readonly<ScreenshotOptions> = {}\n  ): Promise<Uint8Array | string> {\n    using _guard = await this.browserContext().startScreenshot();\n\n    await this.bringToFront();\n\n    // TODO: use structuredClone after Node 16 support is dropped.\n    const options = {\n      ...userOptions,\n      clip: userOptions.clip\n        ? {\n            ...userOptions.clip,\n          }\n        : undefined,\n    };\n    if (options.type === undefined && options.path !== undefined) {\n      const filePath = options.path;\n      // Note we cannot use Node.js here due to browser compatibility.\n      const extension = filePath\n        .slice(filePath.lastIndexOf('.') + 1)\n        .toLowerCase();\n      switch (extension) {\n        case 'png':\n          options.type = 'png';\n          break;\n        case 'jpeg':\n        case 'jpg':\n          options.type = 'jpeg';\n          break;\n        case 'webp':\n          options.type = 'webp';\n          break;\n      }\n    }\n    if (options.quality !== undefined) {\n      if (options.quality < 0 || options.quality > 100) {\n        throw new Error(\n          `Expected 'quality' (${options.quality}) to be between 0 and 100, inclusive.`\n        );\n      }\n      if (\n        options.type === undefined ||\n        !['jpeg', 'webp'].includes(options.type)\n      ) {\n        throw new Error(\n          `${options.type ?? 'png'} screenshots do not support 'quality'.`\n        );\n      }\n    }\n    if (options.clip) {\n      if (options.clip.width <= 0) {\n        throw new Error(\"'width' in 'clip' must be positive.\");\n      }\n      if (options.clip.height <= 0) {\n        throw new Error(\"'height' in 'clip' must be positive.\");\n      }\n    }\n\n    setDefaultScreenshotOptions(options);\n\n    await using stack = new AsyncDisposableStack();\n    if (options.clip) {\n      if (options.fullPage) {\n        throw new Error(\"'clip' and 'fullPage' are mutually exclusive\");\n      }\n\n      options.clip = roundRectangle(normalizeRectangle(options.clip));\n    } else {\n      if (options.fullPage) {\n        // If `captureBeyondViewport` is `false`, then we set the viewport to\n        // capture the full page. Note this may be affected by on-page CSS and\n        // JavaScript.\n        if (!options.captureBeyondViewport) {\n          const scrollDimensions = await this.mainFrame()\n            .isolatedRealm()\n            .evaluate(() => {\n              const element = document.documentElement;\n              return {\n                width: element.scrollWidth,\n                height: element.scrollHeight,\n              };\n            });\n          const viewport = this.viewport();\n          await this.setViewport({\n            ...viewport,\n            ...scrollDimensions,\n          });\n          stack.defer(async () => {\n            await this.setViewport(viewport).catch(debugError);\n          });\n        }\n      } else {\n        options.captureBeyondViewport = false;\n      }\n    }\n\n    const data = await this._screenshot(options);\n    if (options.encoding === 'base64') {\n      return data;\n    }\n\n    const typedArray = stringToTypedArray(data, true);\n    await this._maybeWriteTypedArrayToFile(options.path, typedArray);\n    return typedArray;\n  }\n\n  /**\n   * @internal\n   */\n  abstract _screenshot(options: Readonly<ScreenshotOptions>): Promise<string>;\n\n  /**\n   * Generates a PDF of the page with the `print` CSS media type.\n   *\n   * @param options - options for generating the PDF.\n   *\n   * @remarks\n   *\n   * To generate a PDF with the `screen` media type, call\n   * {@link Page.emulateMediaType | `page.emulateMediaType('screen')`} before\n   * calling `page.pdf()`.\n   *\n   * By default, `page.pdf()` generates a pdf with modified colors for printing.\n   * Use the\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-print-color-adjust | `-webkit-print-color-adjust`}\n   * property to force rendering of exact colors.\n   */\n  abstract createPDFStream(\n    options?: PDFOptions\n  ): Promise<ReadableStream<Uint8Array>>;\n\n  /**\n   * {@inheritDoc Page.createPDFStream}\n   */\n  abstract pdf(options?: PDFOptions): Promise<Uint8Array>;\n\n  /**\n   * The page's title\n   *\n   * @remarks\n   *\n   * Shortcut for {@link Frame.title | page.mainFrame().title()}.\n   */\n  async title(): Promise<string> {\n    return await this.mainFrame().title();\n  }\n\n  abstract close(options?: {runBeforeUnload?: boolean}): Promise<void>;\n\n  /**\n   * Indicates that the page has been closed.\n   * @returns\n   */\n  abstract isClosed(): boolean;\n\n  /**\n   * {@inheritDoc Mouse}\n   */\n  abstract get mouse(): Mouse;\n\n  /**\n   * This method fetches an element with `selector`, scrolls it into view if\n   * needed, and then uses {@link Page.mouse} to click in the center of the\n   * element. If there's no element matching `selector`, the method throws an\n   * error.\n   *\n   * @remarks\n   *\n   * Bear in mind that if `click()` triggers a navigation event and\n   * there's a separate `page.waitForNavigation()` promise to be resolved, you\n   * may end up with a race condition that yields unexpected results. The\n   * correct pattern for click and wait for navigation is the following:\n   *\n   * ```ts\n   * const [response] = await Promise.all([\n   *   page.waitForNavigation(waitOptions),\n   *   page.click(selector, clickOptions),\n   * ]);\n   * ```\n   *\n   * Shortcut for {@link Frame.click | page.mainFrame().click(selector[, options]) }.\n   * @param selector -\n   * {@link https://pptr.dev/guides/page-interactions#selectors | selector}\n   * to query the page for.\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}\n   * can be passed as-is and a\n   * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}\n   * allows quering by\n   * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},\n   * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},\n   * and\n   * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}\n   * and\n   * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.\n   * Alternatively, you can specify the selector type using a\n   * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}. If there are\n   * multiple elements satisfying the `selector`, the first will be clicked\n   * @param options - `Object`\n   * @returns Promise which resolves when the element matching `selector` is\n   * successfully clicked. The Promise will be rejected if there is no element\n   * matching `selector`.\n   */\n  click(selector: string, options?: Readonly<ClickOptions>): Promise<void> {\n    return this.mainFrame().click(selector, options);\n  }\n\n  /**\n   * This method fetches an element with `selector` and focuses it. If\n   * there's no element matching `selector`, the method throws an error.\n   * @param selector -\n   * {@link https://pptr.dev/guides/page-interactions#selectors | selector}\n   * to query the page for.\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}\n   * can be passed as-is and a\n   * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}\n   * allows quering by\n   * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},\n   * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},\n   * and\n   * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}\n   * and\n   * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.\n   * Alternatively, you can specify the selector type using a\n   * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.\n   * If there are multiple elements satisfying the selector, the first\n   * will be focused.\n   * @returns Promise which resolves when the element matching selector\n   * is successfully focused. The promise will be rejected if there is\n   * no element matching selector.\n   *\n   * @remarks\n   *\n   * Shortcut for\n   * {@link Frame.focus | page.mainFrame().focus(selector)}.\n   */\n  focus(selector: string): Promise<void> {\n    return this.mainFrame().focus(selector);\n  }\n\n  /**\n   * This method fetches an element with `selector`, scrolls it into view if\n   * needed, and then uses {@link Page.mouse}\n   * to hover over the center of the element.\n   * If there's no element matching `selector`, the method throws an error.\n   * @param selector -\n   * {@link https://pptr.dev/guides/page-interactions#selectors | selector}\n   * to query the page for.\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}\n   * can be passed as-is and a\n   * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}\n   * allows quering by\n   * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},\n   * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},\n   * and\n   * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}\n   * and\n   * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.\n   * Alternatively, you can specify the selector type using a\n   * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}. If there are\n   * multiple elements satisfying the `selector`, the first will be hovered.\n   * @returns Promise which resolves when the element matching `selector` is\n   * successfully hovered. Promise gets rejected if there's no element matching\n   * `selector`.\n   *\n   * @remarks\n   *\n   * Shortcut for {@link Page.hover | page.mainFrame().hover(selector)}.\n   */\n  hover(selector: string): Promise<void> {\n    return this.mainFrame().hover(selector);\n  }\n\n  /**\n   * Triggers a `change` and `input` event once all the provided options have been\n   * selected. If there's no `<select>` element matching `selector`, the method\n   * throws an error.\n   *\n   * @example\n   *\n   * ```ts\n   * page.select('select#colors', 'blue'); // single selection\n   * page.select('select#colors', 'red', 'green', 'blue'); // multiple selections\n   * ```\n   *\n   * @param selector -\n   * {@link https://pptr.dev/guides/page-interactions#selectors | selector}\n   * to query the page for.\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}\n   * can be passed as-is and a\n   * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}\n   * allows quering by\n   * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},\n   * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},\n   * and\n   * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}\n   * and\n   * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.\n   * Alternatively, you can specify the selector type using a\n   * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.\n   * @param values - Values of options to select. If the `<select>` has the\n   * `multiple` attribute, all values are considered, otherwise only the first one\n   * is taken into account.\n   * @returns\n   *\n   * @remarks\n   *\n   * Shortcut for {@link Frame.select | page.mainFrame().select()}\n   */\n  select(selector: string, ...values: string[]): Promise<string[]> {\n    return this.mainFrame().select(selector, ...values);\n  }\n\n  /**\n   * This method fetches an element with `selector`, scrolls it into view if\n   * needed, and then uses {@link Page.touchscreen}\n   * to tap in the center of the element.\n   * If there's no element matching `selector`, the method throws an error.\n   * @param selector -\n   * {@link https://pptr.dev/guides/page-interactions#selectors | selector}\n   * to query the page for.\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}\n   * can be passed as-is and a\n   * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}\n   * allows quering by\n   * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},\n   * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},\n   * and\n   * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}\n   * and\n   * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.\n   * Alternatively, you can specify the selector type using a\n   * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}. If there are multiple elements satisfying the\n   * selector, the first will be tapped.\n   *\n   * @remarks\n   *\n   * Shortcut for {@link Frame.tap | page.mainFrame().tap(selector)}.\n   */\n  tap(selector: string): Promise<void> {\n    return this.mainFrame().tap(selector);\n  }\n\n  /**\n   * Sends a `keydown`, `keypress/input`, and `keyup` event for each character\n   * in the text.\n   *\n   * To press a special key, like `Control` or `ArrowDown`, use {@link Keyboard.press}.\n   * @example\n   *\n   * ```ts\n   * await page.type('#mytextarea', 'Hello');\n   * // Types instantly\n   * await page.type('#mytextarea', 'World', {delay: 100});\n   * // Types slower, like a user\n   * ```\n   *\n   * @param selector -\n   * {@link https://pptr.dev/guides/page-interactions#selectors | selector}\n   * to query the page for.\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}\n   * can be passed as-is and a\n   * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}\n   * allows quering by\n   * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},\n   * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},\n   * and\n   * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}\n   * and\n   * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.\n   * Alternatively, you can specify the selector type using a\n   * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.\n   * @param text - A text to type into a focused element.\n   * @param options - have property `delay` which is the Time to wait between\n   * key presses in milliseconds. Defaults to `0`.\n   * @returns\n   */\n  type(\n    selector: string,\n    text: string,\n    options?: Readonly<KeyboardTypeOptions>\n  ): Promise<void> {\n    return this.mainFrame().type(selector, text, options);\n  }\n\n  /**\n   * Wait for the `selector` to appear in page. If at the moment of calling the\n   * method the `selector` already exists, the method will return immediately. If\n   * the `selector` doesn't appear after the `timeout` milliseconds of waiting, the\n   * function will throw.\n   *\n   * @example\n   * This method works across navigations:\n   *\n   * ```ts\n   * import puppeteer from 'puppeteer';\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   const page = await browser.newPage();\n   *   let currentURL;\n   *   page\n   *     .waitForSelector('img')\n   *     .then(() => console.log('First URL with image: ' + currentURL));\n   *   for (currentURL of [\n   *     'https://example.com',\n   *     'https://google.com',\n   *     'https://bbc.com',\n   *   ]) {\n   *     await page.goto(currentURL);\n   *   }\n   *   await browser.close();\n   * })();\n   * ```\n   *\n   * @param selector -\n   * {@link https://pptr.dev/guides/page-interactions#selectors | selector}\n   * to query the page for.\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}\n   * can be passed as-is and a\n   * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}\n   * allows quering by\n   * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},\n   * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},\n   * and\n   * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}\n   * and\n   * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.\n   * Alternatively, you can specify the selector type using a\n   * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.\n   * @param options - Optional waiting parameters\n   * @returns Promise which resolves when element specified by selector string\n   * is added to DOM. Resolves to `null` if waiting for hidden: `true` and\n   * selector is not found in DOM.\n   *\n   * @remarks\n   * The optional Parameter in Arguments `options` are:\n   *\n   * - `visible`: A boolean wait for element to be present in DOM and to be\n   *   visible, i.e. to not have `display: none` or `visibility: hidden` CSS\n   *   properties. Defaults to `false`.\n   *\n   * - `hidden`: Wait for element to not be found in the DOM or to be hidden,\n   *   i.e. have `display: none` or `visibility: hidden` CSS properties. Defaults to\n   *   `false`.\n   *\n   * - `timeout`: maximum time to wait for in milliseconds. Defaults to `30000`\n   *   (30 seconds). Pass `0` to disable timeout. The default value can be changed\n   *   by using the {@link Page.setDefaultTimeout} method.\n   */\n  async waitForSelector<Selector extends string>(\n    selector: Selector,\n    options: WaitForSelectorOptions = {}\n  ): Promise<ElementHandle<NodeFor<Selector>> | null> {\n    return await this.mainFrame().waitForSelector(selector, options);\n  }\n\n  /**\n   * Waits for the provided function, `pageFunction`, to return a truthy value when\n   * evaluated in the page's context.\n   *\n   * @example\n   * {@link Page.waitForFunction} can be used to observe a viewport size change:\n   *\n   * ```ts\n   * import puppeteer from 'puppeteer';\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   const page = await browser.newPage();\n   *   const watchDog = page.waitForFunction('window.innerWidth < 100');\n   *   await page.setViewport({width: 50, height: 50});\n   *   await watchDog;\n   *   await browser.close();\n   * })();\n   * ```\n   *\n   * @example\n   * Arguments can be passed from Node.js to `pageFunction`:\n   *\n   * ```ts\n   * const selector = '.foo';\n   * await page.waitForFunction(\n   *   selector => !!document.querySelector(selector),\n   *   {},\n   *   selector\n   * );\n   * ```\n   *\n   * @example\n   * The provided `pageFunction` can be asynchronous:\n   *\n   * ```ts\n   * const username = 'github-username';\n   * await page.waitForFunction(\n   *   async username => {\n   *     const githubResponse = await fetch(\n   *       `https://api.github.com/users/${username}`\n   *     );\n   *     const githubUser = await githubResponse.json();\n   *     // show the avatar\n   *     const img = document.createElement('img');\n   *     img.src = githubUser.avatar_url;\n   *     // wait 3 seconds\n   *     await new Promise((resolve, reject) => setTimeout(resolve, 3000));\n   *     img.remove();\n   *   },\n   *   {},\n   *   username\n   * );\n   * ```\n   *\n   * @param pageFunction - Function to be evaluated in browser context until it returns a\n   * truthy value.\n   * @param options - Options for configuring waiting behavior.\n   */\n  waitForFunction<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(\n    pageFunction: Func | string,\n    options?: FrameWaitForFunctionOptions,\n    ...args: Params\n  ): Promise<HandleFor<Awaited<ReturnType<Func>>>> {\n    return this.mainFrame().waitForFunction(pageFunction, options, ...args);\n  }\n\n  /**\n   * This method is typically coupled with an action that triggers a device\n   * request from an api such as WebBluetooth.\n   *\n   * :::caution\n   *\n   * This must be called before the device request is made. It will not return a\n   * currently active device prompt.\n   *\n   * :::\n   *\n   * @example\n   *\n   * ```ts\n   * const [devicePrompt] = Promise.all([\n   *   page.waitForDevicePrompt(),\n   *   page.click('#connect-bluetooth'),\n   * ]);\n   * await devicePrompt.select(\n   *   await devicePrompt.waitForDevice(({name}) => name.includes('My Device'))\n   * );\n   * ```\n   */\n  abstract waitForDevicePrompt(\n    options?: WaitTimeoutOptions\n  ): Promise<DeviceRequestPrompt>;\n\n  /** @internal */\n  [disposeSymbol](): void {\n    return void this.close().catch(debugError);\n  }\n\n  /** @internal */\n  [asyncDisposeSymbol](): Promise<void> {\n    return this.close();\n  }\n}\n\n/**\n * @internal\n */\nexport const supportedMetrics = new Set<string>([\n  'Timestamp',\n  'Documents',\n  'Frames',\n  'JSEventListeners',\n  'Nodes',\n  'LayoutCount',\n  'RecalcStyleCount',\n  'LayoutDuration',\n  'RecalcStyleDuration',\n  'ScriptDuration',\n  'TaskDuration',\n  'JSHeapUsedSize',\n  'JSHeapTotalSize',\n]);\n\n/** @see https://w3c.github.io/webdriver-bidi/#normalize-rect */\nfunction normalizeRectangle<BoundingBoxType extends BoundingBox>(\n  clip: Readonly<BoundingBoxType>\n): BoundingBoxType {\n  return {\n    ...clip,\n    ...(clip.width < 0\n      ? {\n          x: clip.x + clip.width,\n          width: -clip.width,\n        }\n      : {\n          x: clip.x,\n          width: clip.width,\n        }),\n    ...(clip.height < 0\n      ? {\n          y: clip.y + clip.height,\n          height: -clip.height,\n        }\n      : {\n          y: clip.y,\n          height: clip.height,\n        }),\n  };\n}\n\nfunction roundRectangle<BoundingBoxType extends BoundingBox>(\n  clip: Readonly<BoundingBoxType>\n): BoundingBoxType {\n  const x = Math.round(clip.x);\n  const y = Math.round(clip.y);\n  const width = Math.round(clip.width + clip.x - x);\n  const height = Math.round(clip.height + clip.y - y);\n  return {...clip, x, y, width, height};\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}