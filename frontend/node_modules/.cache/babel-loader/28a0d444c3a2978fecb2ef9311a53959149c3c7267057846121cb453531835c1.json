{"ast":null,"code":"/**\n * @license\n * Copyright 2017 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { EventEmitter } from '../common/EventEmitter.js';\nimport { debugError, PuppeteerURL } from '../common/util.js';\nimport { assert } from '../util/assert.js';\nimport { DisposableStack } from '../util/disposable.js';\n/**\n * The Coverage class provides methods to gather information about parts of\n * JavaScript and CSS that were used by the page.\n *\n * @remarks\n * To output coverage in a form consumable by {@link https://github.com/istanbuljs | Istanbul},\n * see {@link https://github.com/istanbuljs/puppeteer-to-istanbul | puppeteer-to-istanbul}.\n *\n * @example\n * An example of using JavaScript and CSS coverage to get percentage of initially\n * executed code:\n *\n * ```ts\n * // Enable both JavaScript and CSS coverage\n * await Promise.all([\n *   page.coverage.startJSCoverage(),\n *   page.coverage.startCSSCoverage(),\n * ]);\n * // Navigate to page\n * await page.goto('https://example.com');\n * // Disable both JavaScript and CSS coverage\n * const [jsCoverage, cssCoverage] = await Promise.all([\n *   page.coverage.stopJSCoverage(),\n *   page.coverage.stopCSSCoverage(),\n * ]);\n * let totalBytes = 0;\n * let usedBytes = 0;\n * const coverage = [...jsCoverage, ...cssCoverage];\n * for (const entry of coverage) {\n *   totalBytes += entry.text.length;\n *   for (const range of entry.ranges) usedBytes += range.end - range.start - 1;\n * }\n * console.log(`Bytes used: ${(usedBytes / totalBytes) * 100}%`);\n * ```\n *\n * @public\n */\nexport class Coverage {\n  #jsCoverage;\n  #cssCoverage;\n  /**\n   * @internal\n   */\n  constructor(client) {\n    this.#jsCoverage = new JSCoverage(client);\n    this.#cssCoverage = new CSSCoverage(client);\n  }\n  /**\n   * @internal\n   */\n  updateClient(client) {\n    this.#jsCoverage.updateClient(client);\n    this.#cssCoverage.updateClient(client);\n  }\n  /**\n   * @param options - Set of configurable options for coverage defaults to\n   * `resetOnNavigation : true, reportAnonymousScripts : false,`\n   * `includeRawScriptCoverage : false, useBlockCoverage : true`\n   * @returns Promise that resolves when coverage is started.\n   *\n   * @remarks\n   * Anonymous scripts are ones that don't have an associated url. These are\n   * scripts that are dynamically created on the page using `eval` or\n   * `new Function`. If `reportAnonymousScripts` is set to `true`, anonymous\n   * scripts URL will start with `debugger://VM` (unless a magic //# sourceURL\n   * comment is present, in which case that will the be URL).\n   */\n  async startJSCoverage(options = {}) {\n    return await this.#jsCoverage.start(options);\n  }\n  /**\n   * Promise that resolves to the array of coverage reports for\n   * all scripts.\n   *\n   * @remarks\n   * JavaScript Coverage doesn't include anonymous scripts by default.\n   * However, scripts with sourceURLs are reported.\n   */\n  async stopJSCoverage() {\n    return await this.#jsCoverage.stop();\n  }\n  /**\n   * @param options - Set of configurable options for coverage, defaults to\n   * `resetOnNavigation : true`\n   * @returns Promise that resolves when coverage is started.\n   */\n  async startCSSCoverage(options = {}) {\n    return await this.#cssCoverage.start(options);\n  }\n  /**\n   * Promise that resolves to the array of coverage reports\n   * for all stylesheets.\n   *\n   * @remarks\n   * CSS Coverage doesn't include dynamically injected style tags\n   * without sourceURLs.\n   */\n  async stopCSSCoverage() {\n    return await this.#cssCoverage.stop();\n  }\n}\n/**\n * @public\n */\nexport class JSCoverage {\n  #client;\n  #enabled = false;\n  #scriptURLs = new Map();\n  #scriptSources = new Map();\n  #subscriptions;\n  #resetOnNavigation = false;\n  #reportAnonymousScripts = false;\n  #includeRawScriptCoverage = false;\n  /**\n   * @internal\n   */\n  constructor(client) {\n    this.#client = client;\n  }\n  /**\n   * @internal\n   */\n  updateClient(client) {\n    this.#client = client;\n  }\n  async start(options = {}) {\n    assert(!this.#enabled, 'JSCoverage is already enabled');\n    const {\n      resetOnNavigation = true,\n      reportAnonymousScripts = false,\n      includeRawScriptCoverage = false,\n      useBlockCoverage = true\n    } = options;\n    this.#resetOnNavigation = resetOnNavigation;\n    this.#reportAnonymousScripts = reportAnonymousScripts;\n    this.#includeRawScriptCoverage = includeRawScriptCoverage;\n    this.#enabled = true;\n    this.#scriptURLs.clear();\n    this.#scriptSources.clear();\n    this.#subscriptions = new DisposableStack();\n    const clientEmitter = this.#subscriptions.use(new EventEmitter(this.#client));\n    clientEmitter.on('Debugger.scriptParsed', this.#onScriptParsed.bind(this));\n    clientEmitter.on('Runtime.executionContextsCleared', this.#onExecutionContextsCleared.bind(this));\n    await Promise.all([this.#client.send('Profiler.enable'), this.#client.send('Profiler.startPreciseCoverage', {\n      callCount: this.#includeRawScriptCoverage,\n      detailed: useBlockCoverage\n    }), this.#client.send('Debugger.enable'), this.#client.send('Debugger.setSkipAllPauses', {\n      skip: true\n    })]);\n  }\n  #onExecutionContextsCleared() {\n    if (!this.#resetOnNavigation) {\n      return;\n    }\n    this.#scriptURLs.clear();\n    this.#scriptSources.clear();\n  }\n  async #onScriptParsed(event) {\n    // Ignore puppeteer-injected scripts\n    if (PuppeteerURL.isPuppeteerURL(event.url)) {\n      return;\n    }\n    // Ignore other anonymous scripts unless the reportAnonymousScripts option is true.\n    if (!event.url && !this.#reportAnonymousScripts) {\n      return;\n    }\n    try {\n      const response = await this.#client.send('Debugger.getScriptSource', {\n        scriptId: event.scriptId\n      });\n      this.#scriptURLs.set(event.scriptId, event.url);\n      this.#scriptSources.set(event.scriptId, response.scriptSource);\n    } catch (error) {\n      // This might happen if the page has already navigated away.\n      debugError(error);\n    }\n  }\n  async stop() {\n    assert(this.#enabled, 'JSCoverage is not enabled');\n    this.#enabled = false;\n    const result = await Promise.all([this.#client.send('Profiler.takePreciseCoverage'), this.#client.send('Profiler.stopPreciseCoverage'), this.#client.send('Profiler.disable'), this.#client.send('Debugger.disable')]);\n    this.#subscriptions?.dispose();\n    const coverage = [];\n    const profileResponse = result[0];\n    for (const entry of profileResponse.result) {\n      let url = this.#scriptURLs.get(entry.scriptId);\n      if (!url && this.#reportAnonymousScripts) {\n        url = 'debugger://VM' + entry.scriptId;\n      }\n      const text = this.#scriptSources.get(entry.scriptId);\n      if (text === undefined || url === undefined) {\n        continue;\n      }\n      const flattenRanges = [];\n      for (const func of entry.functions) {\n        flattenRanges.push(...func.ranges);\n      }\n      const ranges = convertToDisjointRanges(flattenRanges);\n      if (!this.#includeRawScriptCoverage) {\n        coverage.push({\n          url,\n          ranges,\n          text\n        });\n      } else {\n        coverage.push({\n          url,\n          ranges,\n          text,\n          rawScriptCoverage: entry\n        });\n      }\n    }\n    return coverage;\n  }\n}\n/**\n * @public\n */\nexport class CSSCoverage {\n  #client;\n  #enabled = false;\n  #stylesheetURLs = new Map();\n  #stylesheetSources = new Map();\n  #eventListeners;\n  #resetOnNavigation = false;\n  constructor(client) {\n    this.#client = client;\n  }\n  /**\n   * @internal\n   */\n  updateClient(client) {\n    this.#client = client;\n  }\n  async start(options = {}) {\n    assert(!this.#enabled, 'CSSCoverage is already enabled');\n    const {\n      resetOnNavigation = true\n    } = options;\n    this.#resetOnNavigation = resetOnNavigation;\n    this.#enabled = true;\n    this.#stylesheetURLs.clear();\n    this.#stylesheetSources.clear();\n    this.#eventListeners = new DisposableStack();\n    const clientEmitter = this.#eventListeners.use(new EventEmitter(this.#client));\n    clientEmitter.on('CSS.styleSheetAdded', this.#onStyleSheet.bind(this));\n    clientEmitter.on('Runtime.executionContextsCleared', this.#onExecutionContextsCleared.bind(this));\n    await Promise.all([this.#client.send('DOM.enable'), this.#client.send('CSS.enable'), this.#client.send('CSS.startRuleUsageTracking')]);\n  }\n  #onExecutionContextsCleared() {\n    if (!this.#resetOnNavigation) {\n      return;\n    }\n    this.#stylesheetURLs.clear();\n    this.#stylesheetSources.clear();\n  }\n  async #onStyleSheet(event) {\n    const header = event.header;\n    // Ignore anonymous scripts\n    if (!header.sourceURL) {\n      return;\n    }\n    try {\n      const response = await this.#client.send('CSS.getStyleSheetText', {\n        styleSheetId: header.styleSheetId\n      });\n      this.#stylesheetURLs.set(header.styleSheetId, header.sourceURL);\n      this.#stylesheetSources.set(header.styleSheetId, response.text);\n    } catch (error) {\n      // This might happen if the page has already navigated away.\n      debugError(error);\n    }\n  }\n  async stop() {\n    assert(this.#enabled, 'CSSCoverage is not enabled');\n    this.#enabled = false;\n    const ruleTrackingResponse = await this.#client.send('CSS.stopRuleUsageTracking');\n    await Promise.all([this.#client.send('CSS.disable'), this.#client.send('DOM.disable')]);\n    this.#eventListeners?.dispose();\n    // aggregate by styleSheetId\n    const styleSheetIdToCoverage = new Map();\n    for (const entry of ruleTrackingResponse.ruleUsage) {\n      let ranges = styleSheetIdToCoverage.get(entry.styleSheetId);\n      if (!ranges) {\n        ranges = [];\n        styleSheetIdToCoverage.set(entry.styleSheetId, ranges);\n      }\n      ranges.push({\n        startOffset: entry.startOffset,\n        endOffset: entry.endOffset,\n        count: entry.used ? 1 : 0\n      });\n    }\n    const coverage = [];\n    for (const styleSheetId of this.#stylesheetURLs.keys()) {\n      const url = this.#stylesheetURLs.get(styleSheetId);\n      assert(typeof url !== 'undefined', `Stylesheet URL is undefined (styleSheetId=${styleSheetId})`);\n      const text = this.#stylesheetSources.get(styleSheetId);\n      assert(typeof text !== 'undefined', `Stylesheet text is undefined (styleSheetId=${styleSheetId})`);\n      const ranges = convertToDisjointRanges(styleSheetIdToCoverage.get(styleSheetId) || []);\n      coverage.push({\n        url,\n        ranges,\n        text\n      });\n    }\n    return coverage;\n  }\n}\nfunction convertToDisjointRanges(nestedRanges) {\n  const points = [];\n  for (const range of nestedRanges) {\n    points.push({\n      offset: range.startOffset,\n      type: 0,\n      range\n    });\n    points.push({\n      offset: range.endOffset,\n      type: 1,\n      range\n    });\n  }\n  // Sort points to form a valid parenthesis sequence.\n  points.sort((a, b) => {\n    // Sort with increasing offsets.\n    if (a.offset !== b.offset) {\n      return a.offset - b.offset;\n    }\n    // All \"end\" points should go before \"start\" points.\n    if (a.type !== b.type) {\n      return b.type - a.type;\n    }\n    const aLength = a.range.endOffset - a.range.startOffset;\n    const bLength = b.range.endOffset - b.range.startOffset;\n    // For two \"start\" points, the one with longer range goes first.\n    if (a.type === 0) {\n      return bLength - aLength;\n    }\n    // For two \"end\" points, the one with shorter range goes first.\n    return aLength - bLength;\n  });\n  const hitCountStack = [];\n  const results = [];\n  let lastOffset = 0;\n  // Run scanning line to intersect all ranges.\n  for (const point of points) {\n    if (hitCountStack.length && lastOffset < point.offset && hitCountStack[hitCountStack.length - 1] > 0) {\n      const lastResult = results[results.length - 1];\n      if (lastResult && lastResult.end === lastOffset) {\n        lastResult.end = point.offset;\n      } else {\n        results.push({\n          start: lastOffset,\n          end: point.offset\n        });\n      }\n    }\n    lastOffset = point.offset;\n    if (point.type === 0) {\n      hitCountStack.push(point.range.count);\n    } else {\n      hitCountStack.pop();\n    }\n  }\n  // Filter out empty ranges.\n  return results.filter(range => {\n    return range.end - range.start > 0;\n  });\n}","map":{"version":3,"names":["EventEmitter","debugError","PuppeteerURL","assert","DisposableStack","Coverage","jsCoverage","cssCoverage","constructor","client","JSCoverage","CSSCoverage","updateClient","startJSCoverage","options","start","stopJSCoverage","stop","startCSSCoverage","stopCSSCoverage","enabled","scriptURLs","Map","scriptSources","subscriptions","resetOnNavigation","reportAnonymousScripts","includeRawScriptCoverage","useBlockCoverage","clear","clientEmitter","use","on","onScriptParsed","bind","onExecutionContextsCleared","Promise","all","send","callCount","detailed","skip","#onExecutionContextsCleared","#onScriptParsed","event","isPuppeteerURL","url","response","scriptId","set","scriptSource","error","result","dispose","coverage","profileResponse","entry","get","text","undefined","flattenRanges","func","functions","push","ranges","convertToDisjointRanges","rawScriptCoverage","stylesheetURLs","stylesheetSources","eventListeners","onStyleSheet","#onStyleSheet","header","sourceURL","styleSheetId","ruleTrackingResponse","styleSheetIdToCoverage","ruleUsage","startOffset","endOffset","count","used","keys","nestedRanges","points","range","offset","type","sort","a","b","aLength","bLength","hitCountStack","results","lastOffset","point","length","lastResult","end","pop","filter"],"sources":["C:\\Users\\raffy\\Desktop\\test\\node_modules\\puppeteer-core\\src\\cdp\\Coverage.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2017 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport type {Protocol} from 'devtools-protocol';\n\nimport type {CDPSession} from '../api/CDPSession.js';\nimport {EventEmitter} from '../common/EventEmitter.js';\nimport {debugError, PuppeteerURL} from '../common/util.js';\nimport {assert} from '../util/assert.js';\nimport {DisposableStack} from '../util/disposable.js';\n\n/**\n * The CoverageEntry class represents one entry of the coverage report.\n * @public\n */\nexport interface CoverageEntry {\n  /**\n   * The URL of the style sheet or script.\n   */\n  url: string;\n  /**\n   * The content of the style sheet or script.\n   */\n  text: string;\n  /**\n   * The covered range as start and end positions.\n   */\n  ranges: Array<{start: number; end: number}>;\n}\n\n/**\n * The CoverageEntry class for JavaScript\n * @public\n */\nexport interface JSCoverageEntry extends CoverageEntry {\n  /**\n   * Raw V8 script coverage entry.\n   */\n  rawScriptCoverage?: Protocol.Profiler.ScriptCoverage;\n}\n\n/**\n * Set of configurable options for JS coverage.\n * @public\n */\nexport interface JSCoverageOptions {\n  /**\n   * Whether to reset coverage on every navigation.\n   */\n  resetOnNavigation?: boolean;\n  /**\n   * Whether anonymous scripts generated by the page should be reported.\n   */\n  reportAnonymousScripts?: boolean;\n  /**\n   * Whether the result includes raw V8 script coverage entries.\n   */\n  includeRawScriptCoverage?: boolean;\n  /**\n   * Whether to collect coverage information at the block level.\n   * If true, coverage will be collected at the block level (this is the default).\n   * If false, coverage will be collected at the function level.\n   */\n  useBlockCoverage?: boolean;\n}\n\n/**\n * Set of configurable options for CSS coverage.\n * @public\n */\nexport interface CSSCoverageOptions {\n  /**\n   * Whether to reset coverage on every navigation.\n   */\n  resetOnNavigation?: boolean;\n}\n\n/**\n * The Coverage class provides methods to gather information about parts of\n * JavaScript and CSS that were used by the page.\n *\n * @remarks\n * To output coverage in a form consumable by {@link https://github.com/istanbuljs | Istanbul},\n * see {@link https://github.com/istanbuljs/puppeteer-to-istanbul | puppeteer-to-istanbul}.\n *\n * @example\n * An example of using JavaScript and CSS coverage to get percentage of initially\n * executed code:\n *\n * ```ts\n * // Enable both JavaScript and CSS coverage\n * await Promise.all([\n *   page.coverage.startJSCoverage(),\n *   page.coverage.startCSSCoverage(),\n * ]);\n * // Navigate to page\n * await page.goto('https://example.com');\n * // Disable both JavaScript and CSS coverage\n * const [jsCoverage, cssCoverage] = await Promise.all([\n *   page.coverage.stopJSCoverage(),\n *   page.coverage.stopCSSCoverage(),\n * ]);\n * let totalBytes = 0;\n * let usedBytes = 0;\n * const coverage = [...jsCoverage, ...cssCoverage];\n * for (const entry of coverage) {\n *   totalBytes += entry.text.length;\n *   for (const range of entry.ranges) usedBytes += range.end - range.start - 1;\n * }\n * console.log(`Bytes used: ${(usedBytes / totalBytes) * 100}%`);\n * ```\n *\n * @public\n */\nexport class Coverage {\n  #jsCoverage: JSCoverage;\n  #cssCoverage: CSSCoverage;\n\n  /**\n   * @internal\n   */\n  constructor(client: CDPSession) {\n    this.#jsCoverage = new JSCoverage(client);\n    this.#cssCoverage = new CSSCoverage(client);\n  }\n\n  /**\n   * @internal\n   */\n  updateClient(client: CDPSession): void {\n    this.#jsCoverage.updateClient(client);\n    this.#cssCoverage.updateClient(client);\n  }\n\n  /**\n   * @param options - Set of configurable options for coverage defaults to\n   * `resetOnNavigation : true, reportAnonymousScripts : false,`\n   * `includeRawScriptCoverage : false, useBlockCoverage : true`\n   * @returns Promise that resolves when coverage is started.\n   *\n   * @remarks\n   * Anonymous scripts are ones that don't have an associated url. These are\n   * scripts that are dynamically created on the page using `eval` or\n   * `new Function`. If `reportAnonymousScripts` is set to `true`, anonymous\n   * scripts URL will start with `debugger://VM` (unless a magic //# sourceURL\n   * comment is present, in which case that will the be URL).\n   */\n  async startJSCoverage(options: JSCoverageOptions = {}): Promise<void> {\n    return await this.#jsCoverage.start(options);\n  }\n\n  /**\n   * Promise that resolves to the array of coverage reports for\n   * all scripts.\n   *\n   * @remarks\n   * JavaScript Coverage doesn't include anonymous scripts by default.\n   * However, scripts with sourceURLs are reported.\n   */\n  async stopJSCoverage(): Promise<JSCoverageEntry[]> {\n    return await this.#jsCoverage.stop();\n  }\n\n  /**\n   * @param options - Set of configurable options for coverage, defaults to\n   * `resetOnNavigation : true`\n   * @returns Promise that resolves when coverage is started.\n   */\n  async startCSSCoverage(options: CSSCoverageOptions = {}): Promise<void> {\n    return await this.#cssCoverage.start(options);\n  }\n\n  /**\n   * Promise that resolves to the array of coverage reports\n   * for all stylesheets.\n   *\n   * @remarks\n   * CSS Coverage doesn't include dynamically injected style tags\n   * without sourceURLs.\n   */\n  async stopCSSCoverage(): Promise<CoverageEntry[]> {\n    return await this.#cssCoverage.stop();\n  }\n}\n\n/**\n * @public\n */\nexport class JSCoverage {\n  #client: CDPSession;\n  #enabled = false;\n  #scriptURLs = new Map<string, string>();\n  #scriptSources = new Map<string, string>();\n  #subscriptions?: DisposableStack;\n  #resetOnNavigation = false;\n  #reportAnonymousScripts = false;\n  #includeRawScriptCoverage = false;\n\n  /**\n   * @internal\n   */\n  constructor(client: CDPSession) {\n    this.#client = client;\n  }\n\n  /**\n   * @internal\n   */\n  updateClient(client: CDPSession): void {\n    this.#client = client;\n  }\n\n  async start(\n    options: {\n      resetOnNavigation?: boolean;\n      reportAnonymousScripts?: boolean;\n      includeRawScriptCoverage?: boolean;\n      useBlockCoverage?: boolean;\n    } = {}\n  ): Promise<void> {\n    assert(!this.#enabled, 'JSCoverage is already enabled');\n    const {\n      resetOnNavigation = true,\n      reportAnonymousScripts = false,\n      includeRawScriptCoverage = false,\n      useBlockCoverage = true,\n    } = options;\n    this.#resetOnNavigation = resetOnNavigation;\n    this.#reportAnonymousScripts = reportAnonymousScripts;\n    this.#includeRawScriptCoverage = includeRawScriptCoverage;\n    this.#enabled = true;\n    this.#scriptURLs.clear();\n    this.#scriptSources.clear();\n    this.#subscriptions = new DisposableStack();\n    const clientEmitter = this.#subscriptions.use(\n      new EventEmitter(this.#client)\n    );\n    clientEmitter.on('Debugger.scriptParsed', this.#onScriptParsed.bind(this));\n    clientEmitter.on(\n      'Runtime.executionContextsCleared',\n      this.#onExecutionContextsCleared.bind(this)\n    );\n    await Promise.all([\n      this.#client.send('Profiler.enable'),\n      this.#client.send('Profiler.startPreciseCoverage', {\n        callCount: this.#includeRawScriptCoverage,\n        detailed: useBlockCoverage,\n      }),\n      this.#client.send('Debugger.enable'),\n      this.#client.send('Debugger.setSkipAllPauses', {skip: true}),\n    ]);\n  }\n\n  #onExecutionContextsCleared(): void {\n    if (!this.#resetOnNavigation) {\n      return;\n    }\n    this.#scriptURLs.clear();\n    this.#scriptSources.clear();\n  }\n\n  async #onScriptParsed(\n    event: Protocol.Debugger.ScriptParsedEvent\n  ): Promise<void> {\n    // Ignore puppeteer-injected scripts\n    if (PuppeteerURL.isPuppeteerURL(event.url)) {\n      return;\n    }\n    // Ignore other anonymous scripts unless the reportAnonymousScripts option is true.\n    if (!event.url && !this.#reportAnonymousScripts) {\n      return;\n    }\n    try {\n      const response = await this.#client.send('Debugger.getScriptSource', {\n        scriptId: event.scriptId,\n      });\n      this.#scriptURLs.set(event.scriptId, event.url);\n      this.#scriptSources.set(event.scriptId, response.scriptSource);\n    } catch (error) {\n      // This might happen if the page has already navigated away.\n      debugError(error);\n    }\n  }\n\n  async stop(): Promise<JSCoverageEntry[]> {\n    assert(this.#enabled, 'JSCoverage is not enabled');\n    this.#enabled = false;\n\n    const result = await Promise.all([\n      this.#client.send('Profiler.takePreciseCoverage'),\n      this.#client.send('Profiler.stopPreciseCoverage'),\n      this.#client.send('Profiler.disable'),\n      this.#client.send('Debugger.disable'),\n    ]);\n\n    this.#subscriptions?.dispose();\n\n    const coverage = [];\n    const profileResponse = result[0];\n\n    for (const entry of profileResponse.result) {\n      let url = this.#scriptURLs.get(entry.scriptId);\n      if (!url && this.#reportAnonymousScripts) {\n        url = 'debugger://VM' + entry.scriptId;\n      }\n      const text = this.#scriptSources.get(entry.scriptId);\n      if (text === undefined || url === undefined) {\n        continue;\n      }\n      const flattenRanges = [];\n      for (const func of entry.functions) {\n        flattenRanges.push(...func.ranges);\n      }\n      const ranges = convertToDisjointRanges(flattenRanges);\n      if (!this.#includeRawScriptCoverage) {\n        coverage.push({url, ranges, text});\n      } else {\n        coverage.push({url, ranges, text, rawScriptCoverage: entry});\n      }\n    }\n    return coverage;\n  }\n}\n\n/**\n * @public\n */\nexport class CSSCoverage {\n  #client: CDPSession;\n  #enabled = false;\n  #stylesheetURLs = new Map<string, string>();\n  #stylesheetSources = new Map<string, string>();\n  #eventListeners?: DisposableStack;\n  #resetOnNavigation = false;\n\n  constructor(client: CDPSession) {\n    this.#client = client;\n  }\n\n  /**\n   * @internal\n   */\n  updateClient(client: CDPSession): void {\n    this.#client = client;\n  }\n\n  async start(options: {resetOnNavigation?: boolean} = {}): Promise<void> {\n    assert(!this.#enabled, 'CSSCoverage is already enabled');\n    const {resetOnNavigation = true} = options;\n    this.#resetOnNavigation = resetOnNavigation;\n    this.#enabled = true;\n    this.#stylesheetURLs.clear();\n    this.#stylesheetSources.clear();\n    this.#eventListeners = new DisposableStack();\n    const clientEmitter = this.#eventListeners.use(\n      new EventEmitter(this.#client)\n    );\n    clientEmitter.on('CSS.styleSheetAdded', this.#onStyleSheet.bind(this));\n    clientEmitter.on(\n      'Runtime.executionContextsCleared',\n      this.#onExecutionContextsCleared.bind(this)\n    );\n\n    await Promise.all([\n      this.#client.send('DOM.enable'),\n      this.#client.send('CSS.enable'),\n      this.#client.send('CSS.startRuleUsageTracking'),\n    ]);\n  }\n\n  #onExecutionContextsCleared(): void {\n    if (!this.#resetOnNavigation) {\n      return;\n    }\n    this.#stylesheetURLs.clear();\n    this.#stylesheetSources.clear();\n  }\n\n  async #onStyleSheet(event: Protocol.CSS.StyleSheetAddedEvent): Promise<void> {\n    const header = event.header;\n    // Ignore anonymous scripts\n    if (!header.sourceURL) {\n      return;\n    }\n    try {\n      const response = await this.#client.send('CSS.getStyleSheetText', {\n        styleSheetId: header.styleSheetId,\n      });\n      this.#stylesheetURLs.set(header.styleSheetId, header.sourceURL);\n      this.#stylesheetSources.set(header.styleSheetId, response.text);\n    } catch (error) {\n      // This might happen if the page has already navigated away.\n      debugError(error);\n    }\n  }\n\n  async stop(): Promise<CoverageEntry[]> {\n    assert(this.#enabled, 'CSSCoverage is not enabled');\n    this.#enabled = false;\n    const ruleTrackingResponse = await this.#client.send(\n      'CSS.stopRuleUsageTracking'\n    );\n    await Promise.all([\n      this.#client.send('CSS.disable'),\n      this.#client.send('DOM.disable'),\n    ]);\n    this.#eventListeners?.dispose();\n\n    // aggregate by styleSheetId\n    const styleSheetIdToCoverage = new Map();\n    for (const entry of ruleTrackingResponse.ruleUsage) {\n      let ranges = styleSheetIdToCoverage.get(entry.styleSheetId);\n      if (!ranges) {\n        ranges = [];\n        styleSheetIdToCoverage.set(entry.styleSheetId, ranges);\n      }\n      ranges.push({\n        startOffset: entry.startOffset,\n        endOffset: entry.endOffset,\n        count: entry.used ? 1 : 0,\n      });\n    }\n\n    const coverage: CoverageEntry[] = [];\n    for (const styleSheetId of this.#stylesheetURLs.keys()) {\n      const url = this.#stylesheetURLs.get(styleSheetId);\n      assert(\n        typeof url !== 'undefined',\n        `Stylesheet URL is undefined (styleSheetId=${styleSheetId})`\n      );\n      const text = this.#stylesheetSources.get(styleSheetId);\n      assert(\n        typeof text !== 'undefined',\n        `Stylesheet text is undefined (styleSheetId=${styleSheetId})`\n      );\n      const ranges = convertToDisjointRanges(\n        styleSheetIdToCoverage.get(styleSheetId) || []\n      );\n      coverage.push({url, ranges, text});\n    }\n\n    return coverage;\n  }\n}\n\nfunction convertToDisjointRanges(\n  nestedRanges: Array<{startOffset: number; endOffset: number; count: number}>\n): Array<{start: number; end: number}> {\n  const points = [];\n  for (const range of nestedRanges) {\n    points.push({offset: range.startOffset, type: 0, range});\n    points.push({offset: range.endOffset, type: 1, range});\n  }\n  // Sort points to form a valid parenthesis sequence.\n  points.sort((a, b) => {\n    // Sort with increasing offsets.\n    if (a.offset !== b.offset) {\n      return a.offset - b.offset;\n    }\n    // All \"end\" points should go before \"start\" points.\n    if (a.type !== b.type) {\n      return b.type - a.type;\n    }\n    const aLength = a.range.endOffset - a.range.startOffset;\n    const bLength = b.range.endOffset - b.range.startOffset;\n    // For two \"start\" points, the one with longer range goes first.\n    if (a.type === 0) {\n      return bLength - aLength;\n    }\n    // For two \"end\" points, the one with shorter range goes first.\n    return aLength - bLength;\n  });\n\n  const hitCountStack = [];\n  const results: Array<{\n    start: number;\n    end: number;\n  }> = [];\n  let lastOffset = 0;\n  // Run scanning line to intersect all ranges.\n  for (const point of points) {\n    if (\n      hitCountStack.length &&\n      lastOffset < point.offset &&\n      hitCountStack[hitCountStack.length - 1]! > 0\n    ) {\n      const lastResult = results[results.length - 1];\n      if (lastResult && lastResult.end === lastOffset) {\n        lastResult.end = point.offset;\n      } else {\n        results.push({start: lastOffset, end: point.offset});\n      }\n    }\n    lastOffset = point.offset;\n    if (point.type === 0) {\n      hitCountStack.push(point.range.count);\n    } else {\n      hitCountStack.pop();\n    }\n  }\n  // Filter out empty ranges.\n  return results.filter(range => {\n    return range.end - range.start > 0;\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}