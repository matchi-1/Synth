{"ast":null,"code":"import { parse, SelectorType, isTraversal } from \"css-what\";\nimport { _compileToken as compileToken, prepareContext } from \"css-select\";\nimport * as DomUtils from \"domutils\";\nimport * as boolbase from \"boolbase\";\nimport { getDocumentRoot, groupSelectors } from \"./helpers.js\";\nimport { isFilter, getLimit } from \"./positionals.js\";\n// Re-export pseudo extension points\nexport { filters, pseudos, aliases } from \"css-select\";\nconst UNIVERSAL_SELECTOR = {\n  type: SelectorType.Universal,\n  namespace: null\n};\nconst SCOPE_PSEUDO = {\n  type: SelectorType.Pseudo,\n  name: \"scope\",\n  data: null\n};\nexport function is(element, selector, options = {}) {\n  return some([element], selector, options);\n}\nexport function some(elements, selector, options = {}) {\n  if (typeof selector === \"function\") return elements.some(selector);\n  const [plain, filtered] = groupSelectors(parse(selector));\n  return plain.length > 0 && elements.some(compileToken(plain, options)) || filtered.some(sel => filterBySelector(sel, elements, options).length > 0);\n}\nfunction filterByPosition(filter, elems, data, options) {\n  const num = typeof data === \"string\" ? parseInt(data, 10) : NaN;\n  switch (filter) {\n    case \"first\":\n    case \"lt\":\n      // Already done in `getLimit`\n      return elems;\n    case \"last\":\n      return elems.length > 0 ? [elems[elems.length - 1]] : elems;\n    case \"nth\":\n    case \"eq\":\n      return isFinite(num) && Math.abs(num) < elems.length ? [num < 0 ? elems[elems.length + num] : elems[num]] : [];\n    case \"gt\":\n      return isFinite(num) ? elems.slice(num + 1) : [];\n    case \"even\":\n      return elems.filter((_, i) => i % 2 === 0);\n    case \"odd\":\n      return elems.filter((_, i) => i % 2 === 1);\n    case \"not\":\n      {\n        const filtered = new Set(filterParsed(data, elems, options));\n        return elems.filter(e => !filtered.has(e));\n      }\n  }\n}\nexport function filter(selector, elements, options = {}) {\n  return filterParsed(parse(selector), elements, options);\n}\n/**\n * Filter a set of elements by a selector.\n *\n * Will return elements in the original order.\n *\n * @param selector Selector to filter by.\n * @param elements Elements to filter.\n * @param options Options for selector.\n */\nfunction filterParsed(selector, elements, options) {\n  if (elements.length === 0) return [];\n  const [plainSelectors, filteredSelectors] = groupSelectors(selector);\n  let found;\n  if (plainSelectors.length) {\n    const filtered = filterElements(elements, plainSelectors, options);\n    // If there are no filters, just return\n    if (filteredSelectors.length === 0) {\n      return filtered;\n    }\n    // Otherwise, we have to do some filtering\n    if (filtered.length) {\n      found = new Set(filtered);\n    }\n  }\n  for (let i = 0; i < filteredSelectors.length && (found === null || found === void 0 ? void 0 : found.size) !== elements.length; i++) {\n    const filteredSelector = filteredSelectors[i];\n    const missing = found ? elements.filter(e => DomUtils.isTag(e) && !found.has(e)) : elements;\n    if (missing.length === 0) break;\n    const filtered = filterBySelector(filteredSelector, elements, options);\n    if (filtered.length) {\n      if (!found) {\n        /*\n         * If we haven't found anything before the last selector,\n         * just return what we found now.\n         */\n        if (i === filteredSelectors.length - 1) {\n          return filtered;\n        }\n        found = new Set(filtered);\n      } else {\n        filtered.forEach(el => found.add(el));\n      }\n    }\n  }\n  return typeof found !== \"undefined\" ? found.size === elements.length ? elements :\n  // Filter elements to preserve order\n  elements.filter(el => found.has(el)) : [];\n}\nfunction filterBySelector(selector, elements, options) {\n  var _a;\n  if (selector.some(isTraversal)) {\n    /*\n     * Get root node, run selector with the scope\n     * set to all of our nodes.\n     */\n    const root = (_a = options.root) !== null && _a !== void 0 ? _a : getDocumentRoot(elements[0]);\n    const opts = {\n      ...options,\n      context: elements,\n      relativeSelector: false\n    };\n    selector.push(SCOPE_PSEUDO);\n    return findFilterElements(root, selector, opts, true, elements.length);\n  }\n  // Performance optimization: If we don't have to traverse, just filter set.\n  return findFilterElements(elements, selector, options, false, elements.length);\n}\nexport function select(selector, root, options = {}, limit = Infinity) {\n  if (typeof selector === \"function\") {\n    return find(root, selector);\n  }\n  const [plain, filtered] = groupSelectors(parse(selector));\n  const results = filtered.map(sel => findFilterElements(root, sel, options, true, limit));\n  // Plain selectors can be queried in a single go\n  if (plain.length) {\n    results.push(findElements(root, plain, options, limit));\n  }\n  if (results.length === 0) {\n    return [];\n  }\n  // If there was only a single selector, just return the result\n  if (results.length === 1) {\n    return results[0];\n  }\n  // Sort results, filtering for duplicates\n  return DomUtils.uniqueSort(results.reduce((a, b) => [...a, ...b]));\n}\n/**\n *\n * @param root Element(s) to search from.\n * @param selector Selector to look for.\n * @param options Options for querying.\n * @param queryForSelector Query multiple levels deep for the initial selector, even if it doesn't contain a traversal.\n */\nfunction findFilterElements(root, selector, options, queryForSelector, totalLimit) {\n  const filterIndex = selector.findIndex(isFilter);\n  const sub = selector.slice(0, filterIndex);\n  const filter = selector[filterIndex];\n  // If we are at the end of the selector, we can limit the number of elements to retrieve.\n  const partLimit = selector.length - 1 === filterIndex ? totalLimit : Infinity;\n  /*\n   * Set the number of elements to retrieve.\n   * Eg. for :first, we only have to get a single element.\n   */\n  const limit = getLimit(filter.name, filter.data, partLimit);\n  if (limit === 0) return [];\n  /*\n   * Skip `findElements` call if our selector starts with a positional\n   * pseudo.\n   */\n  const elemsNoLimit = sub.length === 0 && !Array.isArray(root) ? DomUtils.getChildren(root).filter(DomUtils.isTag) : sub.length === 0 ? (Array.isArray(root) ? root : [root]).filter(DomUtils.isTag) : queryForSelector || sub.some(isTraversal) ? findElements(root, [sub], options, limit) : filterElements(root, [sub], options);\n  const elems = elemsNoLimit.slice(0, limit);\n  let result = filterByPosition(filter.name, elems, filter.data, options);\n  if (result.length === 0 || selector.length === filterIndex + 1) {\n    return result;\n  }\n  const remainingSelector = selector.slice(filterIndex + 1);\n  const remainingHasTraversal = remainingSelector.some(isTraversal);\n  if (remainingHasTraversal) {\n    if (isTraversal(remainingSelector[0])) {\n      const {\n        type\n      } = remainingSelector[0];\n      if (type === SelectorType.Sibling || type === SelectorType.Adjacent) {\n        // If we have a sibling traversal, we need to also look at the siblings.\n        result = prepareContext(result, DomUtils, true);\n      }\n      // Avoid a traversal-first selector error.\n      remainingSelector.unshift(UNIVERSAL_SELECTOR);\n    }\n    options = {\n      ...options,\n      // Avoid absolutizing the selector\n      relativeSelector: false,\n      /*\n       * Add a custom root func, to make sure traversals don't match elements\n       * that aren't a part of the considered tree.\n       */\n      rootFunc: el => result.includes(el)\n    };\n  } else if (options.rootFunc && options.rootFunc !== boolbase.trueFunc) {\n    options = {\n      ...options,\n      rootFunc: boolbase.trueFunc\n    };\n  }\n  /*\n   * If we have another filter, recursively call `findFilterElements`,\n   * with the `recursive` flag disabled. We only have to look for more\n   * elements when we see a traversal.\n   *\n   * Otherwise,\n   */\n  return remainingSelector.some(isFilter) ? findFilterElements(result, remainingSelector, options, false, totalLimit) : remainingHasTraversal ?\n  // Query existing elements to resolve traversal.\n  findElements(result, [remainingSelector], options, totalLimit) :\n  // If we don't have any more traversals, simply filter elements.\n  filterElements(result, [remainingSelector], options);\n}\nfunction findElements(root, sel, options, limit) {\n  const query = compileToken(sel, options, root);\n  return find(root, query, limit);\n}\nfunction find(root, query, limit = Infinity) {\n  const elems = prepareContext(root, DomUtils, query.shouldTestNextSiblings);\n  return DomUtils.find(node => DomUtils.isTag(node) && query(node), elems, true, limit);\n}\nfunction filterElements(elements, sel, options) {\n  const els = (Array.isArray(elements) ? elements : [elements]).filter(DomUtils.isTag);\n  if (els.length === 0) return els;\n  const query = compileToken(sel, options);\n  return query === boolbase.trueFunc ? els : els.filter(query);\n}\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}