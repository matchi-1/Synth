{"ast":null,"code":"/**\n * @license\n * Copyright 2023 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * The HTTPResponse class represents responses which are received by the\n * {@link Page} class.\n *\n * @public\n */\nexport class HTTPResponse {\n  /**\n   * @internal\n   */\n  constructor() {}\n  /**\n   * True if the response was successful (status in the range 200-299).\n   */\n  ok() {\n    // TODO: document === 0 case?\n    const status = this.status();\n    return status === 0 || status >= 200 && status <= 299;\n  }\n  /**\n   * {@inheritDoc HTTPResponse.content}\n   */\n  async buffer() {\n    const content = await this.content();\n    return Buffer.from(content);\n  }\n  /**\n   * Promise which resolves to a text (utf8) representation of response body.\n   */\n  async text() {\n    const content = await this.content();\n    return new TextDecoder().decode(content);\n  }\n  /**\n   * Promise which resolves to a JSON representation of response body.\n   *\n   * @remarks\n   *\n   * This method will throw if the response body is not parsable via\n   * `JSON.parse`.\n   */\n  async json() {\n    const content = await this.text();\n    return JSON.parse(content);\n  }\n}","map":{"version":3,"names":["HTTPResponse","constructor","ok","status","buffer","content","Buffer","from","text","TextDecoder","decode","json","JSON","parse"],"sources":["C:\\Users\\raffy\\Desktop\\test\\node_modules\\puppeteer-core\\src\\api\\HTTPResponse.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2023 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport type Protocol from 'devtools-protocol';\n\nimport type {SecurityDetails} from '../common/SecurityDetails.js';\n\nimport type {Frame} from './Frame.js';\nimport type {HTTPRequest} from './HTTPRequest.js';\n\n/**\n * @public\n */\nexport interface RemoteAddress {\n  ip?: string;\n  port?: number;\n}\n\n/**\n * The HTTPResponse class represents responses which are received by the\n * {@link Page} class.\n *\n * @public\n */\nexport abstract class HTTPResponse {\n  /**\n   * @internal\n   */\n  constructor() {}\n\n  /**\n   * The IP address and port number used to connect to the remote\n   * server.\n   */\n  abstract remoteAddress(): RemoteAddress;\n\n  /**\n   * The URL of the response.\n   */\n  abstract url(): string;\n\n  /**\n   * True if the response was successful (status in the range 200-299).\n   */\n  ok(): boolean {\n    // TODO: document === 0 case?\n    const status = this.status();\n    return status === 0 || (status >= 200 && status <= 299);\n  }\n\n  /**\n   * The status code of the response (e.g., 200 for a success).\n   */\n  abstract status(): number;\n\n  /**\n   * The status text of the response (e.g. usually an \"OK\" for a\n   * success).\n   */\n  abstract statusText(): string;\n\n  /**\n   * An object with HTTP headers associated with the response. All\n   * header names are lower-case.\n   */\n  abstract headers(): Record<string, string>;\n\n  /**\n   * {@link SecurityDetails} if the response was received over the\n   * secure connection, or `null` otherwise.\n   */\n  abstract securityDetails(): SecurityDetails | null;\n\n  /**\n   * Timing information related to the response.\n   */\n  abstract timing(): Protocol.Network.ResourceTiming | null;\n\n  /**\n   * Promise which resolves to a buffer with response body.\n   *\n   * @remarks\n   *\n   * The buffer might be re-encoded by the browser\n   * based on HTTP-headers or other heuristics. If the browser\n   * failed to detect the correct encoding, the buffer might\n   * be encoded incorrectly. See https://github.com/puppeteer/puppeteer/issues/6478.\n   */\n  abstract content(): Promise<Uint8Array>;\n\n  /**\n   * {@inheritDoc HTTPResponse.content}\n   */\n  async buffer(): Promise<Buffer> {\n    const content = await this.content();\n    return Buffer.from(content);\n  }\n  /**\n   * Promise which resolves to a text (utf8) representation of response body.\n   */\n  async text(): Promise<string> {\n    const content = await this.content();\n    return new TextDecoder().decode(content);\n  }\n\n  /**\n   * Promise which resolves to a JSON representation of response body.\n   *\n   * @remarks\n   *\n   * This method will throw if the response body is not parsable via\n   * `JSON.parse`.\n   */\n  async json(): Promise<any> {\n    const content = await this.text();\n    return JSON.parse(content);\n  }\n\n  /**\n   * A matching {@link HTTPRequest} object.\n   */\n  abstract request(): HTTPRequest;\n\n  /**\n   * True if the response was served from either the browser's disk\n   * cache or memory cache.\n   */\n  abstract fromCache(): boolean;\n\n  /**\n   * True if the response was served by a service worker.\n   */\n  abstract fromServiceWorker(): boolean;\n\n  /**\n   * A {@link Frame} that initiated this response, or `null` if\n   * navigating to error pages.\n   */\n  abstract frame(): Frame | null;\n}\n"],"mappings":"AAAA;;;;;AAqBA;;;;;;AAMA,OAAM,MAAgBA,YAAY;EAChC;;;EAGAC,YAAA,GAAe;EAaf;;;EAGAC,EAAEA,CAAA;IACA;IACA,MAAMC,MAAM,GAAG,IAAI,CAACA,MAAM,EAAE;IAC5B,OAAOA,MAAM,KAAK,CAAC,IAAKA,MAAM,IAAI,GAAG,IAAIA,MAAM,IAAI,GAAI;EACzD;EA0CA;;;EAGA,MAAMC,MAAMA,CAAA;IACV,MAAMC,OAAO,GAAG,MAAM,IAAI,CAACA,OAAO,EAAE;IACpC,OAAOC,MAAM,CAACC,IAAI,CAACF,OAAO,CAAC;EAC7B;EACA;;;EAGA,MAAMG,IAAIA,CAAA;IACR,MAAMH,OAAO,GAAG,MAAM,IAAI,CAACA,OAAO,EAAE;IACpC,OAAO,IAAII,WAAW,EAAE,CAACC,MAAM,CAACL,OAAO,CAAC;EAC1C;EAEA;;;;;;;;EAQA,MAAMM,IAAIA,CAAA;IACR,MAAMN,OAAO,GAAG,MAAM,IAAI,CAACG,IAAI,EAAE;IACjC,OAAOI,IAAI,CAACC,KAAK,CAACR,OAAO,CAAC;EAC5B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}