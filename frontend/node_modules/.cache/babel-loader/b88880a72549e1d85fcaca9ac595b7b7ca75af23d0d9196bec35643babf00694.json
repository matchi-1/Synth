{"ast":null,"code":"/**\n * @license\n * Copyright 2023 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { Connection } from '../cdp/Connection.js';\nimport { ProtocolError, UnsupportedOperation } from '../common/Errors.js';\nimport { debugError, DEFAULT_VIEWPORT } from '../common/util.js';\n/**\n * Users should never call this directly; it's called when calling `puppeteer.connect`\n * with `protocol: 'webDriverBiDi'`. This method attaches Puppeteer to an existing browser\n * instance. First it tries to connect to the browser using pure BiDi. If the protocol is\n * not supported, connects to the browser using BiDi over CDP.\n *\n * @internal\n */\nexport async function _connectToBiDiBrowser(connectionTransport, url, options) {\n  const {\n    acceptInsecureCerts = false,\n    defaultViewport = DEFAULT_VIEWPORT\n  } = options;\n  const {\n    bidiConnection,\n    cdpConnection,\n    closeCallback\n  } = await getBiDiConnection(connectionTransport, url, options);\n  const BiDi = await import(/* webpackIgnore: true */'./bidi.js');\n  const bidiBrowser = await BiDi.BidiBrowser.create({\n    connection: bidiConnection,\n    cdpConnection,\n    closeCallback,\n    process: undefined,\n    defaultViewport: defaultViewport,\n    acceptInsecureCerts: acceptInsecureCerts,\n    capabilities: options.capabilities\n  });\n  return bidiBrowser;\n}\n/**\n * Returns a BiDiConnection established to the endpoint specified by the options and a\n * callback closing the browser. Callback depends on whether the connection is pure BiDi\n * or BiDi over CDP.\n * The method tries to connect to the browser using pure BiDi protocol, and falls back\n * to BiDi over CDP.\n */\nasync function getBiDiConnection(connectionTransport, url, options) {\n  const BiDi = await import(/* webpackIgnore: true */'./bidi.js');\n  const {\n    slowMo = 0,\n    protocolTimeout\n  } = options;\n  // Try pure BiDi first.\n  const pureBidiConnection = new BiDi.BidiConnection(url, connectionTransport, slowMo, protocolTimeout);\n  try {\n    const result = await pureBidiConnection.send('session.status', {});\n    if ('type' in result && result.type === 'success') {\n      // The `browserWSEndpoint` points to an endpoint supporting pure WebDriver BiDi.\n      return {\n        bidiConnection: pureBidiConnection,\n        closeCallback: async () => {\n          await pureBidiConnection.send('browser.close', {}).catch(debugError);\n        }\n      };\n    }\n  } catch (e) {\n    if (!(e instanceof ProtocolError)) {\n      // Unexpected exception not related to BiDi / CDP. Rethrow.\n      throw e;\n    }\n  }\n  // Unbind the connection to avoid memory leaks.\n  pureBidiConnection.unbind();\n  // Fall back to CDP over BiDi reusing the WS connection.\n  const cdpConnection = new Connection(url, connectionTransport, slowMo, protocolTimeout);\n  const version = await cdpConnection.send('Browser.getVersion');\n  if (version.product.toLowerCase().includes('firefox')) {\n    throw new UnsupportedOperation('Firefox is not supported in BiDi over CDP mode.');\n  }\n  const bidiOverCdpConnection = await BiDi.connectBidiOverCdp(cdpConnection);\n  return {\n    cdpConnection,\n    bidiConnection: bidiOverCdpConnection,\n    closeCallback: async () => {\n      // In case of BiDi over CDP, we need to close browser via CDP.\n      await cdpConnection.send('Browser.close').catch(debugError);\n    }\n  };\n}","map":{"version":3,"names":["Connection","ProtocolError","UnsupportedOperation","debugError","DEFAULT_VIEWPORT","_connectToBiDiBrowser","connectionTransport","url","options","acceptInsecureCerts","defaultViewport","bidiConnection","cdpConnection","closeCallback","getBiDiConnection","BiDi","bidiBrowser","BidiBrowser","create","connection","process","undefined","capabilities","slowMo","protocolTimeout","pureBidiConnection","BidiConnection","result","send","type","catch","e","unbind","version","product","toLowerCase","includes","bidiOverCdpConnection","connectBidiOverCdp"],"sources":["C:\\Users\\raffy\\Desktop\\test\\node_modules\\puppeteer-core\\src\\bidi\\BrowserConnector.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2023 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport type {BrowserCloseCallback} from '../api/Browser.js';\nimport {Connection} from '../cdp/Connection.js';\nimport type {ConnectionTransport} from '../common/ConnectionTransport.js';\nimport type {\n  BrowserConnectOptions,\n  ConnectOptions,\n} from '../common/ConnectOptions.js';\nimport {ProtocolError, UnsupportedOperation} from '../common/Errors.js';\nimport {debugError, DEFAULT_VIEWPORT} from '../common/util.js';\n\nimport type {BidiBrowser} from './Browser.js';\nimport type {BidiConnection} from './Connection.js';\n\n/**\n * Users should never call this directly; it's called when calling `puppeteer.connect`\n * with `protocol: 'webDriverBiDi'`. This method attaches Puppeteer to an existing browser\n * instance. First it tries to connect to the browser using pure BiDi. If the protocol is\n * not supported, connects to the browser using BiDi over CDP.\n *\n * @internal\n */\nexport async function _connectToBiDiBrowser(\n  connectionTransport: ConnectionTransport,\n  url: string,\n  options: BrowserConnectOptions & ConnectOptions\n): Promise<BidiBrowser> {\n  const {acceptInsecureCerts = false, defaultViewport = DEFAULT_VIEWPORT} =\n    options;\n\n  const {bidiConnection, cdpConnection, closeCallback} =\n    await getBiDiConnection(connectionTransport, url, options);\n  const BiDi = await import(/* webpackIgnore: true */ './bidi.js');\n  const bidiBrowser = await BiDi.BidiBrowser.create({\n    connection: bidiConnection,\n    cdpConnection,\n    closeCallback,\n    process: undefined,\n    defaultViewport: defaultViewport,\n    acceptInsecureCerts: acceptInsecureCerts,\n    capabilities: options.capabilities,\n  });\n  return bidiBrowser;\n}\n\n/**\n * Returns a BiDiConnection established to the endpoint specified by the options and a\n * callback closing the browser. Callback depends on whether the connection is pure BiDi\n * or BiDi over CDP.\n * The method tries to connect to the browser using pure BiDi protocol, and falls back\n * to BiDi over CDP.\n */\nasync function getBiDiConnection(\n  connectionTransport: ConnectionTransport,\n  url: string,\n  options: BrowserConnectOptions\n): Promise<{\n  cdpConnection?: Connection;\n  bidiConnection: BidiConnection;\n  closeCallback: BrowserCloseCallback;\n}> {\n  const BiDi = await import(/* webpackIgnore: true */ './bidi.js');\n  const {slowMo = 0, protocolTimeout} = options;\n\n  // Try pure BiDi first.\n  const pureBidiConnection = new BiDi.BidiConnection(\n    url,\n    connectionTransport,\n    slowMo,\n    protocolTimeout\n  );\n  try {\n    const result = await pureBidiConnection.send('session.status', {});\n    if ('type' in result && result.type === 'success') {\n      // The `browserWSEndpoint` points to an endpoint supporting pure WebDriver BiDi.\n      return {\n        bidiConnection: pureBidiConnection,\n        closeCallback: async () => {\n          await pureBidiConnection.send('browser.close', {}).catch(debugError);\n        },\n      };\n    }\n  } catch (e) {\n    if (!(e instanceof ProtocolError)) {\n      // Unexpected exception not related to BiDi / CDP. Rethrow.\n      throw e;\n    }\n  }\n  // Unbind the connection to avoid memory leaks.\n  pureBidiConnection.unbind();\n\n  // Fall back to CDP over BiDi reusing the WS connection.\n  const cdpConnection = new Connection(\n    url,\n    connectionTransport,\n    slowMo,\n    protocolTimeout\n  );\n\n  const version = await cdpConnection.send('Browser.getVersion');\n  if (version.product.toLowerCase().includes('firefox')) {\n    throw new UnsupportedOperation(\n      'Firefox is not supported in BiDi over CDP mode.'\n    );\n  }\n\n  const bidiOverCdpConnection = await BiDi.connectBidiOverCdp(cdpConnection);\n  return {\n    cdpConnection,\n    bidiConnection: bidiOverCdpConnection,\n    closeCallback: async () => {\n      // In case of BiDi over CDP, we need to close browser via CDP.\n      await cdpConnection.send('Browser.close').catch(debugError);\n    },\n  };\n}\n"],"mappings":"AAAA;;;;;AAOA,SAAQA,UAAU,QAAO,sBAAsB;AAM/C,SAAQC,aAAa,EAAEC,oBAAoB,QAAO,qBAAqB;AACvE,SAAQC,UAAU,EAAEC,gBAAgB,QAAO,mBAAmB;AAK9D;;;;;;;;AAQA,OAAO,eAAeC,qBAAqBA,CACzCC,mBAAwC,EACxCC,GAAW,EACXC,OAA+C;EAE/C,MAAM;IAACC,mBAAmB,GAAG,KAAK;IAAEC,eAAe,GAAGN;EAAgB,CAAC,GACrEI,OAAO;EAET,MAAM;IAACG,cAAc;IAAEC,aAAa;IAAEC;EAAa,CAAC,GAClD,MAAMC,iBAAiB,CAACR,mBAAmB,EAAEC,GAAG,EAAEC,OAAO,CAAC;EAC5D,MAAMO,IAAI,GAAG,MAAM,MAAM,CAAC,yBAA0B,WAAW,CAAC;EAChE,MAAMC,WAAW,GAAG,MAAMD,IAAI,CAACE,WAAW,CAACC,MAAM,CAAC;IAChDC,UAAU,EAAER,cAAc;IAC1BC,aAAa;IACbC,aAAa;IACbO,OAAO,EAAEC,SAAS;IAClBX,eAAe,EAAEA,eAAe;IAChCD,mBAAmB,EAAEA,mBAAmB;IACxCa,YAAY,EAAEd,OAAO,CAACc;GACvB,CAAC;EACF,OAAON,WAAW;AACpB;AAEA;;;;;;;AAOA,eAAeF,iBAAiBA,CAC9BR,mBAAwC,EACxCC,GAAW,EACXC,OAA8B;EAM9B,MAAMO,IAAI,GAAG,MAAM,MAAM,CAAC,yBAA0B,WAAW,CAAC;EAChE,MAAM;IAACQ,MAAM,GAAG,CAAC;IAAEC;EAAe,CAAC,GAAGhB,OAAO;EAE7C;EACA,MAAMiB,kBAAkB,GAAG,IAAIV,IAAI,CAACW,cAAc,CAChDnB,GAAG,EACHD,mBAAmB,EACnBiB,MAAM,EACNC,eAAe,CAChB;EACD,IAAI;IACF,MAAMG,MAAM,GAAG,MAAMF,kBAAkB,CAACG,IAAI,CAAC,gBAAgB,EAAE,EAAE,CAAC;IAClE,IAAI,MAAM,IAAID,MAAM,IAAIA,MAAM,CAACE,IAAI,KAAK,SAAS,EAAE;MACjD;MACA,OAAO;QACLlB,cAAc,EAAEc,kBAAkB;QAClCZ,aAAa,EAAE,MAAAA,CAAA,KAAW;UACxB,MAAMY,kBAAkB,CAACG,IAAI,CAAC,eAAe,EAAE,EAAE,CAAC,CAACE,KAAK,CAAC3B,UAAU,CAAC;QACtE;OACD;IACH;EACF,CAAC,CAAC,OAAO4B,CAAC,EAAE;IACV,IAAI,EAAEA,CAAC,YAAY9B,aAAa,CAAC,EAAE;MACjC;MACA,MAAM8B,CAAC;IACT;EACF;EACA;EACAN,kBAAkB,CAACO,MAAM,EAAE;EAE3B;EACA,MAAMpB,aAAa,GAAG,IAAIZ,UAAU,CAClCO,GAAG,EACHD,mBAAmB,EACnBiB,MAAM,EACNC,eAAe,CAChB;EAED,MAAMS,OAAO,GAAG,MAAMrB,aAAa,CAACgB,IAAI,CAAC,oBAAoB,CAAC;EAC9D,IAAIK,OAAO,CAACC,OAAO,CAACC,WAAW,EAAE,CAACC,QAAQ,CAAC,SAAS,CAAC,EAAE;IACrD,MAAM,IAAIlC,oBAAoB,CAC5B,iDAAiD,CAClD;EACH;EAEA,MAAMmC,qBAAqB,GAAG,MAAMtB,IAAI,CAACuB,kBAAkB,CAAC1B,aAAa,CAAC;EAC1E,OAAO;IACLA,aAAa;IACbD,cAAc,EAAE0B,qBAAqB;IACrCxB,aAAa,EAAE,MAAAA,CAAA,KAAW;MACxB;MACA,MAAMD,aAAa,CAACgB,IAAI,CAAC,eAAe,CAAC,CAACE,KAAK,CAAC3B,UAAU,CAAC;IAC7D;GACD;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}