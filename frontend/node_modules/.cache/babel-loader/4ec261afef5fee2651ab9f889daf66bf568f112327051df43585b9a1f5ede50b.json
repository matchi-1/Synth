{"ast":null,"code":"/**\n * @license\n * Copyright 2019 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { firstValueFrom, map, raceWith } from '../../third_party/rxjs/rxjs.js';\nimport { Realm } from '../api/Realm.js';\nimport { EventEmitter } from '../common/EventEmitter.js';\nimport { fromEmitterEvent, timeout, withSourcePuppeteerURLIfNone } from '../common/util.js';\nimport { disposeSymbol } from '../util/disposable.js';\nimport { CdpElementHandle } from './ElementHandle.js';\nimport { CdpJSHandle } from './JSHandle.js';\n/**\n * @internal\n */\nexport class IsolatedWorld extends Realm {\n  #context;\n  #emitter = new EventEmitter();\n  #frameOrWorker;\n  constructor(frameOrWorker, timeoutSettings) {\n    super(timeoutSettings);\n    this.#frameOrWorker = frameOrWorker;\n  }\n  get environment() {\n    return this.#frameOrWorker;\n  }\n  get client() {\n    return this.#frameOrWorker.client;\n  }\n  get emitter() {\n    return this.#emitter;\n  }\n  setContext(context) {\n    this.#context?.[disposeSymbol]();\n    context.once('disposed', this.#onContextDisposed.bind(this));\n    context.on('consoleapicalled', this.#onContextConsoleApiCalled.bind(this));\n    context.on('bindingcalled', this.#onContextBindingCalled.bind(this));\n    this.#context = context;\n    this.#emitter.emit('context', context);\n    void this.taskManager.rerunAll();\n  }\n  #onContextDisposed() {\n    this.#context = undefined;\n    if ('clearDocumentHandle' in this.#frameOrWorker) {\n      this.#frameOrWorker.clearDocumentHandle();\n    }\n  }\n  #onContextConsoleApiCalled(event) {\n    this.#emitter.emit('consoleapicalled', event);\n  }\n  #onContextBindingCalled(event) {\n    this.#emitter.emit('bindingcalled', event);\n  }\n  hasContext() {\n    return !!this.#context;\n  }\n  get context() {\n    return this.#context;\n  }\n  #executionContext() {\n    if (this.disposed) {\n      throw new Error(`Execution context is not available in detached frame or worker \"${this.environment.url()}\" (are you trying to evaluate?)`);\n    }\n    return this.#context;\n  }\n  /**\n   * Waits for the next context to be set on the isolated world.\n   */\n  async #waitForExecutionContext() {\n    const result = await firstValueFrom(fromEmitterEvent(this.#emitter, 'context').pipe(raceWith(fromEmitterEvent(this.#emitter, 'disposed').pipe(map(() => {\n      // The message has to match the CDP message expected by the WaitTask class.\n      throw new Error('Execution context was destroyed');\n    })), timeout(this.timeoutSettings.timeout()))));\n    return result;\n  }\n  async evaluateHandle(pageFunction, ...args) {\n    pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);\n    // This code needs to schedule evaluateHandle call synchroniously (at\n    // least when the context is there) so we cannot unconditionally\n    // await.\n    let context = this.#executionContext();\n    if (!context) {\n      context = await this.#waitForExecutionContext();\n    }\n    return await context.evaluateHandle(pageFunction, ...args);\n  }\n  async evaluate(pageFunction, ...args) {\n    pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);\n    // This code needs to schedule evaluate call synchroniously (at\n    // least when the context is there) so we cannot unconditionally\n    // await.\n    let context = this.#executionContext();\n    if (!context) {\n      context = await this.#waitForExecutionContext();\n    }\n    return await context.evaluate(pageFunction, ...args);\n  }\n  async adoptBackendNode(backendNodeId) {\n    // This code needs to schedule resolveNode call synchroniously (at\n    // least when the context is there) so we cannot unconditionally\n    // await.\n    let context = this.#executionContext();\n    if (!context) {\n      context = await this.#waitForExecutionContext();\n    }\n    const {\n      object\n    } = await this.client.send('DOM.resolveNode', {\n      backendNodeId: backendNodeId,\n      executionContextId: context.id\n    });\n    return this.createCdpHandle(object);\n  }\n  async adoptHandle(handle) {\n    if (handle.realm === this) {\n      // If the context has already adopted this handle, clone it so downstream\n      // disposal doesn't become an issue.\n      return await handle.evaluateHandle(value => {\n        return value;\n      });\n    }\n    const nodeInfo = await this.client.send('DOM.describeNode', {\n      objectId: handle.id\n    });\n    return await this.adoptBackendNode(nodeInfo.node.backendNodeId);\n  }\n  async transferHandle(handle) {\n    if (handle.realm === this) {\n      return handle;\n    }\n    // Implies it's a primitive value, probably.\n    if (handle.remoteObject().objectId === undefined) {\n      return handle;\n    }\n    const info = await this.client.send('DOM.describeNode', {\n      objectId: handle.remoteObject().objectId\n    });\n    const newHandle = await this.adoptBackendNode(info.node.backendNodeId);\n    await handle.dispose();\n    return newHandle;\n  }\n  /**\n   * @internal\n   */\n  createCdpHandle(remoteObject) {\n    if (remoteObject.subtype === 'node') {\n      return new CdpElementHandle(this, remoteObject);\n    }\n    return new CdpJSHandle(this, remoteObject);\n  }\n  [disposeSymbol]() {\n    this.#context?.[disposeSymbol]();\n    this.#emitter.emit('disposed', undefined);\n    super[disposeSymbol]();\n    this.#emitter.removeAllListeners();\n  }\n}","map":{"version":3,"names":["firstValueFrom","map","raceWith","Realm","EventEmitter","fromEmitterEvent","timeout","withSourcePuppeteerURLIfNone","disposeSymbol","CdpElementHandle","CdpJSHandle","IsolatedWorld","context","emitter","frameOrWorker","constructor","timeoutSettings","environment","client","setContext","once","onContextDisposed","bind","on","onContextConsoleApiCalled","onContextBindingCalled","emit","taskManager","rerunAll","#onContextDisposed","undefined","clearDocumentHandle","#onContextConsoleApiCalled","event","#onContextBindingCalled","hasContext","executionContext","#executionContext","disposed","Error","url","waitForExecutionContext","#waitForExecutionContext","result","pipe","evaluateHandle","pageFunction","args","name","evaluate","adoptBackendNode","backendNodeId","object","send","executionContextId","id","createCdpHandle","adoptHandle","handle","realm","value","nodeInfo","objectId","node","transferHandle","remoteObject","info","newHandle","dispose","subtype","removeAllListeners"],"sources":["C:\\Users\\raffy\\Desktop\\test\\node_modules\\puppeteer-core\\src\\cdp\\IsolatedWorld.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2019 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport type {Protocol} from 'devtools-protocol';\n\nimport {firstValueFrom, map, raceWith} from '../../third_party/rxjs/rxjs.js';\nimport type {CDPSession} from '../api/CDPSession.js';\nimport type {ElementHandle} from '../api/ElementHandle.js';\nimport type {JSHandle} from '../api/JSHandle.js';\nimport {Realm} from '../api/Realm.js';\nimport {EventEmitter} from '../common/EventEmitter.js';\nimport type {TimeoutSettings} from '../common/TimeoutSettings.js';\nimport type {EvaluateFunc, HandleFor} from '../common/types.js';\nimport {\n  fromEmitterEvent,\n  timeout,\n  withSourcePuppeteerURLIfNone,\n} from '../common/util.js';\nimport {disposeSymbol} from '../util/disposable.js';\n\nimport {CdpElementHandle} from './ElementHandle.js';\nimport type {ExecutionContext} from './ExecutionContext.js';\nimport type {CdpFrame} from './Frame.js';\nimport type {MAIN_WORLD, PUPPETEER_WORLD} from './IsolatedWorlds.js';\nimport {CdpJSHandle} from './JSHandle.js';\nimport type {CdpWebWorker} from './WebWorker.js';\n\n/**\n * @internal\n */\nexport interface PageBinding {\n  name: string;\n  pptrFunction: Function;\n}\n\n/**\n * @internal\n */\nexport interface IsolatedWorldChart {\n  [key: string]: IsolatedWorld;\n  [MAIN_WORLD]: IsolatedWorld;\n  [PUPPETEER_WORLD]: IsolatedWorld;\n}\n\n/**\n * @internal\n */\ntype IsolatedWorldEmitter = EventEmitter<{\n  // Emitted when the isolated world gets a new execution context.\n  context: ExecutionContext;\n  // Emitted when the isolated world is disposed.\n  disposed: undefined;\n  // Emitted when a new console message is logged.\n  consoleapicalled: Protocol.Runtime.ConsoleAPICalledEvent;\n  /** Emitted when a binding that is not installed by the ExecutionContext is called. */\n  bindingcalled: Protocol.Runtime.BindingCalledEvent;\n}>;\n\n/**\n * @internal\n */\nexport class IsolatedWorld extends Realm {\n  #context?: ExecutionContext;\n  #emitter: IsolatedWorldEmitter = new EventEmitter();\n\n  readonly #frameOrWorker: CdpFrame | CdpWebWorker;\n\n  constructor(\n    frameOrWorker: CdpFrame | CdpWebWorker,\n    timeoutSettings: TimeoutSettings\n  ) {\n    super(timeoutSettings);\n    this.#frameOrWorker = frameOrWorker;\n  }\n\n  get environment(): CdpFrame | CdpWebWorker {\n    return this.#frameOrWorker;\n  }\n\n  get client(): CDPSession {\n    return this.#frameOrWorker.client;\n  }\n\n  get emitter(): IsolatedWorldEmitter {\n    return this.#emitter;\n  }\n\n  setContext(context: ExecutionContext): void {\n    this.#context?.[disposeSymbol]();\n    context.once('disposed', this.#onContextDisposed.bind(this));\n    context.on('consoleapicalled', this.#onContextConsoleApiCalled.bind(this));\n    context.on('bindingcalled', this.#onContextBindingCalled.bind(this));\n    this.#context = context;\n    this.#emitter.emit('context', context);\n    void this.taskManager.rerunAll();\n  }\n\n  #onContextDisposed(): void {\n    this.#context = undefined;\n    if ('clearDocumentHandle' in this.#frameOrWorker) {\n      this.#frameOrWorker.clearDocumentHandle();\n    }\n  }\n\n  #onContextConsoleApiCalled(\n    event: Protocol.Runtime.ConsoleAPICalledEvent\n  ): void {\n    this.#emitter.emit('consoleapicalled', event);\n  }\n\n  #onContextBindingCalled(event: Protocol.Runtime.BindingCalledEvent): void {\n    this.#emitter.emit('bindingcalled', event);\n  }\n\n  hasContext(): boolean {\n    return !!this.#context;\n  }\n\n  get context(): ExecutionContext | undefined {\n    return this.#context;\n  }\n\n  #executionContext(): ExecutionContext | undefined {\n    if (this.disposed) {\n      throw new Error(\n        `Execution context is not available in detached frame or worker \"${this.environment.url()}\" (are you trying to evaluate?)`\n      );\n    }\n    return this.#context;\n  }\n\n  /**\n   * Waits for the next context to be set on the isolated world.\n   */\n  async #waitForExecutionContext(): Promise<ExecutionContext> {\n    const result = await firstValueFrom(\n      fromEmitterEvent(this.#emitter, 'context').pipe(\n        raceWith(\n          fromEmitterEvent(this.#emitter, 'disposed').pipe(\n            map(() => {\n              // The message has to match the CDP message expected by the WaitTask class.\n              throw new Error('Execution context was destroyed');\n            })\n          ),\n          timeout(this.timeoutSettings.timeout())\n        )\n      )\n    );\n    return result;\n  }\n\n  async evaluateHandle<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<HandleFor<Awaited<ReturnType<Func>>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(\n      this.evaluateHandle.name,\n      pageFunction\n    );\n    // This code needs to schedule evaluateHandle call synchroniously (at\n    // least when the context is there) so we cannot unconditionally\n    // await.\n    let context = this.#executionContext();\n    if (!context) {\n      context = await this.#waitForExecutionContext();\n    }\n    return await context.evaluateHandle(pageFunction, ...args);\n  }\n\n  async evaluate<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<Awaited<ReturnType<Func>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(\n      this.evaluate.name,\n      pageFunction\n    );\n    // This code needs to schedule evaluate call synchroniously (at\n    // least when the context is there) so we cannot unconditionally\n    // await.\n    let context = this.#executionContext();\n    if (!context) {\n      context = await this.#waitForExecutionContext();\n    }\n    return await context.evaluate(pageFunction, ...args);\n  }\n\n  override async adoptBackendNode(\n    backendNodeId?: Protocol.DOM.BackendNodeId\n  ): Promise<JSHandle<Node>> {\n    // This code needs to schedule resolveNode call synchroniously (at\n    // least when the context is there) so we cannot unconditionally\n    // await.\n    let context = this.#executionContext();\n    if (!context) {\n      context = await this.#waitForExecutionContext();\n    }\n    const {object} = await this.client.send('DOM.resolveNode', {\n      backendNodeId: backendNodeId,\n      executionContextId: context.id,\n    });\n    return this.createCdpHandle(object) as JSHandle<Node>;\n  }\n\n  async adoptHandle<T extends JSHandle<Node>>(handle: T): Promise<T> {\n    if (handle.realm === this) {\n      // If the context has already adopted this handle, clone it so downstream\n      // disposal doesn't become an issue.\n      return (await handle.evaluateHandle(value => {\n        return value;\n      })) as unknown as T;\n    }\n    const nodeInfo = await this.client.send('DOM.describeNode', {\n      objectId: handle.id,\n    });\n    return (await this.adoptBackendNode(nodeInfo.node.backendNodeId)) as T;\n  }\n\n  async transferHandle<T extends JSHandle<Node>>(handle: T): Promise<T> {\n    if (handle.realm === this) {\n      return handle;\n    }\n    // Implies it's a primitive value, probably.\n    if (handle.remoteObject().objectId === undefined) {\n      return handle;\n    }\n    const info = await this.client.send('DOM.describeNode', {\n      objectId: handle.remoteObject().objectId,\n    });\n    const newHandle = (await this.adoptBackendNode(\n      info.node.backendNodeId\n    )) as T;\n    await handle.dispose();\n    return newHandle;\n  }\n\n  /**\n   * @internal\n   */\n  createCdpHandle(\n    remoteObject: Protocol.Runtime.RemoteObject\n  ): JSHandle | ElementHandle<Node> {\n    if (remoteObject.subtype === 'node') {\n      return new CdpElementHandle(this, remoteObject);\n    }\n    return new CdpJSHandle(this, remoteObject);\n  }\n\n  [disposeSymbol](): void {\n    this.#context?.[disposeSymbol]();\n    this.#emitter.emit('disposed', undefined);\n    super[disposeSymbol]();\n    this.#emitter.removeAllListeners();\n  }\n}\n"],"mappings":"AAAA;;;;;AAQA,SAAQA,cAAc,EAAEC,GAAG,EAAEC,QAAQ,QAAO,gCAAgC;AAI5E,SAAQC,KAAK,QAAO,iBAAiB;AACrC,SAAQC,YAAY,QAAO,2BAA2B;AAGtD,SACEC,gBAAgB,EAChBC,OAAO,EACPC,4BAA4B,QACvB,mBAAmB;AAC1B,SAAQC,aAAa,QAAO,uBAAuB;AAEnD,SAAQC,gBAAgB,QAAO,oBAAoB;AAInD,SAAQC,WAAW,QAAO,eAAe;AAkCzC;;;AAGA,OAAM,MAAOC,aAAc,SAAQR,KAAK;EACtC,CAAAS,OAAQ;EACR,CAAAC,OAAQ,GAAyB,IAAIT,YAAY,EAAE;EAE1C,CAAAU,aAAc;EAEvBC,YACED,aAAsC,EACtCE,eAAgC;IAEhC,KAAK,CAACA,eAAe,CAAC;IACtB,IAAI,CAAC,CAAAF,aAAc,GAAGA,aAAa;EACrC;EAEA,IAAIG,WAAWA,CAAA;IACb,OAAO,IAAI,CAAC,CAAAH,aAAc;EAC5B;EAEA,IAAII,MAAMA,CAAA;IACR,OAAO,IAAI,CAAC,CAAAJ,aAAc,CAACI,MAAM;EACnC;EAEA,IAAIL,OAAOA,CAAA;IACT,OAAO,IAAI,CAAC,CAAAA,OAAQ;EACtB;EAEAM,UAAUA,CAACP,OAAyB;IAClC,IAAI,CAAC,CAAAA,OAAQ,GAAGJ,aAAa,CAAC,EAAE;IAChCI,OAAO,CAACQ,IAAI,CAAC,UAAU,EAAE,IAAI,CAAC,CAAAC,iBAAkB,CAACC,IAAI,CAAC,IAAI,CAAC,CAAC;IAC5DV,OAAO,CAACW,EAAE,CAAC,kBAAkB,EAAE,IAAI,CAAC,CAAAC,yBAA0B,CAACF,IAAI,CAAC,IAAI,CAAC,CAAC;IAC1EV,OAAO,CAACW,EAAE,CAAC,eAAe,EAAE,IAAI,CAAC,CAAAE,sBAAuB,CAACH,IAAI,CAAC,IAAI,CAAC,CAAC;IACpE,IAAI,CAAC,CAAAV,OAAQ,GAAGA,OAAO;IACvB,IAAI,CAAC,CAAAC,OAAQ,CAACa,IAAI,CAAC,SAAS,EAAEd,OAAO,CAAC;IACtC,KAAK,IAAI,CAACe,WAAW,CAACC,QAAQ,EAAE;EAClC;EAEA,CAAAP,iBAAkBQ,CAAA;IAChB,IAAI,CAAC,CAAAjB,OAAQ,GAAGkB,SAAS;IACzB,IAAI,qBAAqB,IAAI,IAAI,CAAC,CAAAhB,aAAc,EAAE;MAChD,IAAI,CAAC,CAAAA,aAAc,CAACiB,mBAAmB,EAAE;IAC3C;EACF;EAEA,CAAAP,yBAA0BQ,CACxBC,KAA6C;IAE7C,IAAI,CAAC,CAAApB,OAAQ,CAACa,IAAI,CAAC,kBAAkB,EAAEO,KAAK,CAAC;EAC/C;EAEA,CAAAR,sBAAuBS,CAACD,KAA0C;IAChE,IAAI,CAAC,CAAApB,OAAQ,CAACa,IAAI,CAAC,eAAe,EAAEO,KAAK,CAAC;EAC5C;EAEAE,UAAUA,CAAA;IACR,OAAO,CAAC,CAAC,IAAI,CAAC,CAAAvB,OAAQ;EACxB;EAEA,IAAIA,OAAOA,CAAA;IACT,OAAO,IAAI,CAAC,CAAAA,OAAQ;EACtB;EAEA,CAAAwB,gBAAiBC,CAAA;IACf,IAAI,IAAI,CAACC,QAAQ,EAAE;MACjB,MAAM,IAAIC,KAAK,CACb,mEAAmE,IAAI,CAACtB,WAAW,CAACuB,GAAG,EAAE,iCAAiC,CAC3H;IACH;IACA,OAAO,IAAI,CAAC,CAAA5B,OAAQ;EACtB;EAEA;;;EAGA,MAAM,CAAA6B,uBAAwBC,CAAA;IAC5B,MAAMC,MAAM,GAAG,MAAM3C,cAAc,CACjCK,gBAAgB,CAAC,IAAI,CAAC,CAAAQ,OAAQ,EAAE,SAAS,CAAC,CAAC+B,IAAI,CAC7C1C,QAAQ,CACNG,gBAAgB,CAAC,IAAI,CAAC,CAAAQ,OAAQ,EAAE,UAAU,CAAC,CAAC+B,IAAI,CAC9C3C,GAAG,CAAC,MAAK;MACP;MACA,MAAM,IAAIsC,KAAK,CAAC,iCAAiC,CAAC;IACpD,CAAC,CAAC,CACH,EACDjC,OAAO,CAAC,IAAI,CAACU,eAAe,CAACV,OAAO,EAAE,CAAC,CACxC,CACF,CACF;IACD,OAAOqC,MAAM;EACf;EAEA,MAAME,cAAcA,CAIlBC,YAA2B,EAC3B,GAAGC,IAAY;IAEfD,YAAY,GAAGvC,4BAA4B,CACzC,IAAI,CAACsC,cAAc,CAACG,IAAI,EACxBF,YAAY,CACb;IACD;IACA;IACA;IACA,IAAIlC,OAAO,GAAG,IAAI,CAAC,CAAAwB,gBAAiB,EAAE;IACtC,IAAI,CAACxB,OAAO,EAAE;MACZA,OAAO,GAAG,MAAM,IAAI,CAAC,CAAA6B,uBAAwB,EAAE;IACjD;IACA,OAAO,MAAM7B,OAAO,CAACiC,cAAc,CAACC,YAAY,EAAE,GAAGC,IAAI,CAAC;EAC5D;EAEA,MAAME,QAAQA,CAIZH,YAA2B,EAC3B,GAAGC,IAAY;IAEfD,YAAY,GAAGvC,4BAA4B,CACzC,IAAI,CAAC0C,QAAQ,CAACD,IAAI,EAClBF,YAAY,CACb;IACD;IACA;IACA;IACA,IAAIlC,OAAO,GAAG,IAAI,CAAC,CAAAwB,gBAAiB,EAAE;IACtC,IAAI,CAACxB,OAAO,EAAE;MACZA,OAAO,GAAG,MAAM,IAAI,CAAC,CAAA6B,uBAAwB,EAAE;IACjD;IACA,OAAO,MAAM7B,OAAO,CAACqC,QAAQ,CAACH,YAAY,EAAE,GAAGC,IAAI,CAAC;EACtD;EAES,MAAMG,gBAAgBA,CAC7BC,aAA0C;IAE1C;IACA;IACA;IACA,IAAIvC,OAAO,GAAG,IAAI,CAAC,CAAAwB,gBAAiB,EAAE;IACtC,IAAI,CAACxB,OAAO,EAAE;MACZA,OAAO,GAAG,MAAM,IAAI,CAAC,CAAA6B,uBAAwB,EAAE;IACjD;IACA,MAAM;MAACW;IAAM,CAAC,GAAG,MAAM,IAAI,CAAClC,MAAM,CAACmC,IAAI,CAAC,iBAAiB,EAAE;MACzDF,aAAa,EAAEA,aAAa;MAC5BG,kBAAkB,EAAE1C,OAAO,CAAC2C;KAC7B,CAAC;IACF,OAAO,IAAI,CAACC,eAAe,CAACJ,MAAM,CAAmB;EACvD;EAEA,MAAMK,WAAWA,CAA2BC,MAAS;IACnD,IAAIA,MAAM,CAACC,KAAK,KAAK,IAAI,EAAE;MACzB;MACA;MACA,OAAQ,MAAMD,MAAM,CAACb,cAAc,CAACe,KAAK,IAAG;QAC1C,OAAOA,KAAK;MACd,CAAC,CAAC;IACJ;IACA,MAAMC,QAAQ,GAAG,MAAM,IAAI,CAAC3C,MAAM,CAACmC,IAAI,CAAC,kBAAkB,EAAE;MAC1DS,QAAQ,EAAEJ,MAAM,CAACH;KAClB,CAAC;IACF,OAAQ,MAAM,IAAI,CAACL,gBAAgB,CAACW,QAAQ,CAACE,IAAI,CAACZ,aAAa,CAAC;EAClE;EAEA,MAAMa,cAAcA,CAA2BN,MAAS;IACtD,IAAIA,MAAM,CAACC,KAAK,KAAK,IAAI,EAAE;MACzB,OAAOD,MAAM;IACf;IACA;IACA,IAAIA,MAAM,CAACO,YAAY,EAAE,CAACH,QAAQ,KAAKhC,SAAS,EAAE;MAChD,OAAO4B,MAAM;IACf;IACA,MAAMQ,IAAI,GAAG,MAAM,IAAI,CAAChD,MAAM,CAACmC,IAAI,CAAC,kBAAkB,EAAE;MACtDS,QAAQ,EAAEJ,MAAM,CAACO,YAAY,EAAE,CAACH;KACjC,CAAC;IACF,MAAMK,SAAS,GAAI,MAAM,IAAI,CAACjB,gBAAgB,CAC5CgB,IAAI,CAACH,IAAI,CAACZ,aAAa,CAClB;IACP,MAAMO,MAAM,CAACU,OAAO,EAAE;IACtB,OAAOD,SAAS;EAClB;EAEA;;;EAGAX,eAAeA,CACbS,YAA2C;IAE3C,IAAIA,YAAY,CAACI,OAAO,KAAK,MAAM,EAAE;MACnC,OAAO,IAAI5D,gBAAgB,CAAC,IAAI,EAAEwD,YAAY,CAAC;IACjD;IACA,OAAO,IAAIvD,WAAW,CAAC,IAAI,EAAEuD,YAAY,CAAC;EAC5C;EAEA,CAACzD,aAAa,IAAC;IACb,IAAI,CAAC,CAAAI,OAAQ,GAAGJ,aAAa,CAAC,EAAE;IAChC,IAAI,CAAC,CAAAK,OAAQ,CAACa,IAAI,CAAC,UAAU,EAAEI,SAAS,CAAC;IACzC,KAAK,CAACtB,aAAa,CAAC,EAAE;IACtB,IAAI,CAAC,CAAAK,OAAQ,CAACyD,kBAAkB,EAAE;EACpC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}