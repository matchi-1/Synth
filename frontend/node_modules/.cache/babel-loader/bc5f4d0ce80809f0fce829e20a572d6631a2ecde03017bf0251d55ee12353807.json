{"ast":null,"code":"const tabTargetInfo = {\n  targetId: 'tabTargetId',\n  type: 'tab',\n  title: 'tab',\n  url: 'about:blank',\n  attached: false,\n  canAccessOpener: false\n};\nconst pageTargetInfo = {\n  targetId: 'pageTargetId',\n  type: 'page',\n  title: 'page',\n  url: 'about:blank',\n  attached: false,\n  canAccessOpener: false\n};\n/**\n * Experimental ExtensionTransport allows establishing a connection via\n * chrome.debugger API if Puppeteer runs in an extension. Since Chrome\n * DevTools Protocol is restricted for extensions, the transport\n * implements missing commands and events.\n *\n * @experimental\n * @public\n */\nexport class ExtensionTransport {\n  static async connectTab(tabId) {\n    await chrome.debugger.attach({\n      tabId\n    }, '1.3');\n    return new ExtensionTransport(tabId);\n  }\n  onmessage;\n  onclose;\n  #tabId;\n  /**\n   * @internal\n   */\n  constructor(tabId) {\n    this.#tabId = tabId;\n    chrome.debugger.onEvent.addListener(this.#debuggerEventHandler);\n  }\n  #debuggerEventHandler = (source, method, params) => {\n    if (source.tabId !== this.#tabId) {\n      return;\n    }\n    this.#dispatchResponse({\n      // @ts-expect-error sessionId is not in stable yet.\n      sessionId: source.sessionId ?? 'pageTargetSessionId',\n      method: method,\n      params: params\n    });\n  };\n  #dispatchResponse(message) {\n    this.onmessage?.(JSON.stringify(message));\n  }\n  send(message) {\n    const parsed = JSON.parse(message);\n    switch (parsed.method) {\n      case 'Browser.getVersion':\n        {\n          this.#dispatchResponse({\n            id: parsed.id,\n            sessionId: parsed.sessionId,\n            method: parsed.method,\n            result: {\n              protocolVersion: '1.3',\n              product: 'chrome',\n              revision: 'unknown',\n              userAgent: 'chrome',\n              jsVersion: 'unknown'\n            }\n          });\n          return;\n        }\n      case 'Target.getBrowserContexts':\n        {\n          this.#dispatchResponse({\n            id: parsed.id,\n            sessionId: parsed.sessionId,\n            method: parsed.method,\n            result: {\n              browserContextIds: []\n            }\n          });\n          return;\n        }\n      case 'Target.setDiscoverTargets':\n        {\n          this.#dispatchResponse({\n            method: 'Target.targetCreated',\n            params: {\n              targetInfo: tabTargetInfo\n            }\n          });\n          this.#dispatchResponse({\n            method: 'Target.targetCreated',\n            params: {\n              targetInfo: pageTargetInfo\n            }\n          });\n          this.#dispatchResponse({\n            id: parsed.id,\n            sessionId: parsed.sessionId,\n            method: parsed.method,\n            result: {}\n          });\n          return;\n        }\n      case 'Target.setAutoAttach':\n        {\n          if (parsed.sessionId === 'tabTargetSessionId') {\n            this.#dispatchResponse({\n              method: 'Target.attachedToTarget',\n              params: {\n                targetInfo: pageTargetInfo,\n                sessionId: 'pageTargetSessionId'\n              }\n            });\n          } else if (!parsed.sessionId) {\n            this.#dispatchResponse({\n              method: 'Target.attachedToTarget',\n              params: {\n                targetInfo: tabTargetInfo,\n                sessionId: 'tabTargetSessionId'\n              }\n            });\n          }\n          this.#dispatchResponse({\n            id: parsed.id,\n            sessionId: parsed.sessionId,\n            method: parsed.method,\n            result: {}\n          });\n          return;\n        }\n    }\n    if (parsed.sessionId === 'pageTargetSessionId') {\n      delete parsed.sessionId;\n    }\n    chrome.debugger.sendCommand(\n    // @ts-expect-error sessionId is not in stable yet.\n    {\n      tabId: this.#tabId,\n      sessionId: parsed.sessionId\n    }, parsed.method, parsed.params).then(response => {\n      this.#dispatchResponse({\n        id: parsed.id,\n        sessionId: parsed.sessionId ?? 'pageTargetSessionId',\n        method: parsed.method,\n        result: response\n      });\n    }).catch(err => {\n      this.#dispatchResponse({\n        id: parsed.id,\n        sessionId: parsed.sessionId ?? 'pageTargetSessionId',\n        method: parsed.method,\n        error: err\n      });\n    });\n  }\n  close() {\n    chrome.debugger.onEvent.removeListener(this.#debuggerEventHandler);\n    void chrome.debugger.detach({\n      tabId: this.#tabId\n    });\n  }\n}","map":{"version":3,"names":["tabTargetInfo","targetId","type","title","url","attached","canAccessOpener","pageTargetInfo","ExtensionTransport","connectTab","tabId","chrome","debugger","attach","onmessage","onclose","constructor","onEvent","addListener","debuggerEventHandler","#debuggerEventHandler","source","method","params","dispatchResponse","sessionId","#dispatchResponse","message","JSON","stringify","send","parsed","parse","id","result","protocolVersion","product","revision","userAgent","jsVersion","browserContextIds","targetInfo","sendCommand","then","response","catch","err","error","close","removeListener","detach"],"sources":["C:\\Users\\raffy\\Desktop\\test\\node_modules\\puppeteer-core\\src\\cdp\\ExtensionTransport.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2024 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport type {ConnectionTransport} from '../common/ConnectionTransport.js';\n\nconst tabTargetInfo = {\n  targetId: 'tabTargetId',\n  type: 'tab',\n  title: 'tab',\n  url: 'about:blank',\n  attached: false,\n  canAccessOpener: false,\n};\n\nconst pageTargetInfo = {\n  targetId: 'pageTargetId',\n  type: 'page',\n  title: 'page',\n  url: 'about:blank',\n  attached: false,\n  canAccessOpener: false,\n};\n\n/**\n * Experimental ExtensionTransport allows establishing a connection via\n * chrome.debugger API if Puppeteer runs in an extension. Since Chrome\n * DevTools Protocol is restricted for extensions, the transport\n * implements missing commands and events.\n *\n * @experimental\n * @public\n */\nexport class ExtensionTransport implements ConnectionTransport {\n  static async connectTab(tabId: number): Promise<ExtensionTransport> {\n    await chrome.debugger.attach({tabId}, '1.3');\n    return new ExtensionTransport(tabId);\n  }\n\n  onmessage?: (message: string) => void;\n  onclose?: () => void;\n\n  #tabId: number;\n\n  /**\n   * @internal\n   */\n  constructor(tabId: number) {\n    this.#tabId = tabId;\n    chrome.debugger.onEvent.addListener(this.#debuggerEventHandler);\n  }\n\n  #debuggerEventHandler = (\n    source: chrome.debugger.Debuggee,\n    method: string,\n    params?: object | undefined\n  ): void => {\n    if (source.tabId !== this.#tabId) {\n      return;\n    }\n    this.#dispatchResponse({\n      // @ts-expect-error sessionId is not in stable yet.\n      sessionId: source.sessionId ?? 'pageTargetSessionId',\n      method: method,\n      params: params,\n    });\n  };\n\n  #dispatchResponse(message: object): void {\n    this.onmessage?.(JSON.stringify(message));\n  }\n\n  send(message: string): void {\n    const parsed = JSON.parse(message);\n    switch (parsed.method) {\n      case 'Browser.getVersion': {\n        this.#dispatchResponse({\n          id: parsed.id,\n          sessionId: parsed.sessionId,\n          method: parsed.method,\n          result: {\n            protocolVersion: '1.3',\n            product: 'chrome',\n            revision: 'unknown',\n            userAgent: 'chrome',\n            jsVersion: 'unknown',\n          },\n        });\n        return;\n      }\n      case 'Target.getBrowserContexts': {\n        this.#dispatchResponse({\n          id: parsed.id,\n          sessionId: parsed.sessionId,\n          method: parsed.method,\n          result: {\n            browserContextIds: [],\n          },\n        });\n        return;\n      }\n      case 'Target.setDiscoverTargets': {\n        this.#dispatchResponse({\n          method: 'Target.targetCreated',\n          params: {\n            targetInfo: tabTargetInfo,\n          },\n        });\n        this.#dispatchResponse({\n          method: 'Target.targetCreated',\n          params: {\n            targetInfo: pageTargetInfo,\n          },\n        });\n        this.#dispatchResponse({\n          id: parsed.id,\n          sessionId: parsed.sessionId,\n          method: parsed.method,\n          result: {},\n        });\n        return;\n      }\n      case 'Target.setAutoAttach': {\n        if (parsed.sessionId === 'tabTargetSessionId') {\n          this.#dispatchResponse({\n            method: 'Target.attachedToTarget',\n            params: {\n              targetInfo: pageTargetInfo,\n              sessionId: 'pageTargetSessionId',\n            },\n          });\n        } else if (!parsed.sessionId) {\n          this.#dispatchResponse({\n            method: 'Target.attachedToTarget',\n            params: {\n              targetInfo: tabTargetInfo,\n              sessionId: 'tabTargetSessionId',\n            },\n          });\n        }\n        this.#dispatchResponse({\n          id: parsed.id,\n          sessionId: parsed.sessionId,\n          method: parsed.method,\n          result: {},\n        });\n        return;\n      }\n    }\n    if (parsed.sessionId === 'pageTargetSessionId') {\n      delete parsed.sessionId;\n    }\n    chrome.debugger\n      .sendCommand(\n        // @ts-expect-error sessionId is not in stable yet.\n        {tabId: this.#tabId, sessionId: parsed.sessionId},\n        parsed.method,\n        parsed.params\n      )\n      .then(response => {\n        this.#dispatchResponse({\n          id: parsed.id,\n          sessionId: parsed.sessionId ?? 'pageTargetSessionId',\n          method: parsed.method,\n          result: response,\n        });\n      })\n      .catch(err => {\n        this.#dispatchResponse({\n          id: parsed.id,\n          sessionId: parsed.sessionId ?? 'pageTargetSessionId',\n          method: parsed.method,\n          error: err,\n        });\n      });\n  }\n\n  close(): void {\n    chrome.debugger.onEvent.removeListener(this.#debuggerEventHandler);\n    void chrome.debugger.detach({tabId: this.#tabId});\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}