{"ast":null,"code":"/**\n * @license\n * Copyright 2017 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { firstValueFrom, from, merge, raceWith } from '../../third_party/rxjs/rxjs.js';\nimport { EventEmitter } from '../common/EventEmitter.js';\nimport { debugError, fromEmitterEvent, filterAsync, timeout, fromAbortSignal } from '../common/util.js';\nimport { asyncDisposeSymbol, disposeSymbol } from '../util/disposable.js';\n/**\n * @internal\n */\nexport const WEB_PERMISSION_TO_PROTOCOL_PERMISSION = new Map([['geolocation', 'geolocation'], ['midi', 'midi'], ['notifications', 'notifications'],\n// TODO: push isn't a valid type?\n// ['push', 'push'],\n['camera', 'videoCapture'], ['microphone', 'audioCapture'], ['background-sync', 'backgroundSync'], ['ambient-light-sensor', 'sensors'], ['accelerometer', 'sensors'], ['gyroscope', 'sensors'], ['magnetometer', 'sensors'], ['accessibility-events', 'accessibilityEvents'], ['clipboard-read', 'clipboardReadWrite'], ['clipboard-write', 'clipboardReadWrite'], ['clipboard-sanitized-write', 'clipboardSanitizedWrite'], ['payment-handler', 'paymentHandler'], ['persistent-storage', 'durableStorage'], ['idle-detection', 'idleDetection'],\n// chrome-specific permissions we have.\n['midi-sysex', 'midiSysex']]);\n/**\n * {@link Browser} represents a browser instance that is either:\n *\n * - connected to via {@link Puppeteer.connect} or\n * - launched by {@link PuppeteerNode.launch}.\n *\n * {@link Browser} {@link EventEmitter.emit | emits} various events which are\n * documented in the {@link BrowserEvent} enum.\n *\n * @example Using a {@link Browser} to create a {@link Page}:\n *\n * ```ts\n * import puppeteer from 'puppeteer';\n *\n * const browser = await puppeteer.launch();\n * const page = await browser.newPage();\n * await page.goto('https://example.com');\n * await browser.close();\n * ```\n *\n * @example Disconnecting from and reconnecting to a {@link Browser}:\n *\n * ```ts\n * import puppeteer from 'puppeteer';\n *\n * const browser = await puppeteer.launch();\n * // Store the endpoint to be able to reconnect to the browser.\n * const browserWSEndpoint = browser.wsEndpoint();\n * // Disconnect puppeteer from the browser.\n * await browser.disconnect();\n *\n * // Use the endpoint to reestablish a connection\n * const browser2 = await puppeteer.connect({browserWSEndpoint});\n * // Close the browser.\n * await browser2.close();\n * ```\n *\n * @public\n */\nexport class Browser extends EventEmitter {\n  /**\n   * @internal\n   */\n  constructor() {\n    super();\n  }\n  /**\n   * Waits until a {@link Target | target} matching the given `predicate`\n   * appears and returns it.\n   *\n   * This will look all open {@link BrowserContext | browser contexts}.\n   *\n   * @example Finding a target for a page opened via `window.open`:\n   *\n   * ```ts\n   * await page.evaluate(() => window.open('https://www.example.com/'));\n   * const newWindowTarget = await browser.waitForTarget(\n   *   target => target.url() === 'https://www.example.com/'\n   * );\n   * ```\n   */\n  async waitForTarget(predicate, options = {}) {\n    const {\n      timeout: ms = 30000,\n      signal\n    } = options;\n    return await firstValueFrom(merge(fromEmitterEvent(this, \"targetcreated\" /* BrowserEvent.TargetCreated */), fromEmitterEvent(this, \"targetchanged\" /* BrowserEvent.TargetChanged */), from(this.targets())).pipe(filterAsync(predicate), raceWith(fromAbortSignal(signal), timeout(ms))));\n  }\n  /**\n   * Gets a list of all open {@link Page | pages} inside this {@link Browser}.\n   *\n   * If there ar multiple {@link BrowserContext | browser contexts}, this\n   * returns all {@link Page | pages} in all\n   * {@link BrowserContext | browser contexts}.\n   *\n   * @remarks Non-visible {@link Page | pages}, such as `\"background_page\"`,\n   * will not be listed here. You can find them using {@link Target.page}.\n   */\n  async pages() {\n    const contextPages = await Promise.all(this.browserContexts().map(context => {\n      return context.pages();\n    }));\n    // Flatten array.\n    return contextPages.reduce((acc, x) => {\n      return acc.concat(x);\n    }, []);\n  }\n  /**\n   * Whether Puppeteer is connected to this {@link Browser | browser}.\n   *\n   * @deprecated Use {@link Browser | Browser.connected}.\n   */\n  isConnected() {\n    return this.connected;\n  }\n  /** @internal */\n  [disposeSymbol]() {\n    if (this.process()) {\n      return void this.close().catch(debugError);\n    }\n    return void this.disconnect().catch(debugError);\n  }\n  /** @internal */\n  [asyncDisposeSymbol]() {\n    if (this.process()) {\n      return this.close();\n    }\n    return this.disconnect();\n  }\n}","map":{"version":3,"names":["firstValueFrom","from","merge","raceWith","EventEmitter","debugError","fromEmitterEvent","filterAsync","timeout","fromAbortSignal","asyncDisposeSymbol","disposeSymbol","WEB_PERMISSION_TO_PROTOCOL_PERMISSION","Map","Browser","constructor","waitForTarget","predicate","options","ms","signal","targets","pipe","pages","contextPages","Promise","all","browserContexts","map","context","reduce","acc","x","concat","isConnected","connected","process","close","catch","disconnect"],"sources":["C:\\Users\\raffy\\Desktop\\test\\node_modules\\puppeteer-core\\src\\api\\Browser.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2017 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport type {ChildProcess} from 'child_process';\n\nimport type {Protocol} from 'devtools-protocol';\n\nimport {\n  firstValueFrom,\n  from,\n  merge,\n  raceWith,\n} from '../../third_party/rxjs/rxjs.js';\nimport type {ProtocolType} from '../common/ConnectOptions.js';\nimport {EventEmitter, type EventType} from '../common/EventEmitter.js';\nimport {\n  debugError,\n  fromEmitterEvent,\n  filterAsync,\n  timeout,\n  fromAbortSignal,\n} from '../common/util.js';\nimport {asyncDisposeSymbol, disposeSymbol} from '../util/disposable.js';\n\nimport type {BrowserContext} from './BrowserContext.js';\nimport type {Page} from './Page.js';\nimport type {Target} from './Target.js';\n/**\n * @public\n */\nexport interface BrowserContextOptions {\n  /**\n   * Proxy server with optional port to use for all requests.\n   * Username and password can be set in `Page.authenticate`.\n   */\n  proxyServer?: string;\n  /**\n   * Bypass the proxy for the given list of hosts.\n   */\n  proxyBypassList?: string[];\n}\n\n/**\n * @internal\n */\nexport type BrowserCloseCallback = () => Promise<void> | void;\n\n/**\n * @public\n */\nexport type TargetFilterCallback = (target: Target) => boolean;\n\n/**\n * @internal\n */\nexport type IsPageTargetCallback = (target: Target) => boolean;\n\n/**\n * @internal\n */\nexport const WEB_PERMISSION_TO_PROTOCOL_PERMISSION = new Map<\n  Permission,\n  Protocol.Browser.PermissionType\n>([\n  ['geolocation', 'geolocation'],\n  ['midi', 'midi'],\n  ['notifications', 'notifications'],\n  // TODO: push isn't a valid type?\n  // ['push', 'push'],\n  ['camera', 'videoCapture'],\n  ['microphone', 'audioCapture'],\n  ['background-sync', 'backgroundSync'],\n  ['ambient-light-sensor', 'sensors'],\n  ['accelerometer', 'sensors'],\n  ['gyroscope', 'sensors'],\n  ['magnetometer', 'sensors'],\n  ['accessibility-events', 'accessibilityEvents'],\n  ['clipboard-read', 'clipboardReadWrite'],\n  ['clipboard-write', 'clipboardReadWrite'],\n  ['clipboard-sanitized-write', 'clipboardSanitizedWrite'],\n  ['payment-handler', 'paymentHandler'],\n  ['persistent-storage', 'durableStorage'],\n  ['idle-detection', 'idleDetection'],\n  // chrome-specific permissions we have.\n  ['midi-sysex', 'midiSysex'],\n]);\n\n/**\n * @public\n */\nexport type Permission =\n  | 'geolocation'\n  | 'midi'\n  | 'notifications'\n  | 'camera'\n  | 'microphone'\n  | 'background-sync'\n  | 'ambient-light-sensor'\n  | 'accelerometer'\n  | 'gyroscope'\n  | 'magnetometer'\n  | 'accessibility-events'\n  | 'clipboard-read'\n  | 'clipboard-write'\n  | 'clipboard-sanitized-write'\n  | 'payment-handler'\n  | 'persistent-storage'\n  | 'idle-detection'\n  | 'midi-sysex';\n\n/**\n * @public\n */\nexport interface WaitForTargetOptions {\n  /**\n   * Maximum wait time in milliseconds. Pass `0` to disable the timeout.\n   *\n   * @defaultValue `30_000`\n   */\n  timeout?: number;\n\n  /**\n   * A signal object that allows you to cancel a waitFor call.\n   */\n  signal?: AbortSignal;\n}\n\n/**\n * All the events a {@link Browser | browser instance} may emit.\n *\n * @public\n */\nexport const enum BrowserEvent {\n  /**\n   * Emitted when Puppeteer gets disconnected from the browser instance. This\n   * might happen because either:\n   *\n   * - The browser closes/crashes or\n   * - {@link Browser.disconnect} was called.\n   */\n  Disconnected = 'disconnected',\n  /**\n   * Emitted when the URL of a target changes. Contains a {@link Target}\n   * instance.\n   *\n   * @remarks Note that this includes target changes in all browser\n   * contexts.\n   */\n  TargetChanged = 'targetchanged',\n  /**\n   * Emitted when a target is created, for example when a new page is opened by\n   * {@link https://developer.mozilla.org/en-US/docs/Web/API/Window/open | window.open}\n   * or by {@link Browser.newPage | browser.newPage}\n   *\n   * Contains a {@link Target} instance.\n   *\n   * @remarks Note that this includes target creations in all browser\n   * contexts.\n   */\n  TargetCreated = 'targetcreated',\n  /**\n   * Emitted when a target is destroyed, for example when a page is closed.\n   * Contains a {@link Target} instance.\n   *\n   * @remarks Note that this includes target destructions in all browser\n   * contexts.\n   */\n  TargetDestroyed = 'targetdestroyed',\n  /**\n   * @internal\n   */\n  TargetDiscovered = 'targetdiscovered',\n}\n\n/**\n * @public\n */\nexport interface BrowserEvents extends Record<EventType, unknown> {\n  [BrowserEvent.Disconnected]: undefined;\n  [BrowserEvent.TargetCreated]: Target;\n  [BrowserEvent.TargetDestroyed]: Target;\n  [BrowserEvent.TargetChanged]: Target;\n  /**\n   * @internal\n   */\n  [BrowserEvent.TargetDiscovered]: Protocol.Target.TargetInfo;\n}\n\n/**\n * @public\n * @experimental\n */\nexport interface DebugInfo {\n  pendingProtocolErrors: Error[];\n}\n\n/**\n * {@link Browser} represents a browser instance that is either:\n *\n * - connected to via {@link Puppeteer.connect} or\n * - launched by {@link PuppeteerNode.launch}.\n *\n * {@link Browser} {@link EventEmitter.emit | emits} various events which are\n * documented in the {@link BrowserEvent} enum.\n *\n * @example Using a {@link Browser} to create a {@link Page}:\n *\n * ```ts\n * import puppeteer from 'puppeteer';\n *\n * const browser = await puppeteer.launch();\n * const page = await browser.newPage();\n * await page.goto('https://example.com');\n * await browser.close();\n * ```\n *\n * @example Disconnecting from and reconnecting to a {@link Browser}:\n *\n * ```ts\n * import puppeteer from 'puppeteer';\n *\n * const browser = await puppeteer.launch();\n * // Store the endpoint to be able to reconnect to the browser.\n * const browserWSEndpoint = browser.wsEndpoint();\n * // Disconnect puppeteer from the browser.\n * await browser.disconnect();\n *\n * // Use the endpoint to reestablish a connection\n * const browser2 = await puppeteer.connect({browserWSEndpoint});\n * // Close the browser.\n * await browser2.close();\n * ```\n *\n * @public\n */\nexport abstract class Browser extends EventEmitter<BrowserEvents> {\n  /**\n   * @internal\n   */\n  constructor() {\n    super();\n  }\n\n  /**\n   * Gets the associated\n   * {@link https://nodejs.org/api/child_process.html#class-childprocess | ChildProcess}.\n   *\n   * @returns `null` if this instance was connected to via\n   * {@link Puppeteer.connect}.\n   */\n  abstract process(): ChildProcess | null;\n\n  /**\n   * Creates a new {@link BrowserContext | browser context}.\n   *\n   * This won't share cookies/cache with other {@link BrowserContext | browser contexts}.\n   *\n   * @example\n   *\n   * ```ts\n   * import puppeteer from 'puppeteer';\n   *\n   * const browser = await puppeteer.launch();\n   * // Create a new browser context.\n   * const context = await browser.createBrowserContext();\n   * // Create a new page in a pristine context.\n   * const page = await context.newPage();\n   * // Do stuff\n   * await page.goto('https://example.com');\n   * ```\n   */\n  abstract createBrowserContext(\n    options?: BrowserContextOptions\n  ): Promise<BrowserContext>;\n\n  /**\n   * Gets a list of open {@link BrowserContext | browser contexts}.\n   *\n   * In a newly-created {@link Browser | browser}, this will return a single\n   * instance of {@link BrowserContext}.\n   */\n  abstract browserContexts(): BrowserContext[];\n\n  /**\n   * Gets the default {@link BrowserContext | browser context}.\n   *\n   * @remarks The default {@link BrowserContext | browser context} cannot be\n   * closed.\n   */\n  abstract defaultBrowserContext(): BrowserContext;\n\n  /**\n   * Gets the WebSocket URL to connect to this {@link Browser | browser}.\n   *\n   * This is usually used with {@link Puppeteer.connect}.\n   *\n   * You can find the debugger URL (`webSocketDebuggerUrl`) from\n   * `http://HOST:PORT/json/version`.\n   *\n   * See {@link\n   * https://chromedevtools.github.io/devtools-protocol/#how-do-i-access-the-browser-target\n   * | browser endpoint} for more information.\n   *\n   * @remarks The format is always `ws://HOST:PORT/devtools/browser/<id>`.\n   */\n  abstract wsEndpoint(): string;\n\n  /**\n   * Creates a new {@link Page | page} in the\n   * {@link Browser.defaultBrowserContext | default browser context}.\n   */\n  abstract newPage(): Promise<Page>;\n\n  /**\n   * Gets all active {@link Target | targets}.\n   *\n   * In case of multiple {@link BrowserContext | browser contexts}, this returns\n   * all {@link Target | targets} in all\n   * {@link BrowserContext | browser contexts}.\n   */\n  abstract targets(): Target[];\n\n  /**\n   * Gets the {@link Target | target} associated with the\n   * {@link Browser.defaultBrowserContext | default browser context}).\n   */\n  abstract target(): Target;\n\n  /**\n   * Waits until a {@link Target | target} matching the given `predicate`\n   * appears and returns it.\n   *\n   * This will look all open {@link BrowserContext | browser contexts}.\n   *\n   * @example Finding a target for a page opened via `window.open`:\n   *\n   * ```ts\n   * await page.evaluate(() => window.open('https://www.example.com/'));\n   * const newWindowTarget = await browser.waitForTarget(\n   *   target => target.url() === 'https://www.example.com/'\n   * );\n   * ```\n   */\n  async waitForTarget(\n    predicate: (x: Target) => boolean | Promise<boolean>,\n    options: WaitForTargetOptions = {}\n  ): Promise<Target> {\n    const {timeout: ms = 30000, signal} = options;\n    return await firstValueFrom(\n      merge(\n        fromEmitterEvent(this, BrowserEvent.TargetCreated),\n        fromEmitterEvent(this, BrowserEvent.TargetChanged),\n        from(this.targets())\n      ).pipe(\n        filterAsync(predicate),\n        raceWith(fromAbortSignal(signal), timeout(ms))\n      )\n    );\n  }\n\n  /**\n   * Gets a list of all open {@link Page | pages} inside this {@link Browser}.\n   *\n   * If there ar multiple {@link BrowserContext | browser contexts}, this\n   * returns all {@link Page | pages} in all\n   * {@link BrowserContext | browser contexts}.\n   *\n   * @remarks Non-visible {@link Page | pages}, such as `\"background_page\"`,\n   * will not be listed here. You can find them using {@link Target.page}.\n   */\n  async pages(): Promise<Page[]> {\n    const contextPages = await Promise.all(\n      this.browserContexts().map(context => {\n        return context.pages();\n      })\n    );\n    // Flatten array.\n    return contextPages.reduce((acc, x) => {\n      return acc.concat(x);\n    }, []);\n  }\n\n  /**\n   * Gets a string representing this {@link Browser | browser's} name and\n   * version.\n   *\n   * For headless browser, this is similar to `\"HeadlessChrome/61.0.3153.0\"`. For\n   * non-headless or new-headless, this is similar to `\"Chrome/61.0.3153.0\"`. For\n   * Firefox, it is similar to `\"Firefox/116.0a1\"`.\n   *\n   * The format of {@link Browser.version} might change with future releases of\n   * browsers.\n   */\n  abstract version(): Promise<string>;\n\n  /**\n   * Gets this {@link Browser | browser's} original user agent.\n   *\n   * {@link Page | Pages} can override the user agent with\n   * {@link Page.setUserAgent}.\n   *\n   */\n  abstract userAgent(): Promise<string>;\n\n  /**\n   * Closes this {@link Browser | browser} and all associated\n   * {@link Page | pages}.\n   */\n  abstract close(): Promise<void>;\n\n  /**\n   * Disconnects Puppeteer from this {@link Browser | browser}, but leaves the\n   * process running.\n   */\n  abstract disconnect(): Promise<void>;\n\n  /**\n   * Whether Puppeteer is connected to this {@link Browser | browser}.\n   *\n   * @deprecated Use {@link Browser | Browser.connected}.\n   */\n  isConnected(): boolean {\n    return this.connected;\n  }\n\n  /**\n   * Whether Puppeteer is connected to this {@link Browser | browser}.\n   */\n  abstract get connected(): boolean;\n\n  /** @internal */\n  [disposeSymbol](): void {\n    if (this.process()) {\n      return void this.close().catch(debugError);\n    }\n    return void this.disconnect().catch(debugError);\n  }\n\n  /** @internal */\n  [asyncDisposeSymbol](): Promise<void> {\n    if (this.process()) {\n      return this.close();\n    }\n    return this.disconnect();\n  }\n\n  /**\n   * @internal\n   */\n  abstract get protocol(): ProtocolType;\n\n  /**\n   * Get debug information from Puppeteer.\n   *\n   * @remarks\n   *\n   * Currently, includes pending protocol calls. In the future, we might add more info.\n   *\n   * @public\n   * @experimental\n   */\n  abstract get debugInfo(): DebugInfo;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}