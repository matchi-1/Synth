{"ast":null,"code":"/**\n * @license\n * Copyright 2017 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\nvar __addDisposableResource = this && this.__addDisposableResource || function (env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose;\n    if (async) {\n      if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n      dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n      if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n      dispose = value[Symbol.dispose];\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    env.stack.push({\n      value: value,\n      dispose: dispose,\n      async: async\n    });\n  } else if (async) {\n    env.stack.push({\n      async: true\n    });\n  }\n  return value;\n};\nvar __disposeResources = this && this.__disposeResources || function (SuppressedError) {\n  return function (env) {\n    function fail(e) {\n      env.error = env.hasError ? new SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n      env.hasError = true;\n    }\n    function next() {\n      while (env.stack.length) {\n        var rec = env.stack.pop();\n        try {\n          var result = rec.dispose && rec.dispose.call(rec.value);\n          if (rec.async) return Promise.resolve(result).then(next, function (e) {\n            fail(e);\n            return next();\n          });\n        } catch (e) {\n          fail(e);\n        }\n      }\n      if (env.hasError) throw env.error;\n    }\n    return next();\n  };\n}(typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n});\nimport { CDPSessionEvent } from '../api/CDPSession.js';\nimport { EventEmitter } from '../common/EventEmitter.js';\nimport { LazyArg } from '../common/LazyArg.js';\nimport { scriptInjector } from '../common/ScriptInjector.js';\nimport { PuppeteerURL, SOURCE_URL_REGEX, debugError, getSourcePuppeteerURLIfAvailable, getSourceUrlComment, isString } from '../common/util.js';\nimport { AsyncIterableUtil } from '../util/AsyncIterableUtil.js';\nimport { DisposableStack, disposeSymbol } from '../util/disposable.js';\nimport { stringifyFunction } from '../util/Function.js';\nimport { Mutex } from '../util/Mutex.js';\nimport { ARIAQueryHandler } from './AriaQueryHandler.js';\nimport { Binding } from './Binding.js';\nimport { CdpElementHandle } from './ElementHandle.js';\nimport { CdpJSHandle } from './JSHandle.js';\nimport { addPageBinding, CDP_BINDING_PREFIX, createEvaluationError, valueFromRemoteObject } from './utils.js';\nconst ariaQuerySelectorBinding = new Binding('__ariaQuerySelector', ARIAQueryHandler.queryOne, '' // custom init\n);\nconst ariaQuerySelectorAllBinding = new Binding('__ariaQuerySelectorAll', async (element, selector) => {\n  const results = ARIAQueryHandler.queryAll(element, selector);\n  return await element.realm.evaluateHandle((...elements) => {\n    return elements;\n  }, ...(await AsyncIterableUtil.collect(results)));\n}, '' // custom init\n);\n/**\n * @internal\n */\nexport class ExecutionContext extends EventEmitter {\n  #client;\n  #world;\n  #id;\n  #name;\n  #disposables = new DisposableStack();\n  constructor(client, contextPayload, world) {\n    super();\n    this.#client = client;\n    this.#world = world;\n    this.#id = contextPayload.id;\n    if (contextPayload.name) {\n      this.#name = contextPayload.name;\n    }\n    const clientEmitter = this.#disposables.use(new EventEmitter(this.#client));\n    clientEmitter.on('Runtime.bindingCalled', this.#onBindingCalled.bind(this));\n    clientEmitter.on('Runtime.executionContextDestroyed', async event => {\n      if (event.executionContextId === this.#id) {\n        this[disposeSymbol]();\n      }\n    });\n    clientEmitter.on('Runtime.executionContextsCleared', async () => {\n      this[disposeSymbol]();\n    });\n    clientEmitter.on('Runtime.consoleAPICalled', this.#onConsoleAPI.bind(this));\n    clientEmitter.on(CDPSessionEvent.Disconnected, () => {\n      this[disposeSymbol]();\n    });\n  }\n  // Contains mapping from functions that should be bound to Puppeteer functions.\n  #bindings = new Map();\n  // If multiple waitFor are set up asynchronously, we need to wait for the\n  // first one to set up the binding in the page before running the others.\n  #mutex = new Mutex();\n  async #addBinding(binding) {\n    const env_1 = {\n      stack: [],\n      error: void 0,\n      hasError: false\n    };\n    try {\n      if (this.#bindings.has(binding.name)) {\n        return;\n      }\n      const _ = __addDisposableResource(env_1, await this.#mutex.acquire(), false);\n      try {\n        await this.#client.send('Runtime.addBinding', this.#name ? {\n          name: CDP_BINDING_PREFIX + binding.name,\n          executionContextName: this.#name\n        } : {\n          name: CDP_BINDING_PREFIX + binding.name,\n          executionContextId: this.#id\n        });\n        await this.evaluate(addPageBinding, 'internal', binding.name, CDP_BINDING_PREFIX);\n        this.#bindings.set(binding.name, binding);\n      } catch (error) {\n        // We could have tried to evaluate in a context which was already\n        // destroyed. This happens, for example, if the page is navigated while\n        // we are trying to add the binding\n        if (error instanceof Error) {\n          // Destroyed context.\n          if (error.message.includes('Execution context was destroyed')) {\n            return;\n          }\n          // Missing context.\n          if (error.message.includes('Cannot find context with specified id')) {\n            return;\n          }\n        }\n        debugError(error);\n      }\n    } catch (e_1) {\n      env_1.error = e_1;\n      env_1.hasError = true;\n    } finally {\n      __disposeResources(env_1);\n    }\n  }\n  async #onBindingCalled(event) {\n    if (event.executionContextId !== this.#id) {\n      return;\n    }\n    let payload;\n    try {\n      payload = JSON.parse(event.payload);\n    } catch {\n      // The binding was either called by something in the page or it was\n      // called before our wrapper was initialized.\n      return;\n    }\n    const {\n      type,\n      name,\n      seq,\n      args,\n      isTrivial\n    } = payload;\n    if (type !== 'internal') {\n      this.emit('bindingcalled', event);\n      return;\n    }\n    if (!this.#bindings.has(name)) {\n      this.emit('bindingcalled', event);\n      return;\n    }\n    try {\n      const binding = this.#bindings.get(name);\n      await binding?.run(this, seq, args, isTrivial);\n    } catch (err) {\n      debugError(err);\n    }\n  }\n  get id() {\n    return this.#id;\n  }\n  #onConsoleAPI(event) {\n    if (event.executionContextId !== this.#id) {\n      return;\n    }\n    this.emit('consoleapicalled', event);\n  }\n  #bindingsInstalled = false;\n  #puppeteerUtil;\n  get puppeteerUtil() {\n    let promise = Promise.resolve();\n    if (!this.#bindingsInstalled) {\n      promise = Promise.all([this.#addBindingWithoutThrowing(ariaQuerySelectorBinding), this.#addBindingWithoutThrowing(ariaQuerySelectorAllBinding)]);\n      this.#bindingsInstalled = true;\n    }\n    scriptInjector.inject(script => {\n      if (this.#puppeteerUtil) {\n        void this.#puppeteerUtil.then(handle => {\n          void handle.dispose();\n        });\n      }\n      this.#puppeteerUtil = promise.then(() => {\n        return this.evaluateHandle(script);\n      });\n    }, !this.#puppeteerUtil);\n    return this.#puppeteerUtil;\n  }\n  async #addBindingWithoutThrowing(binding) {\n    try {\n      await this.#addBinding(binding);\n    } catch (err) {\n      // If the binding cannot be added, then either the browser doesn't support\n      // bindings (e.g. Firefox) or the context is broken. Either breakage is\n      // okay, so we ignore the error.\n      debugError(err);\n    }\n  }\n  /**\n   * Evaluates the given function.\n   *\n   * @example\n   *\n   * ```ts\n   * const executionContext = await page.mainFrame().executionContext();\n   * const result = await executionContext.evaluate(() => Promise.resolve(8 * 7))* ;\n   * console.log(result); // prints \"56\"\n   * ```\n   *\n   * @example\n   * A string can also be passed in instead of a function:\n   *\n   * ```ts\n   * console.log(await executionContext.evaluate('1 + 2')); // prints \"3\"\n   * ```\n   *\n   * @example\n   * Handles can also be passed as `args`. They resolve to their referenced object:\n   *\n   * ```ts\n   * const oneHandle = await executionContext.evaluateHandle(() => 1);\n   * const twoHandle = await executionContext.evaluateHandle(() => 2);\n   * const result = await executionContext.evaluate(\n   *   (a, b) => a + b,\n   *   oneHandle,\n   *   twoHandle\n   * );\n   * await oneHandle.dispose();\n   * await twoHandle.dispose();\n   * console.log(result); // prints '3'.\n   * ```\n   *\n   * @param pageFunction - The function to evaluate.\n   * @param args - Additional arguments to pass into the function.\n   * @returns The result of evaluating the function. If the result is an object,\n   * a vanilla object containing the serializable properties of the result is\n   * returned.\n   */\n  async evaluate(pageFunction, ...args) {\n    return await this.#evaluate(true, pageFunction, ...args);\n  }\n  /**\n   * Evaluates the given function.\n   *\n   * Unlike {@link ExecutionContext.evaluate | evaluate}, this method returns a\n   * handle to the result of the function.\n   *\n   * This method may be better suited if the object cannot be serialized (e.g.\n   * `Map`) and requires further manipulation.\n   *\n   * @example\n   *\n   * ```ts\n   * const context = await page.mainFrame().executionContext();\n   * const handle: JSHandle<typeof globalThis> = await context.evaluateHandle(\n   *   () => Promise.resolve(self)\n   * );\n   * ```\n   *\n   * @example\n   * A string can also be passed in instead of a function.\n   *\n   * ```ts\n   * const handle: JSHandle<number> = await context.evaluateHandle('1 + 2');\n   * ```\n   *\n   * @example\n   * Handles can also be passed as `args`. They resolve to their referenced object:\n   *\n   * ```ts\n   * const bodyHandle: ElementHandle<HTMLBodyElement> =\n   *   await context.evaluateHandle(() => {\n   *     return document.body;\n   *   });\n   * const stringHandle: JSHandle<string> = await context.evaluateHandle(\n   *   body => body.innerHTML,\n   *   body\n   * );\n   * console.log(await stringHandle.jsonValue()); // prints body's innerHTML\n   * // Always dispose your garbage! :)\n   * await bodyHandle.dispose();\n   * await stringHandle.dispose();\n   * ```\n   *\n   * @param pageFunction - The function to evaluate.\n   * @param args - Additional arguments to pass into the function.\n   * @returns A {@link JSHandle | handle} to the result of evaluating the\n   * function. If the result is a `Node`, then this will return an\n   * {@link ElementHandle | element handle}.\n   */\n  async evaluateHandle(pageFunction, ...args) {\n    return await this.#evaluate(false, pageFunction, ...args);\n  }\n  async #evaluate(returnByValue, pageFunction, ...args) {\n    const sourceUrlComment = getSourceUrlComment(getSourcePuppeteerURLIfAvailable(pageFunction)?.toString() ?? PuppeteerURL.INTERNAL_URL);\n    if (isString(pageFunction)) {\n      const contextId = this.#id;\n      const expression = pageFunction;\n      const expressionWithSourceUrl = SOURCE_URL_REGEX.test(expression) ? expression : `${expression}\\n${sourceUrlComment}\\n`;\n      const {\n        exceptionDetails,\n        result: remoteObject\n      } = await this.#client.send('Runtime.evaluate', {\n        expression: expressionWithSourceUrl,\n        contextId,\n        returnByValue,\n        awaitPromise: true,\n        userGesture: true\n      }).catch(rewriteError);\n      if (exceptionDetails) {\n        throw createEvaluationError(exceptionDetails);\n      }\n      return returnByValue ? valueFromRemoteObject(remoteObject) : this.#world.createCdpHandle(remoteObject);\n    }\n    const functionDeclaration = stringifyFunction(pageFunction);\n    const functionDeclarationWithSourceUrl = SOURCE_URL_REGEX.test(functionDeclaration) ? functionDeclaration : `${functionDeclaration}\\n${sourceUrlComment}\\n`;\n    let callFunctionOnPromise;\n    try {\n      callFunctionOnPromise = this.#client.send('Runtime.callFunctionOn', {\n        functionDeclaration: functionDeclarationWithSourceUrl,\n        executionContextId: this.#id,\n        // LazyArgs are used only internally and should not affect the order\n        // evaluate calls for the public APIs.\n        arguments: args.some(arg => {\n          return arg instanceof LazyArg;\n        }) ? await Promise.all(args.map(arg => {\n          return convertArgumentAsync(this, arg);\n        })) : args.map(arg => {\n          return convertArgument(this, arg);\n        }),\n        returnByValue,\n        awaitPromise: true,\n        userGesture: true\n      });\n    } catch (error) {\n      if (error instanceof TypeError && error.message.startsWith('Converting circular structure to JSON')) {\n        error.message += ' Recursive objects are not allowed.';\n      }\n      throw error;\n    }\n    const {\n      exceptionDetails,\n      result: remoteObject\n    } = await callFunctionOnPromise.catch(rewriteError);\n    if (exceptionDetails) {\n      throw createEvaluationError(exceptionDetails);\n    }\n    return returnByValue ? valueFromRemoteObject(remoteObject) : this.#world.createCdpHandle(remoteObject);\n    async function convertArgumentAsync(context, arg) {\n      if (arg instanceof LazyArg) {\n        arg = await arg.get(context);\n      }\n      return convertArgument(context, arg);\n    }\n    function convertArgument(context, arg) {\n      if (typeof arg === 'bigint') {\n        // eslint-disable-line valid-typeof\n        return {\n          unserializableValue: `${arg.toString()}n`\n        };\n      }\n      if (Object.is(arg, -0)) {\n        return {\n          unserializableValue: '-0'\n        };\n      }\n      if (Object.is(arg, Infinity)) {\n        return {\n          unserializableValue: 'Infinity'\n        };\n      }\n      if (Object.is(arg, -Infinity)) {\n        return {\n          unserializableValue: '-Infinity'\n        };\n      }\n      if (Object.is(arg, NaN)) {\n        return {\n          unserializableValue: 'NaN'\n        };\n      }\n      const objectHandle = arg && (arg instanceof CdpJSHandle || arg instanceof CdpElementHandle) ? arg : null;\n      if (objectHandle) {\n        if (objectHandle.realm !== context.#world) {\n          throw new Error('JSHandles can be evaluated only in the context they were created!');\n        }\n        if (objectHandle.disposed) {\n          throw new Error('JSHandle is disposed!');\n        }\n        if (objectHandle.remoteObject().unserializableValue) {\n          return {\n            unserializableValue: objectHandle.remoteObject().unserializableValue\n          };\n        }\n        if (!objectHandle.remoteObject().objectId) {\n          return {\n            value: objectHandle.remoteObject().value\n          };\n        }\n        return {\n          objectId: objectHandle.remoteObject().objectId\n        };\n      }\n      return {\n        value: arg\n      };\n    }\n  }\n  [disposeSymbol]() {\n    this.#disposables.dispose();\n    this.emit('disposed', undefined);\n  }\n}\nconst rewriteError = error => {\n  if (error.message.includes('Object reference chain is too long')) {\n    return {\n      result: {\n        type: 'undefined'\n      }\n    };\n  }\n  if (error.message.includes(\"Object couldn't be returned by value\")) {\n    return {\n      result: {\n        type: 'undefined'\n      }\n    };\n  }\n  if (error.message.endsWith('Cannot find context with specified id') || error.message.endsWith('Inspected target navigated or closed')) {\n    throw new Error('Execution context was destroyed, most likely because of a navigation.');\n  }\n  throw error;\n};","map":{"version":3,"names":["CDPSessionEvent","EventEmitter","LazyArg","scriptInjector","PuppeteerURL","SOURCE_URL_REGEX","debugError","getSourcePuppeteerURLIfAvailable","getSourceUrlComment","isString","AsyncIterableUtil","DisposableStack","disposeSymbol","stringifyFunction","Mutex","ARIAQueryHandler","Binding","CdpElementHandle","CdpJSHandle","addPageBinding","CDP_BINDING_PREFIX","createEvaluationError","valueFromRemoteObject","ariaQuerySelectorBinding","queryOne","ariaQuerySelectorAllBinding","element","selector","results","queryAll","realm","evaluateHandle","elements","collect","ExecutionContext","client","world","id","name","disposables","constructor","contextPayload","clientEmitter","use","on","onBindingCalled","bind","event","executionContextId","onConsoleAPI","Disconnected","bindings","Map","mutex","addBinding","#addBinding","binding","has","_","__addDisposableResource","env_1","acquire","send","executionContextName","evaluate","set","error","Error","message","includes","#onBindingCalled","payload","JSON","parse","type","seq","args","isTrivial","emit","get","run","err","#onConsoleAPI","bindingsInstalled","puppeteerUtil","promise","Promise","resolve","all","addBindingWithoutThrowing","inject","script","then","handle","dispose","#addBindingWithoutThrowing","pageFunction","#evaluate","returnByValue","sourceUrlComment","toString","INTERNAL_URL","contextId","expression","expressionWithSourceUrl","test","exceptionDetails","result","remoteObject","awaitPromise","userGesture","catch","rewriteError","createCdpHandle","functionDeclaration","functionDeclarationWithSourceUrl","callFunctionOnPromise","arguments","some","arg","map","convertArgumentAsync","convertArgument","TypeError","startsWith","context","unserializableValue","Object","is","Infinity","NaN","objectHandle","disposed","objectId","value","undefined","endsWith"],"sources":["C:\\Users\\raffy\\Desktop\\test\\node_modules\\puppeteer-core\\src\\cdp\\ExecutionContext.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2017 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport type {Protocol} from 'devtools-protocol';\n\nimport {CDPSessionEvent, type CDPSession} from '../api/CDPSession.js';\nimport type {ElementHandle} from '../api/ElementHandle.js';\nimport type {JSHandle} from '../api/JSHandle.js';\nimport {EventEmitter} from '../common/EventEmitter.js';\nimport {LazyArg} from '../common/LazyArg.js';\nimport {scriptInjector} from '../common/ScriptInjector.js';\nimport type {BindingPayload, EvaluateFunc, HandleFor} from '../common/types.js';\nimport {\n  PuppeteerURL,\n  SOURCE_URL_REGEX,\n  debugError,\n  getSourcePuppeteerURLIfAvailable,\n  getSourceUrlComment,\n  isString,\n} from '../common/util.js';\nimport type PuppeteerUtil from '../injected/injected.js';\nimport {AsyncIterableUtil} from '../util/AsyncIterableUtil.js';\nimport {DisposableStack, disposeSymbol} from '../util/disposable.js';\nimport {stringifyFunction} from '../util/Function.js';\nimport {Mutex} from '../util/Mutex.js';\n\nimport {ARIAQueryHandler} from './AriaQueryHandler.js';\nimport {Binding} from './Binding.js';\nimport {CdpElementHandle} from './ElementHandle.js';\nimport type {IsolatedWorld} from './IsolatedWorld.js';\nimport {CdpJSHandle} from './JSHandle.js';\nimport {\n  addPageBinding,\n  CDP_BINDING_PREFIX,\n  createEvaluationError,\n  valueFromRemoteObject,\n} from './utils.js';\n\nconst ariaQuerySelectorBinding = new Binding(\n  '__ariaQuerySelector',\n  ARIAQueryHandler.queryOne as (...args: unknown[]) => unknown,\n  '' // custom init\n);\n\nconst ariaQuerySelectorAllBinding = new Binding(\n  '__ariaQuerySelectorAll',\n  (async (\n    element: ElementHandle<Node>,\n    selector: string\n  ): Promise<JSHandle<Node[]>> => {\n    const results = ARIAQueryHandler.queryAll(element, selector);\n    return await element.realm.evaluateHandle(\n      (...elements) => {\n        return elements;\n      },\n      ...(await AsyncIterableUtil.collect(results))\n    );\n  }) as (...args: unknown[]) => unknown,\n  '' // custom init\n);\n\n/**\n * @internal\n */\nexport class ExecutionContext\n  extends EventEmitter<{\n    /** Emitted when this execution context is disposed. */\n    disposed: undefined;\n    consoleapicalled: Protocol.Runtime.ConsoleAPICalledEvent;\n    /** Emitted when a binding that is not installed by the ExecutionContext is called. */\n    bindingcalled: Protocol.Runtime.BindingCalledEvent;\n  }>\n  implements Disposable\n{\n  #client: CDPSession;\n  #world: IsolatedWorld;\n  #id: number;\n  #name?: string;\n\n  readonly #disposables = new DisposableStack();\n\n  constructor(\n    client: CDPSession,\n    contextPayload: Protocol.Runtime.ExecutionContextDescription,\n    world: IsolatedWorld\n  ) {\n    super();\n    this.#client = client;\n    this.#world = world;\n    this.#id = contextPayload.id;\n    if (contextPayload.name) {\n      this.#name = contextPayload.name;\n    }\n    const clientEmitter = this.#disposables.use(new EventEmitter(this.#client));\n    clientEmitter.on('Runtime.bindingCalled', this.#onBindingCalled.bind(this));\n    clientEmitter.on('Runtime.executionContextDestroyed', async event => {\n      if (event.executionContextId === this.#id) {\n        this[disposeSymbol]();\n      }\n    });\n    clientEmitter.on('Runtime.executionContextsCleared', async () => {\n      this[disposeSymbol]();\n    });\n    clientEmitter.on('Runtime.consoleAPICalled', this.#onConsoleAPI.bind(this));\n    clientEmitter.on(CDPSessionEvent.Disconnected, () => {\n      this[disposeSymbol]();\n    });\n  }\n\n  // Contains mapping from functions that should be bound to Puppeteer functions.\n  #bindings = new Map<string, Binding>();\n\n  // If multiple waitFor are set up asynchronously, we need to wait for the\n  // first one to set up the binding in the page before running the others.\n  #mutex = new Mutex();\n  async #addBinding(binding: Binding): Promise<void> {\n    if (this.#bindings.has(binding.name)) {\n      return;\n    }\n\n    using _ = await this.#mutex.acquire();\n    try {\n      await this.#client.send(\n        'Runtime.addBinding',\n        this.#name\n          ? {\n              name: CDP_BINDING_PREFIX + binding.name,\n              executionContextName: this.#name,\n            }\n          : {\n              name: CDP_BINDING_PREFIX + binding.name,\n              executionContextId: this.#id,\n            }\n      );\n\n      await this.evaluate(\n        addPageBinding,\n        'internal',\n        binding.name,\n        CDP_BINDING_PREFIX\n      );\n\n      this.#bindings.set(binding.name, binding);\n    } catch (error) {\n      // We could have tried to evaluate in a context which was already\n      // destroyed. This happens, for example, if the page is navigated while\n      // we are trying to add the binding\n      if (error instanceof Error) {\n        // Destroyed context.\n        if (error.message.includes('Execution context was destroyed')) {\n          return;\n        }\n        // Missing context.\n        if (error.message.includes('Cannot find context with specified id')) {\n          return;\n        }\n      }\n\n      debugError(error);\n    }\n  }\n\n  async #onBindingCalled(\n    event: Protocol.Runtime.BindingCalledEvent\n  ): Promise<void> {\n    if (event.executionContextId !== this.#id) {\n      return;\n    }\n\n    let payload: BindingPayload;\n    try {\n      payload = JSON.parse(event.payload);\n    } catch {\n      // The binding was either called by something in the page or it was\n      // called before our wrapper was initialized.\n      return;\n    }\n    const {type, name, seq, args, isTrivial} = payload;\n    if (type !== 'internal') {\n      this.emit('bindingcalled', event);\n      return;\n    }\n    if (!this.#bindings.has(name)) {\n      this.emit('bindingcalled', event);\n      return;\n    }\n\n    try {\n      const binding = this.#bindings.get(name);\n      await binding?.run(this, seq, args, isTrivial);\n    } catch (err) {\n      debugError(err);\n    }\n  }\n\n  get id(): number {\n    return this.#id;\n  }\n\n  #onConsoleAPI(event: Protocol.Runtime.ConsoleAPICalledEvent): void {\n    if (event.executionContextId !== this.#id) {\n      return;\n    }\n    this.emit('consoleapicalled', event);\n  }\n\n  #bindingsInstalled = false;\n  #puppeteerUtil?: Promise<JSHandle<PuppeteerUtil>>;\n  get puppeteerUtil(): Promise<JSHandle<PuppeteerUtil>> {\n    let promise = Promise.resolve() as Promise<unknown>;\n    if (!this.#bindingsInstalled) {\n      promise = Promise.all([\n        this.#addBindingWithoutThrowing(ariaQuerySelectorBinding),\n        this.#addBindingWithoutThrowing(ariaQuerySelectorAllBinding),\n      ]);\n      this.#bindingsInstalled = true;\n    }\n    scriptInjector.inject(script => {\n      if (this.#puppeteerUtil) {\n        void this.#puppeteerUtil.then(handle => {\n          void handle.dispose();\n        });\n      }\n      this.#puppeteerUtil = promise.then(() => {\n        return this.evaluateHandle(script) as Promise<JSHandle<PuppeteerUtil>>;\n      });\n    }, !this.#puppeteerUtil);\n    return this.#puppeteerUtil as Promise<JSHandle<PuppeteerUtil>>;\n  }\n\n  async #addBindingWithoutThrowing(binding: Binding) {\n    try {\n      await this.#addBinding(binding);\n    } catch (err) {\n      // If the binding cannot be added, then either the browser doesn't support\n      // bindings (e.g. Firefox) or the context is broken. Either breakage is\n      // okay, so we ignore the error.\n      debugError(err);\n    }\n  }\n\n  /**\n   * Evaluates the given function.\n   *\n   * @example\n   *\n   * ```ts\n   * const executionContext = await page.mainFrame().executionContext();\n   * const result = await executionContext.evaluate(() => Promise.resolve(8 * 7))* ;\n   * console.log(result); // prints \"56\"\n   * ```\n   *\n   * @example\n   * A string can also be passed in instead of a function:\n   *\n   * ```ts\n   * console.log(await executionContext.evaluate('1 + 2')); // prints \"3\"\n   * ```\n   *\n   * @example\n   * Handles can also be passed as `args`. They resolve to their referenced object:\n   *\n   * ```ts\n   * const oneHandle = await executionContext.evaluateHandle(() => 1);\n   * const twoHandle = await executionContext.evaluateHandle(() => 2);\n   * const result = await executionContext.evaluate(\n   *   (a, b) => a + b,\n   *   oneHandle,\n   *   twoHandle\n   * );\n   * await oneHandle.dispose();\n   * await twoHandle.dispose();\n   * console.log(result); // prints '3'.\n   * ```\n   *\n   * @param pageFunction - The function to evaluate.\n   * @param args - Additional arguments to pass into the function.\n   * @returns The result of evaluating the function. If the result is an object,\n   * a vanilla object containing the serializable properties of the result is\n   * returned.\n   */\n  async evaluate<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<Awaited<ReturnType<Func>>> {\n    return await this.#evaluate(true, pageFunction, ...args);\n  }\n\n  /**\n   * Evaluates the given function.\n   *\n   * Unlike {@link ExecutionContext.evaluate | evaluate}, this method returns a\n   * handle to the result of the function.\n   *\n   * This method may be better suited if the object cannot be serialized (e.g.\n   * `Map`) and requires further manipulation.\n   *\n   * @example\n   *\n   * ```ts\n   * const context = await page.mainFrame().executionContext();\n   * const handle: JSHandle<typeof globalThis> = await context.evaluateHandle(\n   *   () => Promise.resolve(self)\n   * );\n   * ```\n   *\n   * @example\n   * A string can also be passed in instead of a function.\n   *\n   * ```ts\n   * const handle: JSHandle<number> = await context.evaluateHandle('1 + 2');\n   * ```\n   *\n   * @example\n   * Handles can also be passed as `args`. They resolve to their referenced object:\n   *\n   * ```ts\n   * const bodyHandle: ElementHandle<HTMLBodyElement> =\n   *   await context.evaluateHandle(() => {\n   *     return document.body;\n   *   });\n   * const stringHandle: JSHandle<string> = await context.evaluateHandle(\n   *   body => body.innerHTML,\n   *   body\n   * );\n   * console.log(await stringHandle.jsonValue()); // prints body's innerHTML\n   * // Always dispose your garbage! :)\n   * await bodyHandle.dispose();\n   * await stringHandle.dispose();\n   * ```\n   *\n   * @param pageFunction - The function to evaluate.\n   * @param args - Additional arguments to pass into the function.\n   * @returns A {@link JSHandle | handle} to the result of evaluating the\n   * function. If the result is a `Node`, then this will return an\n   * {@link ElementHandle | element handle}.\n   */\n  async evaluateHandle<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<HandleFor<Awaited<ReturnType<Func>>>> {\n    return await this.#evaluate(false, pageFunction, ...args);\n  }\n\n  async #evaluate<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(\n    returnByValue: true,\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<Awaited<ReturnType<Func>>>;\n  async #evaluate<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(\n    returnByValue: false,\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<HandleFor<Awaited<ReturnType<Func>>>>;\n  async #evaluate<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(\n    returnByValue: boolean,\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<HandleFor<Awaited<ReturnType<Func>>> | Awaited<ReturnType<Func>>> {\n    const sourceUrlComment = getSourceUrlComment(\n      getSourcePuppeteerURLIfAvailable(pageFunction)?.toString() ??\n        PuppeteerURL.INTERNAL_URL\n    );\n\n    if (isString(pageFunction)) {\n      const contextId = this.#id;\n      const expression = pageFunction;\n      const expressionWithSourceUrl = SOURCE_URL_REGEX.test(expression)\n        ? expression\n        : `${expression}\\n${sourceUrlComment}\\n`;\n\n      const {exceptionDetails, result: remoteObject} = await this.#client\n        .send('Runtime.evaluate', {\n          expression: expressionWithSourceUrl,\n          contextId,\n          returnByValue,\n          awaitPromise: true,\n          userGesture: true,\n        })\n        .catch(rewriteError);\n\n      if (exceptionDetails) {\n        throw createEvaluationError(exceptionDetails);\n      }\n\n      return returnByValue\n        ? valueFromRemoteObject(remoteObject)\n        : this.#world.createCdpHandle(remoteObject);\n    }\n\n    const functionDeclaration = stringifyFunction(pageFunction);\n    const functionDeclarationWithSourceUrl = SOURCE_URL_REGEX.test(\n      functionDeclaration\n    )\n      ? functionDeclaration\n      : `${functionDeclaration}\\n${sourceUrlComment}\\n`;\n    let callFunctionOnPromise;\n    try {\n      callFunctionOnPromise = this.#client.send('Runtime.callFunctionOn', {\n        functionDeclaration: functionDeclarationWithSourceUrl,\n        executionContextId: this.#id,\n        // LazyArgs are used only internally and should not affect the order\n        // evaluate calls for the public APIs.\n        arguments: args.some(arg => {\n          return arg instanceof LazyArg;\n        })\n          ? await Promise.all(\n              args.map(arg => {\n                return convertArgumentAsync(this, arg);\n              })\n            )\n          : args.map(arg => {\n              return convertArgument(this, arg);\n            }),\n        returnByValue,\n        awaitPromise: true,\n        userGesture: true,\n      });\n    } catch (error) {\n      if (\n        error instanceof TypeError &&\n        error.message.startsWith('Converting circular structure to JSON')\n      ) {\n        error.message += ' Recursive objects are not allowed.';\n      }\n      throw error;\n    }\n    const {exceptionDetails, result: remoteObject} =\n      await callFunctionOnPromise.catch(rewriteError);\n    if (exceptionDetails) {\n      throw createEvaluationError(exceptionDetails);\n    }\n    return returnByValue\n      ? valueFromRemoteObject(remoteObject)\n      : this.#world.createCdpHandle(remoteObject);\n\n    async function convertArgumentAsync(\n      context: ExecutionContext,\n      arg: unknown\n    ) {\n      if (arg instanceof LazyArg) {\n        arg = await arg.get(context);\n      }\n      return convertArgument(context, arg);\n    }\n\n    function convertArgument(\n      context: ExecutionContext,\n      arg: unknown\n    ): Protocol.Runtime.CallArgument {\n      if (typeof arg === 'bigint') {\n        // eslint-disable-line valid-typeof\n        return {unserializableValue: `${arg.toString()}n`};\n      }\n      if (Object.is(arg, -0)) {\n        return {unserializableValue: '-0'};\n      }\n      if (Object.is(arg, Infinity)) {\n        return {unserializableValue: 'Infinity'};\n      }\n      if (Object.is(arg, -Infinity)) {\n        return {unserializableValue: '-Infinity'};\n      }\n      if (Object.is(arg, NaN)) {\n        return {unserializableValue: 'NaN'};\n      }\n      const objectHandle =\n        arg && (arg instanceof CdpJSHandle || arg instanceof CdpElementHandle)\n          ? arg\n          : null;\n      if (objectHandle) {\n        if (objectHandle.realm !== context.#world) {\n          throw new Error(\n            'JSHandles can be evaluated only in the context they were created!'\n          );\n        }\n        if (objectHandle.disposed) {\n          throw new Error('JSHandle is disposed!');\n        }\n        if (objectHandle.remoteObject().unserializableValue) {\n          return {\n            unserializableValue:\n              objectHandle.remoteObject().unserializableValue,\n          };\n        }\n        if (!objectHandle.remoteObject().objectId) {\n          return {value: objectHandle.remoteObject().value};\n        }\n        return {objectId: objectHandle.remoteObject().objectId};\n      }\n      return {value: arg};\n    }\n  }\n\n  [disposeSymbol](): void {\n    this.#disposables.dispose();\n    this.emit('disposed', undefined);\n  }\n}\n\nconst rewriteError = (error: Error): Protocol.Runtime.EvaluateResponse => {\n  if (error.message.includes('Object reference chain is too long')) {\n    return {result: {type: 'undefined'}};\n  }\n  if (error.message.includes(\"Object couldn't be returned by value\")) {\n    return {result: {type: 'undefined'}};\n  }\n\n  if (\n    error.message.endsWith('Cannot find context with specified id') ||\n    error.message.endsWith('Inspected target navigated or closed')\n  ) {\n    throw new Error(\n      'Execution context was destroyed, most likely because of a navigation.'\n    );\n  }\n  throw error;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}