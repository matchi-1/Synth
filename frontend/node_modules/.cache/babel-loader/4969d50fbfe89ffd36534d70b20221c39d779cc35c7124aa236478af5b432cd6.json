{"ast":null,"code":"/**\n * @license\n * Copyright 2023 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { TaskManager, WaitTask } from '../common/WaitTask.js';\nimport { disposeSymbol } from '../util/disposable.js';\n/**\n * @internal\n */\nexport class Realm {\n  timeoutSettings;\n  taskManager = new TaskManager();\n  constructor(timeoutSettings) {\n    this.timeoutSettings = timeoutSettings;\n  }\n  async waitForFunction(pageFunction, options = {}, ...args) {\n    const {\n      polling = 'raf',\n      timeout = this.timeoutSettings.timeout(),\n      root,\n      signal\n    } = options;\n    if (typeof polling === 'number' && polling < 0) {\n      throw new Error('Cannot poll with non-positive interval');\n    }\n    const waitTask = new WaitTask(this, {\n      polling,\n      root,\n      timeout,\n      signal\n    }, pageFunction, ...args);\n    return await waitTask.result;\n  }\n  get disposed() {\n    return this.#disposed;\n  }\n  #disposed = false;\n  /** @internal */\n  dispose() {\n    this.#disposed = true;\n    this.taskManager.terminateAll(new Error('waitForFunction failed: frame got detached.'));\n  }\n  /** @internal */\n  [disposeSymbol]() {\n    this.dispose();\n  }\n}","map":{"version":3,"names":["TaskManager","WaitTask","disposeSymbol","Realm","timeoutSettings","taskManager","constructor","waitForFunction","pageFunction","options","args","polling","timeout","root","signal","Error","waitTask","result","disposed","dispose","terminateAll"],"sources":["C:\\Users\\raffy\\Desktop\\test\\node_modules\\puppeteer-core\\src\\api\\Realm.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2023 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport type {TimeoutSettings} from '../common/TimeoutSettings.js';\nimport type {\n  EvaluateFunc,\n  HandleFor,\n  InnerLazyParams,\n} from '../common/types.js';\nimport {TaskManager, WaitTask} from '../common/WaitTask.js';\nimport {disposeSymbol} from '../util/disposable.js';\n\nimport type {ElementHandle} from './ElementHandle.js';\nimport type {Environment} from './Environment.js';\nimport type {JSHandle} from './JSHandle.js';\n\n/**\n * @internal\n */\nexport abstract class Realm implements Disposable {\n  protected readonly timeoutSettings: TimeoutSettings;\n  readonly taskManager = new TaskManager();\n\n  constructor(timeoutSettings: TimeoutSettings) {\n    this.timeoutSettings = timeoutSettings;\n  }\n\n  abstract get environment(): Environment;\n\n  abstract adoptHandle<T extends JSHandle<Node>>(handle: T): Promise<T>;\n  abstract transferHandle<T extends JSHandle<Node>>(handle: T): Promise<T>;\n  abstract evaluateHandle<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<HandleFor<Awaited<ReturnType<Func>>>>;\n  abstract evaluate<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<Awaited<ReturnType<Func>>>;\n\n  async waitForFunction<\n    Params extends unknown[],\n    Func extends EvaluateFunc<InnerLazyParams<Params>> = EvaluateFunc<\n      InnerLazyParams<Params>\n    >,\n  >(\n    pageFunction: Func | string,\n    options: {\n      polling?: 'raf' | 'mutation' | number;\n      timeout?: number;\n      root?: ElementHandle<Node>;\n      signal?: AbortSignal;\n    } = {},\n    ...args: Params\n  ): Promise<HandleFor<Awaited<ReturnType<Func>>>> {\n    const {\n      polling = 'raf',\n      timeout = this.timeoutSettings.timeout(),\n      root,\n      signal,\n    } = options;\n    if (typeof polling === 'number' && polling < 0) {\n      throw new Error('Cannot poll with non-positive interval');\n    }\n    const waitTask = new WaitTask(\n      this,\n      {\n        polling,\n        root,\n        timeout,\n        signal,\n      },\n      pageFunction as unknown as\n        | ((...args: unknown[]) => Promise<Awaited<ReturnType<Func>>>)\n        | string,\n      ...args\n    );\n    return await waitTask.result;\n  }\n\n  abstract adoptBackendNode(backendNodeId?: number): Promise<JSHandle<Node>>;\n\n  get disposed(): boolean {\n    return this.#disposed;\n  }\n\n  #disposed = false;\n  /** @internal */\n  dispose(): void {\n    this.#disposed = true;\n    this.taskManager.terminateAll(\n      new Error('waitForFunction failed: frame got detached.')\n    );\n  }\n  /** @internal */\n  [disposeSymbol](): void {\n    this.dispose();\n  }\n}\n"],"mappings":"AAAA;;;;;AAYA,SAAQA,WAAW,EAAEC,QAAQ,QAAO,uBAAuB;AAC3D,SAAQC,aAAa,QAAO,uBAAuB;AAMnD;;;AAGA,OAAM,MAAgBC,KAAK;EACNC,eAAe;EACzBC,WAAW,GAAG,IAAIL,WAAW,EAAE;EAExCM,YAAYF,eAAgC;IAC1C,IAAI,CAACA,eAAe,GAAGA,eAAe;EACxC;EAqBA,MAAMG,eAAeA,CAMnBC,YAA2B,EAC3BC,OAAA,GAKI,EAAE,EACN,GAAGC,IAAY;IAEf,MAAM;MACJC,OAAO,GAAG,KAAK;MACfC,OAAO,GAAG,IAAI,CAACR,eAAe,CAACQ,OAAO,EAAE;MACxCC,IAAI;MACJC;IAAM,CACP,GAAGL,OAAO;IACX,IAAI,OAAOE,OAAO,KAAK,QAAQ,IAAIA,OAAO,GAAG,CAAC,EAAE;MAC9C,MAAM,IAAII,KAAK,CAAC,wCAAwC,CAAC;IAC3D;IACA,MAAMC,QAAQ,GAAG,IAAIf,QAAQ,CAC3B,IAAI,EACJ;MACEU,OAAO;MACPE,IAAI;MACJD,OAAO;MACPE;KACD,EACDN,YAEU,EACV,GAAGE,IAAI,CACR;IACD,OAAO,MAAMM,QAAQ,CAACC,MAAM;EAC9B;EAIA,IAAIC,QAAQA,CAAA;IACV,OAAO,IAAI,CAAC,CAAAA,QAAS;EACvB;EAEA,CAAAA,QAAS,GAAG,KAAK;EACjB;EACAC,OAAOA,CAAA;IACL,IAAI,CAAC,CAAAD,QAAS,GAAG,IAAI;IACrB,IAAI,CAACb,WAAW,CAACe,YAAY,CAC3B,IAAIL,KAAK,CAAC,6CAA6C,CAAC,CACzD;EACH;EACA;EACA,CAACb,aAAa,IAAC;IACb,IAAI,CAACiB,OAAO,EAAE;EAChB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}