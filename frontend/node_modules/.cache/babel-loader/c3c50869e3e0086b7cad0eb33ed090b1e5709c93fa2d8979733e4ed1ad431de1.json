{"ast":null,"code":"/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactMount\n */\n\n'use strict';\n\nvar DOMProperty = require(\"./DOMProperty\");\nvar ReactBrowserEventEmitter = require(\"./ReactBrowserEventEmitter\");\nvar ReactCurrentOwner = require(\"./ReactCurrentOwner\");\nvar ReactElement = require(\"./ReactElement\");\nvar ReactElementValidator = require(\"./ReactElementValidator\");\nvar ReactEmptyComponent = require(\"./ReactEmptyComponent\");\nvar ReactInstanceHandles = require(\"./ReactInstanceHandles\");\nvar ReactInstanceMap = require(\"./ReactInstanceMap\");\nvar ReactMarkupChecksum = require(\"./ReactMarkupChecksum\");\nvar ReactPerf = require(\"./ReactPerf\");\nvar ReactReconciler = require(\"./ReactReconciler\");\nvar ReactUpdateQueue = require(\"./ReactUpdateQueue\");\nvar ReactUpdates = require(\"./ReactUpdates\");\nvar emptyObject = require(\"./emptyObject\");\nvar containsNode = require(\"./containsNode\");\nvar getReactRootElementInContainer = require(\"./getReactRootElementInContainer\");\nvar instantiateReactComponent = require(\"./instantiateReactComponent\");\nvar invariant = require(\"./invariant\");\nvar setInnerHTML = require(\"./setInnerHTML\");\nvar shouldUpdateReactComponent = require(\"./shouldUpdateReactComponent\");\nvar warning = require(\"./warning\");\nvar SEPARATOR = ReactInstanceHandles.SEPARATOR;\nvar ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;\nvar nodeCache = {};\nvar ELEMENT_NODE_TYPE = 1;\nvar DOC_NODE_TYPE = 9;\n\n/** Mapping from reactRootID to React component instance. */\nvar instancesByReactRootID = {};\n\n/** Mapping from reactRootID to `container` nodes. */\nvar containersByReactRootID = {};\nif (\"production\" !== process.env.NODE_ENV) {\n  /** __DEV__-only mapping from reactRootID to root elements. */\n  var rootElementsByReactRootID = {};\n}\n\n// Used to store breadth-first search state in findComponentRoot.\nvar findComponentRootReusableArray = [];\n\n/**\n * Finds the index of the first character\n * that's not common between the two given strings.\n *\n * @return {number} the index of the character where the strings diverge\n */\nfunction firstDifferenceIndex(string1, string2) {\n  var minLen = Math.min(string1.length, string2.length);\n  for (var i = 0; i < minLen; i++) {\n    if (string1.charAt(i) !== string2.charAt(i)) {\n      return i;\n    }\n  }\n  return string1.length === string2.length ? -1 : minLen;\n}\n\n/**\n * @param {DOMElement} container DOM element that may contain a React component.\n * @return {?string} A \"reactRoot\" ID, if a React component is rendered.\n */\nfunction getReactRootID(container) {\n  var rootElement = getReactRootElementInContainer(container);\n  return rootElement && ReactMount.getID(rootElement);\n}\n\n/**\n * Accessing node[ATTR_NAME] or calling getAttribute(ATTR_NAME) on a form\n * element can return its control whose name or ID equals ATTR_NAME. All\n * DOM nodes support `getAttributeNode` but this can also get called on\n * other objects so just return '' if we're given something other than a\n * DOM node (such as window).\n *\n * @param {?DOMElement|DOMWindow|DOMDocument|DOMTextNode} node DOM node.\n * @return {string} ID of the supplied `domNode`.\n */\nfunction getID(node) {\n  var id = internalGetID(node);\n  if (id) {\n    if (nodeCache.hasOwnProperty(id)) {\n      var cached = nodeCache[id];\n      if (cached !== node) {\n        \"production\" !== process.env.NODE_ENV ? invariant(!isValid(cached, id), 'ReactMount: Two valid but unequal nodes with the same `%s`: %s', ATTR_NAME, id) : invariant(!isValid(cached, id));\n        nodeCache[id] = node;\n      }\n    } else {\n      nodeCache[id] = node;\n    }\n  }\n  return id;\n}\nfunction internalGetID(node) {\n  // If node is something like a window, document, or text node, none of\n  // which support attributes or a .getAttribute method, gracefully return\n  // the empty string, as if the attribute were missing.\n  return node && node.getAttribute && node.getAttribute(ATTR_NAME) || '';\n}\n\n/**\n * Sets the React-specific ID of the given node.\n *\n * @param {DOMElement} node The DOM node whose ID will be set.\n * @param {string} id The value of the ID attribute.\n */\nfunction setID(node, id) {\n  var oldID = internalGetID(node);\n  if (oldID !== id) {\n    delete nodeCache[oldID];\n  }\n  node.setAttribute(ATTR_NAME, id);\n  nodeCache[id] = node;\n}\n\n/**\n * Finds the node with the supplied React-generated DOM ID.\n *\n * @param {string} id A React-generated DOM ID.\n * @return {DOMElement} DOM node with the suppled `id`.\n * @internal\n */\nfunction getNode(id) {\n  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {\n    nodeCache[id] = ReactMount.findReactNodeByID(id);\n  }\n  return nodeCache[id];\n}\n\n/**\n * Finds the node with the supplied public React instance.\n *\n * @param {*} instance A public React instance.\n * @return {?DOMElement} DOM node with the suppled `id`.\n * @internal\n */\nfunction getNodeFromInstance(instance) {\n  var id = ReactInstanceMap.get(instance)._rootNodeID;\n  if (ReactEmptyComponent.isNullComponentID(id)) {\n    return null;\n  }\n  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {\n    nodeCache[id] = ReactMount.findReactNodeByID(id);\n  }\n  return nodeCache[id];\n}\n\n/**\n * A node is \"valid\" if it is contained by a currently mounted container.\n *\n * This means that the node does not have to be contained by a document in\n * order to be considered valid.\n *\n * @param {?DOMElement} node The candidate DOM node.\n * @param {string} id The expected ID of the node.\n * @return {boolean} Whether the node is contained by a mounted container.\n */\nfunction isValid(node, id) {\n  if (node) {\n    \"production\" !== process.env.NODE_ENV ? invariant(internalGetID(node) === id, 'ReactMount: Unexpected modification of `%s`', ATTR_NAME) : invariant(internalGetID(node) === id);\n    var container = ReactMount.findReactContainerForID(id);\n    if (container && containsNode(container, node)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Causes the cache to forget about one React-specific ID.\n *\n * @param {string} id The ID to forget.\n */\nfunction purgeID(id) {\n  delete nodeCache[id];\n}\nvar deepestNodeSoFar = null;\nfunction findDeepestCachedAncestorImpl(ancestorID) {\n  var ancestor = nodeCache[ancestorID];\n  if (ancestor && isValid(ancestor, ancestorID)) {\n    deepestNodeSoFar = ancestor;\n  } else {\n    // This node isn't populated in the cache, so presumably none of its\n    // descendants are. Break out of the loop.\n    return false;\n  }\n}\n\n/**\n * Return the deepest cached node whose ID is a prefix of `targetID`.\n */\nfunction findDeepestCachedAncestor(targetID) {\n  deepestNodeSoFar = null;\n  ReactInstanceHandles.traverseAncestors(targetID, findDeepestCachedAncestorImpl);\n  var foundNode = deepestNodeSoFar;\n  deepestNodeSoFar = null;\n  return foundNode;\n}\n\n/**\n * Mounts this component and inserts it into the DOM.\n *\n * @param {ReactComponent} componentInstance The instance to mount.\n * @param {string} rootID DOM ID of the root node.\n * @param {DOMElement} container DOM element to mount into.\n * @param {ReactReconcileTransaction} transaction\n * @param {boolean} shouldReuseMarkup If true, do not insert markup\n */\nfunction mountComponentIntoNode(componentInstance, rootID, container, transaction, shouldReuseMarkup) {\n  var markup = ReactReconciler.mountComponent(componentInstance, rootID, transaction, emptyObject);\n  componentInstance._isTopLevel = true;\n  ReactMount._mountImageIntoNode(markup, container, shouldReuseMarkup);\n}\n\n/**\n * Batched mount.\n *\n * @param {ReactComponent} componentInstance The instance to mount.\n * @param {string} rootID DOM ID of the root node.\n * @param {DOMElement} container DOM element to mount into.\n * @param {boolean} shouldReuseMarkup If true, do not insert markup\n */\nfunction batchedMountComponentIntoNode(componentInstance, rootID, container, shouldReuseMarkup) {\n  var transaction = ReactUpdates.ReactReconcileTransaction.getPooled();\n  transaction.perform(mountComponentIntoNode, null, componentInstance, rootID, container, transaction, shouldReuseMarkup);\n  ReactUpdates.ReactReconcileTransaction.release(transaction);\n}\n\n/**\n * Mounting is the process of initializing a React component by creating its\n * representative DOM elements and inserting them into a supplied `container`.\n * Any prior content inside `container` is destroyed in the process.\n *\n *   ReactMount.render(\n *     component,\n *     document.getElementById('container')\n *   );\n *\n *   <div id=\"container\">                   <-- Supplied `container`.\n *     <div data-reactid=\".3\">              <-- Rendered reactRoot of React\n *       // ...                                 component.\n *     </div>\n *   </div>\n *\n * Inside of `container`, the first element rendered is the \"reactRoot\".\n */\nvar ReactMount = {\n  /** Exposed for debugging purposes **/\n  _instancesByReactRootID: instancesByReactRootID,\n  /**\n   * This is a hook provided to support rendering React components while\n   * ensuring that the apparent scroll position of its `container` does not\n   * change.\n   *\n   * @param {DOMElement} container The `container` being rendered into.\n   * @param {function} renderCallback This must be called once to do the render.\n   */\n  scrollMonitor: function (container, renderCallback) {\n    renderCallback();\n  },\n  /**\n   * Take a component that's already mounted into the DOM and replace its props\n   * @param {ReactComponent} prevComponent component instance already in the DOM\n   * @param {ReactElement} nextElement component instance to render\n   * @param {DOMElement} container container to render into\n   * @param {?function} callback function triggered on completion\n   */\n  _updateRootComponent: function (prevComponent, nextElement, container, callback) {\n    if (\"production\" !== process.env.NODE_ENV) {\n      ReactElementValidator.checkAndWarnForMutatedProps(nextElement);\n    }\n    ReactMount.scrollMonitor(container, function () {\n      ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement);\n      if (callback) {\n        ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);\n      }\n    });\n    if (\"production\" !== process.env.NODE_ENV) {\n      // Record the root element in case it later gets transplanted.\n      rootElementsByReactRootID[getReactRootID(container)] = getReactRootElementInContainer(container);\n    }\n    return prevComponent;\n  },\n  /**\n   * Register a component into the instance map and starts scroll value\n   * monitoring\n   * @param {ReactComponent} nextComponent component instance to render\n   * @param {DOMElement} container container to render into\n   * @return {string} reactRoot ID prefix\n   */\n  _registerComponent: function (nextComponent, container) {\n    \"production\" !== process.env.NODE_ENV ? invariant(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE), '_registerComponent(...): Target container is not a DOM element.') : invariant(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE));\n    ReactBrowserEventEmitter.ensureScrollValueMonitoring();\n    var reactRootID = ReactMount.registerContainer(container);\n    instancesByReactRootID[reactRootID] = nextComponent;\n    return reactRootID;\n  },\n  /**\n   * Render a new component into the DOM.\n   * @param {ReactElement} nextElement element to render\n   * @param {DOMElement} container container to render into\n   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion\n   * @return {ReactComponent} nextComponent\n   */\n  _renderNewRootComponent: function (nextElement, container, shouldReuseMarkup) {\n    // Various parts of our code (such as ReactCompositeComponent's\n    // _renderValidatedComponent) assume that calls to render aren't nested;\n    // verify that that's the case.\n    \"production\" !== process.env.NODE_ENV ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate.') : null;\n    var componentInstance = instantiateReactComponent(nextElement, null);\n    var reactRootID = ReactMount._registerComponent(componentInstance, container);\n\n    // The initial render is synchronous but any updates that happen during\n    // rendering, in componentWillMount or componentDidMount, will be batched\n    // according to the current batching strategy.\n\n    ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, reactRootID, container, shouldReuseMarkup);\n    if (\"production\" !== process.env.NODE_ENV) {\n      // Record the root element in case it later gets transplanted.\n      rootElementsByReactRootID[reactRootID] = getReactRootElementInContainer(container);\n    }\n    return componentInstance;\n  },\n  /**\n   * Renders a React component into the DOM in the supplied `container`.\n   *\n   * If the React component was previously rendered into `container`, this will\n   * perform an update on it and only mutate the DOM as necessary to reflect the\n   * latest React component.\n   *\n   * @param {ReactElement} nextElement Component element to render.\n   * @param {DOMElement} container DOM element to render into.\n   * @param {?function} callback function triggered on completion\n   * @return {ReactComponent} Component instance rendered in `container`.\n   */\n  render: function (nextElement, container, callback) {\n    \"production\" !== process.env.NODE_ENV ? invariant(ReactElement.isValidElement(nextElement), 'React.render(): Invalid component element.%s', typeof nextElement === 'string' ? ' Instead of passing an element string, make sure to instantiate ' + 'it by passing it to React.createElement.' : typeof nextElement === 'function' ? ' Instead of passing a component class, make sure to instantiate ' + 'it by passing it to React.createElement.' :\n    // Check if it quacks like an element\n    nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : invariant(ReactElement.isValidElement(nextElement));\n    var prevComponent = instancesByReactRootID[getReactRootID(container)];\n    if (prevComponent) {\n      var prevElement = prevComponent._currentElement;\n      if (shouldUpdateReactComponent(prevElement, nextElement)) {\n        return ReactMount._updateRootComponent(prevComponent, nextElement, container, callback).getPublicInstance();\n      } else {\n        ReactMount.unmountComponentAtNode(container);\n      }\n    }\n    var reactRootElement = getReactRootElementInContainer(container);\n    var containerHasReactMarkup = reactRootElement && ReactMount.isRenderedByReact(reactRootElement);\n    if (\"production\" !== process.env.NODE_ENV) {\n      if (!containerHasReactMarkup || reactRootElement.nextSibling) {\n        var rootElementSibling = reactRootElement;\n        while (rootElementSibling) {\n          if (ReactMount.isRenderedByReact(rootElementSibling)) {\n            \"production\" !== process.env.NODE_ENV ? warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.') : null;\n            break;\n          }\n          rootElementSibling = rootElementSibling.nextSibling;\n        }\n      }\n    }\n    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent;\n    var component = ReactMount._renderNewRootComponent(nextElement, container, shouldReuseMarkup).getPublicInstance();\n    if (callback) {\n      callback.call(component);\n    }\n    return component;\n  },\n  /**\n   * Constructs a component instance of `constructor` with `initialProps` and\n   * renders it into the supplied `container`.\n   *\n   * @param {function} constructor React component constructor.\n   * @param {?object} props Initial props of the component instance.\n   * @param {DOMElement} container DOM element to render into.\n   * @return {ReactComponent} Component instance rendered in `container`.\n   */\n  constructAndRenderComponent: function (constructor, props, container) {\n    var element = ReactElement.createElement(constructor, props);\n    return ReactMount.render(element, container);\n  },\n  /**\n   * Constructs a component instance of `constructor` with `initialProps` and\n   * renders it into a container node identified by supplied `id`.\n   *\n   * @param {function} componentConstructor React component constructor\n   * @param {?object} props Initial props of the component instance.\n   * @param {string} id ID of the DOM element to render into.\n   * @return {ReactComponent} Component instance rendered in the container node.\n   */\n  constructAndRenderComponentByID: function (constructor, props, id) {\n    var domNode = document.getElementById(id);\n    \"production\" !== process.env.NODE_ENV ? invariant(domNode, 'Tried to get element with id of \"%s\" but it is not present on the page.', id) : invariant(domNode);\n    return ReactMount.constructAndRenderComponent(constructor, props, domNode);\n  },\n  /**\n   * Registers a container node into which React components will be rendered.\n   * This also creates the \"reactRoot\" ID that will be assigned to the element\n   * rendered within.\n   *\n   * @param {DOMElement} container DOM element to register as a container.\n   * @return {string} The \"reactRoot\" ID of elements rendered within.\n   */\n  registerContainer: function (container) {\n    var reactRootID = getReactRootID(container);\n    if (reactRootID) {\n      // If one exists, make sure it is a valid \"reactRoot\" ID.\n      reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID);\n    }\n    if (!reactRootID) {\n      // No valid \"reactRoot\" ID found, create one.\n      reactRootID = ReactInstanceHandles.createReactRootID();\n    }\n    containersByReactRootID[reactRootID] = container;\n    return reactRootID;\n  },\n  /**\n   * Unmounts and destroys the React component rendered in the `container`.\n   *\n   * @param {DOMElement} container DOM element containing a React component.\n   * @return {boolean} True if a component was found in and unmounted from\n   *                   `container`\n   */\n  unmountComponentAtNode: function (container) {\n    // Various parts of our code (such as ReactCompositeComponent's\n    // _renderValidatedComponent) assume that calls to render aren't nested;\n    // verify that that's the case. (Strictly speaking, unmounting won't cause a\n    // render but we still don't expect to be in a render call here.)\n    \"production\" !== process.env.NODE_ENV ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function of ' + 'props and state; triggering nested component updates from render is ' + 'not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate.') : null;\n    \"production\" !== process.env.NODE_ENV ? invariant(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE), 'unmountComponentAtNode(...): Target container is not a DOM element.') : invariant(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE));\n    var reactRootID = getReactRootID(container);\n    var component = instancesByReactRootID[reactRootID];\n    if (!component) {\n      return false;\n    }\n    ReactMount.unmountComponentFromNode(component, container);\n    delete instancesByReactRootID[reactRootID];\n    delete containersByReactRootID[reactRootID];\n    if (\"production\" !== process.env.NODE_ENV) {\n      delete rootElementsByReactRootID[reactRootID];\n    }\n    return true;\n  },\n  /**\n   * Unmounts a component and removes it from the DOM.\n   *\n   * @param {ReactComponent} instance React component instance.\n   * @param {DOMElement} container DOM element to unmount from.\n   * @final\n   * @internal\n   * @see {ReactMount.unmountComponentAtNode}\n   */\n  unmountComponentFromNode: function (instance, container) {\n    ReactReconciler.unmountComponent(instance);\n    if (container.nodeType === DOC_NODE_TYPE) {\n      container = container.documentElement;\n    }\n\n    // http://jsperf.com/emptying-a-node\n    while (container.lastChild) {\n      container.removeChild(container.lastChild);\n    }\n  },\n  /**\n   * Finds the container DOM element that contains React component to which the\n   * supplied DOM `id` belongs.\n   *\n   * @param {string} id The ID of an element rendered by a React component.\n   * @return {?DOMElement} DOM element that contains the `id`.\n   */\n  findReactContainerForID: function (id) {\n    var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(id);\n    var container = containersByReactRootID[reactRootID];\n    if (\"production\" !== process.env.NODE_ENV) {\n      var rootElement = rootElementsByReactRootID[reactRootID];\n      if (rootElement && rootElement.parentNode !== container) {\n        \"production\" !== process.env.NODE_ENV ? invariant(\n        // Call internalGetID here because getID calls isValid which calls\n        // findReactContainerForID (this function).\n        internalGetID(rootElement) === reactRootID, 'ReactMount: Root element ID differed from reactRootID.') : invariant(\n        // Call internalGetID here because getID calls isValid which calls\n        // findReactContainerForID (this function).\n        internalGetID(rootElement) === reactRootID);\n        var containerChild = container.firstChild;\n        if (containerChild && reactRootID === internalGetID(containerChild)) {\n          // If the container has a new child with the same ID as the old\n          // root element, then rootElementsByReactRootID[reactRootID] is\n          // just stale and needs to be updated. The case that deserves a\n          // warning is when the container is empty.\n          rootElementsByReactRootID[reactRootID] = containerChild;\n        } else {\n          \"production\" !== process.env.NODE_ENV ? warning(false, 'ReactMount: Root element has been removed from its original ' + 'container. New container:', rootElement.parentNode) : null;\n        }\n      }\n    }\n    return container;\n  },\n  /**\n   * Finds an element rendered by React with the supplied ID.\n   *\n   * @param {string} id ID of a DOM node in the React component.\n   * @return {DOMElement} Root DOM node of the React component.\n   */\n  findReactNodeByID: function (id) {\n    var reactRoot = ReactMount.findReactContainerForID(id);\n    return ReactMount.findComponentRoot(reactRoot, id);\n  },\n  /**\n   * True if the supplied `node` is rendered by React.\n   *\n   * @param {*} node DOM Element to check.\n   * @return {boolean} True if the DOM Element appears to be rendered by React.\n   * @internal\n   */\n  isRenderedByReact: function (node) {\n    if (node.nodeType !== 1) {\n      // Not a DOMElement, therefore not a React component\n      return false;\n    }\n    var id = ReactMount.getID(node);\n    return id ? id.charAt(0) === SEPARATOR : false;\n  },\n  /**\n   * Traverses up the ancestors of the supplied node to find a node that is a\n   * DOM representation of a React component.\n   *\n   * @param {*} node\n   * @return {?DOMEventTarget}\n   * @internal\n   */\n  getFirstReactDOM: function (node) {\n    var current = node;\n    while (current && current.parentNode !== current) {\n      if (ReactMount.isRenderedByReact(current)) {\n        return current;\n      }\n      current = current.parentNode;\n    }\n    return null;\n  },\n  /**\n   * Finds a node with the supplied `targetID` inside of the supplied\n   * `ancestorNode`.  Exploits the ID naming scheme to perform the search\n   * quickly.\n   *\n   * @param {DOMEventTarget} ancestorNode Search from this root.\n   * @pararm {string} targetID ID of the DOM representation of the component.\n   * @return {DOMEventTarget} DOM node with the supplied `targetID`.\n   * @internal\n   */\n  findComponentRoot: function (ancestorNode, targetID) {\n    var firstChildren = findComponentRootReusableArray;\n    var childIndex = 0;\n    var deepestAncestor = findDeepestCachedAncestor(targetID) || ancestorNode;\n    firstChildren[0] = deepestAncestor.firstChild;\n    firstChildren.length = 1;\n    while (childIndex < firstChildren.length) {\n      var child = firstChildren[childIndex++];\n      var targetChild;\n      while (child) {\n        var childID = ReactMount.getID(child);\n        if (childID) {\n          // Even if we find the node we're looking for, we finish looping\n          // through its siblings to ensure they're cached so that we don't have\n          // to revisit this node again. Otherwise, we make n^2 calls to getID\n          // when visiting the many children of a single node in order.\n\n          if (targetID === childID) {\n            targetChild = child;\n          } else if (ReactInstanceHandles.isAncestorIDOf(childID, targetID)) {\n            // If we find a child whose ID is an ancestor of the given ID,\n            // then we can be sure that we only want to search the subtree\n            // rooted at this child, so we can throw out the rest of the\n            // search state.\n            firstChildren.length = childIndex = 0;\n            firstChildren.push(child.firstChild);\n          }\n        } else {\n          // If this child had no ID, then there's a chance that it was\n          // injected automatically by the browser, as when a `<table>`\n          // element sprouts an extra `<tbody>` child as a side effect of\n          // `.innerHTML` parsing. Optimistically continue down this\n          // branch, but not before examining the other siblings.\n          firstChildren.push(child.firstChild);\n        }\n        child = child.nextSibling;\n      }\n      if (targetChild) {\n        // Emptying firstChildren/findComponentRootReusableArray is\n        // not necessary for correctness, but it helps the GC reclaim\n        // any nodes that were left at the end of the search.\n        firstChildren.length = 0;\n        return targetChild;\n      }\n    }\n    firstChildren.length = 0;\n    \"production\" !== process.env.NODE_ENV ? invariant(false, 'findComponentRoot(..., %s): Unable to find element. This probably ' + 'means the DOM was unexpectedly mutated (e.g., by the browser), ' + 'usually due to forgetting a <tbody> when using tables, nesting tags ' + 'like <form>, <p>, or <a>, or using non-SVG elements in an <svg> ' + 'parent. ' + 'Try inspecting the child nodes of the element with React ID `%s`.', targetID, ReactMount.getID(ancestorNode)) : invariant(false);\n  },\n  _mountImageIntoNode: function (markup, container, shouldReuseMarkup) {\n    \"production\" !== process.env.NODE_ENV ? invariant(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE), 'mountComponentIntoNode(...): Target container is not valid.') : invariant(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE));\n    if (shouldReuseMarkup) {\n      var rootElement = getReactRootElementInContainer(container);\n      if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {\n        return;\n      } else {\n        var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);\n        rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);\n        var rootMarkup = rootElement.outerHTML;\n        rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);\n        var diffIndex = firstDifferenceIndex(markup, rootMarkup);\n        var difference = ' (client) ' + markup.substring(diffIndex - 20, diffIndex + 20) + '\\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);\n        \"production\" !== process.env.NODE_ENV ? invariant(container.nodeType !== DOC_NODE_TYPE, 'You\\'re trying to render a component to the document using ' + 'server rendering but the checksum was invalid. This usually ' + 'means you rendered a different component type or props on ' + 'the client from the one on the server, or your render() ' + 'methods are impure. React cannot handle this case due to ' + 'cross-browser quirks by rendering at the document root. You ' + 'should look for environment dependent code in your components ' + 'and ensure the props are the same client and server side:\\n%s', difference) : invariant(container.nodeType !== DOC_NODE_TYPE);\n        if (\"production\" !== process.env.NODE_ENV) {\n          \"production\" !== process.env.NODE_ENV ? warning(false, 'React attempted to reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server:\\n%s', difference) : null;\n        }\n      }\n    }\n    \"production\" !== process.env.NODE_ENV ? invariant(container.nodeType !== DOC_NODE_TYPE, 'You\\'re trying to render a component to the document but ' + 'you didn\\'t use server rendering. We can\\'t do this ' + 'without using server rendering due to cross-browser quirks. ' + 'See React.renderToString() for server rendering.') : invariant(container.nodeType !== DOC_NODE_TYPE);\n    setInnerHTML(container, markup);\n  },\n  /**\n   * React ID utilities.\n   */\n\n  getReactRootID: getReactRootID,\n  getID: getID,\n  setID: setID,\n  getNode: getNode,\n  getNodeFromInstance: getNodeFromInstance,\n  purgeID: purgeID\n};\nReactPerf.measureMethods(ReactMount, 'ReactMount', {\n  _renderNewRootComponent: '_renderNewRootComponent',\n  _mountImageIntoNode: '_mountImageIntoNode'\n});\nmodule.exports = ReactMount;","map":{"version":3,"names":["DOMProperty","require","ReactBrowserEventEmitter","ReactCurrentOwner","ReactElement","ReactElementValidator","ReactEmptyComponent","ReactInstanceHandles","ReactInstanceMap","ReactMarkupChecksum","ReactPerf","ReactReconciler","ReactUpdateQueue","ReactUpdates","emptyObject","containsNode","getReactRootElementInContainer","instantiateReactComponent","invariant","setInnerHTML","shouldUpdateReactComponent","warning","SEPARATOR","ATTR_NAME","ID_ATTRIBUTE_NAME","nodeCache","ELEMENT_NODE_TYPE","DOC_NODE_TYPE","instancesByReactRootID","containersByReactRootID","process","env","NODE_ENV","rootElementsByReactRootID","findComponentRootReusableArray","firstDifferenceIndex","string1","string2","minLen","Math","min","length","i","charAt","getReactRootID","container","rootElement","ReactMount","getID","node","id","internalGetID","hasOwnProperty","cached","isValid","getAttribute","setID","oldID","setAttribute","getNode","findReactNodeByID","getNodeFromInstance","instance","get","_rootNodeID","isNullComponentID","findReactContainerForID","purgeID","deepestNodeSoFar","findDeepestCachedAncestorImpl","ancestorID","ancestor","findDeepestCachedAncestor","targetID","traverseAncestors","foundNode","mountComponentIntoNode","componentInstance","rootID","transaction","shouldReuseMarkup","markup","mountComponent","_isTopLevel","_mountImageIntoNode","batchedMountComponentIntoNode","ReactReconcileTransaction","getPooled","perform","release","_instancesByReactRootID","scrollMonitor","renderCallback","_updateRootComponent","prevComponent","nextElement","callback","checkAndWarnForMutatedProps","enqueueElementInternal","enqueueCallbackInternal","_registerComponent","nextComponent","nodeType","ensureScrollValueMonitoring","reactRootID","registerContainer","_renderNewRootComponent","current","batchedUpdates","render","isValidElement","props","undefined","prevElement","_currentElement","getPublicInstance","unmountComponentAtNode","reactRootElement","containerHasReactMarkup","isRenderedByReact","nextSibling","rootElementSibling","component","call","constructAndRenderComponent","constructor","element","createElement","constructAndRenderComponentByID","domNode","document","getElementById","getReactRootIDFromNodeID","createReactRootID","unmountComponentFromNode","unmountComponent","documentElement","lastChild","removeChild","parentNode","containerChild","firstChild","reactRoot","findComponentRoot","getFirstReactDOM","ancestorNode","firstChildren","childIndex","deepestAncestor","child","targetChild","childID","isAncestorIDOf","push","canReuseMarkup","checksum","CHECKSUM_ATTR_NAME","removeAttribute","rootMarkup","outerHTML","diffIndex","difference","substring","measureMethods","module","exports"],"sources":["C:/Users/raffy/Desktop/test/Synth/Synth/node_modules/react-embedded-browser/node_modules/react/lib/ReactMount.js"],"sourcesContent":["/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactMount\n */\n\n'use strict';\n\nvar DOMProperty = require(\"./DOMProperty\");\nvar ReactBrowserEventEmitter = require(\"./ReactBrowserEventEmitter\");\nvar ReactCurrentOwner = require(\"./ReactCurrentOwner\");\nvar ReactElement = require(\"./ReactElement\");\nvar ReactElementValidator = require(\"./ReactElementValidator\");\nvar ReactEmptyComponent = require(\"./ReactEmptyComponent\");\nvar ReactInstanceHandles = require(\"./ReactInstanceHandles\");\nvar ReactInstanceMap = require(\"./ReactInstanceMap\");\nvar ReactMarkupChecksum = require(\"./ReactMarkupChecksum\");\nvar ReactPerf = require(\"./ReactPerf\");\nvar ReactReconciler = require(\"./ReactReconciler\");\nvar ReactUpdateQueue = require(\"./ReactUpdateQueue\");\nvar ReactUpdates = require(\"./ReactUpdates\");\n\nvar emptyObject = require(\"./emptyObject\");\nvar containsNode = require(\"./containsNode\");\nvar getReactRootElementInContainer = require(\"./getReactRootElementInContainer\");\nvar instantiateReactComponent = require(\"./instantiateReactComponent\");\nvar invariant = require(\"./invariant\");\nvar setInnerHTML = require(\"./setInnerHTML\");\nvar shouldUpdateReactComponent = require(\"./shouldUpdateReactComponent\");\nvar warning = require(\"./warning\");\n\nvar SEPARATOR = ReactInstanceHandles.SEPARATOR;\n\nvar ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;\nvar nodeCache = {};\n\nvar ELEMENT_NODE_TYPE = 1;\nvar DOC_NODE_TYPE = 9;\n\n/** Mapping from reactRootID to React component instance. */\nvar instancesByReactRootID = {};\n\n/** Mapping from reactRootID to `container` nodes. */\nvar containersByReactRootID = {};\n\nif (\"production\" !== process.env.NODE_ENV) {\n  /** __DEV__-only mapping from reactRootID to root elements. */\n  var rootElementsByReactRootID = {};\n}\n\n// Used to store breadth-first search state in findComponentRoot.\nvar findComponentRootReusableArray = [];\n\n/**\n * Finds the index of the first character\n * that's not common between the two given strings.\n *\n * @return {number} the index of the character where the strings diverge\n */\nfunction firstDifferenceIndex(string1, string2) {\n  var minLen = Math.min(string1.length, string2.length);\n  for (var i = 0; i < minLen; i++) {\n    if (string1.charAt(i) !== string2.charAt(i)) {\n      return i;\n    }\n  }\n  return string1.length === string2.length ? -1 : minLen;\n}\n\n/**\n * @param {DOMElement} container DOM element that may contain a React component.\n * @return {?string} A \"reactRoot\" ID, if a React component is rendered.\n */\nfunction getReactRootID(container) {\n  var rootElement = getReactRootElementInContainer(container);\n  return rootElement && ReactMount.getID(rootElement);\n}\n\n/**\n * Accessing node[ATTR_NAME] or calling getAttribute(ATTR_NAME) on a form\n * element can return its control whose name or ID equals ATTR_NAME. All\n * DOM nodes support `getAttributeNode` but this can also get called on\n * other objects so just return '' if we're given something other than a\n * DOM node (such as window).\n *\n * @param {?DOMElement|DOMWindow|DOMDocument|DOMTextNode} node DOM node.\n * @return {string} ID of the supplied `domNode`.\n */\nfunction getID(node) {\n  var id = internalGetID(node);\n  if (id) {\n    if (nodeCache.hasOwnProperty(id)) {\n      var cached = nodeCache[id];\n      if (cached !== node) {\n        (\"production\" !== process.env.NODE_ENV ? invariant(\n          !isValid(cached, id),\n          'ReactMount: Two valid but unequal nodes with the same `%s`: %s',\n          ATTR_NAME, id\n        ) : invariant(!isValid(cached, id)));\n\n        nodeCache[id] = node;\n      }\n    } else {\n      nodeCache[id] = node;\n    }\n  }\n\n  return id;\n}\n\nfunction internalGetID(node) {\n  // If node is something like a window, document, or text node, none of\n  // which support attributes or a .getAttribute method, gracefully return\n  // the empty string, as if the attribute were missing.\n  return node && node.getAttribute && node.getAttribute(ATTR_NAME) || '';\n}\n\n/**\n * Sets the React-specific ID of the given node.\n *\n * @param {DOMElement} node The DOM node whose ID will be set.\n * @param {string} id The value of the ID attribute.\n */\nfunction setID(node, id) {\n  var oldID = internalGetID(node);\n  if (oldID !== id) {\n    delete nodeCache[oldID];\n  }\n  node.setAttribute(ATTR_NAME, id);\n  nodeCache[id] = node;\n}\n\n/**\n * Finds the node with the supplied React-generated DOM ID.\n *\n * @param {string} id A React-generated DOM ID.\n * @return {DOMElement} DOM node with the suppled `id`.\n * @internal\n */\nfunction getNode(id) {\n  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {\n    nodeCache[id] = ReactMount.findReactNodeByID(id);\n  }\n  return nodeCache[id];\n}\n\n/**\n * Finds the node with the supplied public React instance.\n *\n * @param {*} instance A public React instance.\n * @return {?DOMElement} DOM node with the suppled `id`.\n * @internal\n */\nfunction getNodeFromInstance(instance) {\n  var id = ReactInstanceMap.get(instance)._rootNodeID;\n  if (ReactEmptyComponent.isNullComponentID(id)) {\n    return null;\n  }\n  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {\n    nodeCache[id] = ReactMount.findReactNodeByID(id);\n  }\n  return nodeCache[id];\n}\n\n/**\n * A node is \"valid\" if it is contained by a currently mounted container.\n *\n * This means that the node does not have to be contained by a document in\n * order to be considered valid.\n *\n * @param {?DOMElement} node The candidate DOM node.\n * @param {string} id The expected ID of the node.\n * @return {boolean} Whether the node is contained by a mounted container.\n */\nfunction isValid(node, id) {\n  if (node) {\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      internalGetID(node) === id,\n      'ReactMount: Unexpected modification of `%s`',\n      ATTR_NAME\n    ) : invariant(internalGetID(node) === id));\n\n    var container = ReactMount.findReactContainerForID(id);\n    if (container && containsNode(container, node)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Causes the cache to forget about one React-specific ID.\n *\n * @param {string} id The ID to forget.\n */\nfunction purgeID(id) {\n  delete nodeCache[id];\n}\n\nvar deepestNodeSoFar = null;\nfunction findDeepestCachedAncestorImpl(ancestorID) {\n  var ancestor = nodeCache[ancestorID];\n  if (ancestor && isValid(ancestor, ancestorID)) {\n    deepestNodeSoFar = ancestor;\n  } else {\n    // This node isn't populated in the cache, so presumably none of its\n    // descendants are. Break out of the loop.\n    return false;\n  }\n}\n\n/**\n * Return the deepest cached node whose ID is a prefix of `targetID`.\n */\nfunction findDeepestCachedAncestor(targetID) {\n  deepestNodeSoFar = null;\n  ReactInstanceHandles.traverseAncestors(\n    targetID,\n    findDeepestCachedAncestorImpl\n  );\n\n  var foundNode = deepestNodeSoFar;\n  deepestNodeSoFar = null;\n  return foundNode;\n}\n\n/**\n * Mounts this component and inserts it into the DOM.\n *\n * @param {ReactComponent} componentInstance The instance to mount.\n * @param {string} rootID DOM ID of the root node.\n * @param {DOMElement} container DOM element to mount into.\n * @param {ReactReconcileTransaction} transaction\n * @param {boolean} shouldReuseMarkup If true, do not insert markup\n */\nfunction mountComponentIntoNode(\n    componentInstance,\n    rootID,\n    container,\n    transaction,\n    shouldReuseMarkup) {\n  var markup = ReactReconciler.mountComponent(\n    componentInstance, rootID, transaction, emptyObject\n  );\n  componentInstance._isTopLevel = true;\n  ReactMount._mountImageIntoNode(markup, container, shouldReuseMarkup);\n}\n\n/**\n * Batched mount.\n *\n * @param {ReactComponent} componentInstance The instance to mount.\n * @param {string} rootID DOM ID of the root node.\n * @param {DOMElement} container DOM element to mount into.\n * @param {boolean} shouldReuseMarkup If true, do not insert markup\n */\nfunction batchedMountComponentIntoNode(\n    componentInstance,\n    rootID,\n    container,\n    shouldReuseMarkup) {\n  var transaction = ReactUpdates.ReactReconcileTransaction.getPooled();\n  transaction.perform(\n    mountComponentIntoNode,\n    null,\n    componentInstance,\n    rootID,\n    container,\n    transaction,\n    shouldReuseMarkup\n  );\n  ReactUpdates.ReactReconcileTransaction.release(transaction);\n}\n\n/**\n * Mounting is the process of initializing a React component by creating its\n * representative DOM elements and inserting them into a supplied `container`.\n * Any prior content inside `container` is destroyed in the process.\n *\n *   ReactMount.render(\n *     component,\n *     document.getElementById('container')\n *   );\n *\n *   <div id=\"container\">                   <-- Supplied `container`.\n *     <div data-reactid=\".3\">              <-- Rendered reactRoot of React\n *       // ...                                 component.\n *     </div>\n *   </div>\n *\n * Inside of `container`, the first element rendered is the \"reactRoot\".\n */\nvar ReactMount = {\n  /** Exposed for debugging purposes **/\n  _instancesByReactRootID: instancesByReactRootID,\n\n  /**\n   * This is a hook provided to support rendering React components while\n   * ensuring that the apparent scroll position of its `container` does not\n   * change.\n   *\n   * @param {DOMElement} container The `container` being rendered into.\n   * @param {function} renderCallback This must be called once to do the render.\n   */\n  scrollMonitor: function(container, renderCallback) {\n    renderCallback();\n  },\n\n  /**\n   * Take a component that's already mounted into the DOM and replace its props\n   * @param {ReactComponent} prevComponent component instance already in the DOM\n   * @param {ReactElement} nextElement component instance to render\n   * @param {DOMElement} container container to render into\n   * @param {?function} callback function triggered on completion\n   */\n  _updateRootComponent: function(\n      prevComponent,\n      nextElement,\n      container,\n      callback) {\n    if (\"production\" !== process.env.NODE_ENV) {\n      ReactElementValidator.checkAndWarnForMutatedProps(nextElement);\n    }\n\n    ReactMount.scrollMonitor(container, function() {\n      ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement);\n      if (callback) {\n        ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);\n      }\n    });\n\n    if (\"production\" !== process.env.NODE_ENV) {\n      // Record the root element in case it later gets transplanted.\n      rootElementsByReactRootID[getReactRootID(container)] =\n        getReactRootElementInContainer(container);\n    }\n\n    return prevComponent;\n  },\n\n  /**\n   * Register a component into the instance map and starts scroll value\n   * monitoring\n   * @param {ReactComponent} nextComponent component instance to render\n   * @param {DOMElement} container container to render into\n   * @return {string} reactRoot ID prefix\n   */\n  _registerComponent: function(nextComponent, container) {\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      container && (\n        (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE)\n      ),\n      '_registerComponent(...): Target container is not a DOM element.'\n    ) : invariant(container && (\n      (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE)\n    )));\n\n    ReactBrowserEventEmitter.ensureScrollValueMonitoring();\n\n    var reactRootID = ReactMount.registerContainer(container);\n    instancesByReactRootID[reactRootID] = nextComponent;\n    return reactRootID;\n  },\n\n  /**\n   * Render a new component into the DOM.\n   * @param {ReactElement} nextElement element to render\n   * @param {DOMElement} container container to render into\n   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion\n   * @return {ReactComponent} nextComponent\n   */\n  _renderNewRootComponent: function(\n    nextElement,\n    container,\n    shouldReuseMarkup\n  ) {\n    // Various parts of our code (such as ReactCompositeComponent's\n    // _renderValidatedComponent) assume that calls to render aren't nested;\n    // verify that that's the case.\n    (\"production\" !== process.env.NODE_ENV ? warning(\n      ReactCurrentOwner.current == null,\n      '_renderNewRootComponent(): Render methods should be a pure function ' +\n      'of props and state; triggering nested component updates from ' +\n      'render is not allowed. If necessary, trigger nested updates in ' +\n      'componentDidUpdate.'\n    ) : null);\n\n    var componentInstance = instantiateReactComponent(nextElement, null);\n    var reactRootID = ReactMount._registerComponent(\n      componentInstance,\n      container\n    );\n\n    // The initial render is synchronous but any updates that happen during\n    // rendering, in componentWillMount or componentDidMount, will be batched\n    // according to the current batching strategy.\n\n    ReactUpdates.batchedUpdates(\n      batchedMountComponentIntoNode,\n      componentInstance,\n      reactRootID,\n      container,\n      shouldReuseMarkup\n    );\n\n    if (\"production\" !== process.env.NODE_ENV) {\n      // Record the root element in case it later gets transplanted.\n      rootElementsByReactRootID[reactRootID] =\n        getReactRootElementInContainer(container);\n    }\n\n    return componentInstance;\n  },\n\n  /**\n   * Renders a React component into the DOM in the supplied `container`.\n   *\n   * If the React component was previously rendered into `container`, this will\n   * perform an update on it and only mutate the DOM as necessary to reflect the\n   * latest React component.\n   *\n   * @param {ReactElement} nextElement Component element to render.\n   * @param {DOMElement} container DOM element to render into.\n   * @param {?function} callback function triggered on completion\n   * @return {ReactComponent} Component instance rendered in `container`.\n   */\n  render: function(nextElement, container, callback) {\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      ReactElement.isValidElement(nextElement),\n      'React.render(): Invalid component element.%s',\n      (\n        typeof nextElement === 'string' ?\n          ' Instead of passing an element string, make sure to instantiate ' +\n          'it by passing it to React.createElement.' :\n        typeof nextElement === 'function' ?\n          ' Instead of passing a component class, make sure to instantiate ' +\n          'it by passing it to React.createElement.' :\n        // Check if it quacks like an element\n        nextElement != null && nextElement.props !== undefined ?\n          ' This may be caused by unintentionally loading two independent ' +\n          'copies of React.' :\n          ''\n      )\n    ) : invariant(ReactElement.isValidElement(nextElement)));\n\n    var prevComponent = instancesByReactRootID[getReactRootID(container)];\n\n    if (prevComponent) {\n      var prevElement = prevComponent._currentElement;\n      if (shouldUpdateReactComponent(prevElement, nextElement)) {\n        return ReactMount._updateRootComponent(\n          prevComponent,\n          nextElement,\n          container,\n          callback\n        ).getPublicInstance();\n      } else {\n        ReactMount.unmountComponentAtNode(container);\n      }\n    }\n\n    var reactRootElement = getReactRootElementInContainer(container);\n    var containerHasReactMarkup =\n      reactRootElement && ReactMount.isRenderedByReact(reactRootElement);\n\n    if (\"production\" !== process.env.NODE_ENV) {\n      if (!containerHasReactMarkup || reactRootElement.nextSibling) {\n        var rootElementSibling = reactRootElement;\n        while (rootElementSibling) {\n          if (ReactMount.isRenderedByReact(rootElementSibling)) {\n            (\"production\" !== process.env.NODE_ENV ? warning(\n              false,\n              'render(): Target node has markup rendered by React, but there ' +\n              'are unrelated nodes as well. This is most commonly caused by ' +\n              'white-space inserted around server-rendered markup.'\n            ) : null);\n            break;\n          }\n\n          rootElementSibling = rootElementSibling.nextSibling;\n        }\n      }\n    }\n\n    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent;\n\n    var component = ReactMount._renderNewRootComponent(\n      nextElement,\n      container,\n      shouldReuseMarkup\n    ).getPublicInstance();\n    if (callback) {\n      callback.call(component);\n    }\n    return component;\n  },\n\n  /**\n   * Constructs a component instance of `constructor` with `initialProps` and\n   * renders it into the supplied `container`.\n   *\n   * @param {function} constructor React component constructor.\n   * @param {?object} props Initial props of the component instance.\n   * @param {DOMElement} container DOM element to render into.\n   * @return {ReactComponent} Component instance rendered in `container`.\n   */\n  constructAndRenderComponent: function(constructor, props, container) {\n    var element = ReactElement.createElement(constructor, props);\n    return ReactMount.render(element, container);\n  },\n\n  /**\n   * Constructs a component instance of `constructor` with `initialProps` and\n   * renders it into a container node identified by supplied `id`.\n   *\n   * @param {function} componentConstructor React component constructor\n   * @param {?object} props Initial props of the component instance.\n   * @param {string} id ID of the DOM element to render into.\n   * @return {ReactComponent} Component instance rendered in the container node.\n   */\n  constructAndRenderComponentByID: function(constructor, props, id) {\n    var domNode = document.getElementById(id);\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      domNode,\n      'Tried to get element with id of \"%s\" but it is not present on the page.',\n      id\n    ) : invariant(domNode));\n    return ReactMount.constructAndRenderComponent(constructor, props, domNode);\n  },\n\n  /**\n   * Registers a container node into which React components will be rendered.\n   * This also creates the \"reactRoot\" ID that will be assigned to the element\n   * rendered within.\n   *\n   * @param {DOMElement} container DOM element to register as a container.\n   * @return {string} The \"reactRoot\" ID of elements rendered within.\n   */\n  registerContainer: function(container) {\n    var reactRootID = getReactRootID(container);\n    if (reactRootID) {\n      // If one exists, make sure it is a valid \"reactRoot\" ID.\n      reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID);\n    }\n    if (!reactRootID) {\n      // No valid \"reactRoot\" ID found, create one.\n      reactRootID = ReactInstanceHandles.createReactRootID();\n    }\n    containersByReactRootID[reactRootID] = container;\n    return reactRootID;\n  },\n\n  /**\n   * Unmounts and destroys the React component rendered in the `container`.\n   *\n   * @param {DOMElement} container DOM element containing a React component.\n   * @return {boolean} True if a component was found in and unmounted from\n   *                   `container`\n   */\n  unmountComponentAtNode: function(container) {\n    // Various parts of our code (such as ReactCompositeComponent's\n    // _renderValidatedComponent) assume that calls to render aren't nested;\n    // verify that that's the case. (Strictly speaking, unmounting won't cause a\n    // render but we still don't expect to be in a render call here.)\n    (\"production\" !== process.env.NODE_ENV ? warning(\n      ReactCurrentOwner.current == null,\n      'unmountComponentAtNode(): Render methods should be a pure function of ' +\n      'props and state; triggering nested component updates from render is ' +\n      'not allowed. If necessary, trigger nested updates in ' +\n      'componentDidUpdate.'\n    ) : null);\n\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      container && (\n        (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE)\n      ),\n      'unmountComponentAtNode(...): Target container is not a DOM element.'\n    ) : invariant(container && (\n      (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE)\n    )));\n\n    var reactRootID = getReactRootID(container);\n    var component = instancesByReactRootID[reactRootID];\n    if (!component) {\n      return false;\n    }\n    ReactMount.unmountComponentFromNode(component, container);\n    delete instancesByReactRootID[reactRootID];\n    delete containersByReactRootID[reactRootID];\n    if (\"production\" !== process.env.NODE_ENV) {\n      delete rootElementsByReactRootID[reactRootID];\n    }\n    return true;\n  },\n\n  /**\n   * Unmounts a component and removes it from the DOM.\n   *\n   * @param {ReactComponent} instance React component instance.\n   * @param {DOMElement} container DOM element to unmount from.\n   * @final\n   * @internal\n   * @see {ReactMount.unmountComponentAtNode}\n   */\n  unmountComponentFromNode: function(instance, container) {\n    ReactReconciler.unmountComponent(instance);\n\n    if (container.nodeType === DOC_NODE_TYPE) {\n      container = container.documentElement;\n    }\n\n    // http://jsperf.com/emptying-a-node\n    while (container.lastChild) {\n      container.removeChild(container.lastChild);\n    }\n  },\n\n  /**\n   * Finds the container DOM element that contains React component to which the\n   * supplied DOM `id` belongs.\n   *\n   * @param {string} id The ID of an element rendered by a React component.\n   * @return {?DOMElement} DOM element that contains the `id`.\n   */\n  findReactContainerForID: function(id) {\n    var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(id);\n    var container = containersByReactRootID[reactRootID];\n\n    if (\"production\" !== process.env.NODE_ENV) {\n      var rootElement = rootElementsByReactRootID[reactRootID];\n      if (rootElement && rootElement.parentNode !== container) {\n        (\"production\" !== process.env.NODE_ENV ? invariant(\n          // Call internalGetID here because getID calls isValid which calls\n          // findReactContainerForID (this function).\n          internalGetID(rootElement) === reactRootID,\n          'ReactMount: Root element ID differed from reactRootID.'\n        ) : invariant(// Call internalGetID here because getID calls isValid which calls\n        // findReactContainerForID (this function).\n        internalGetID(rootElement) === reactRootID));\n\n        var containerChild = container.firstChild;\n        if (containerChild &&\n            reactRootID === internalGetID(containerChild)) {\n          // If the container has a new child with the same ID as the old\n          // root element, then rootElementsByReactRootID[reactRootID] is\n          // just stale and needs to be updated. The case that deserves a\n          // warning is when the container is empty.\n          rootElementsByReactRootID[reactRootID] = containerChild;\n        } else {\n          (\"production\" !== process.env.NODE_ENV ? warning(\n            false,\n            'ReactMount: Root element has been removed from its original ' +\n            'container. New container:', rootElement.parentNode\n          ) : null);\n        }\n      }\n    }\n\n    return container;\n  },\n\n  /**\n   * Finds an element rendered by React with the supplied ID.\n   *\n   * @param {string} id ID of a DOM node in the React component.\n   * @return {DOMElement} Root DOM node of the React component.\n   */\n  findReactNodeByID: function(id) {\n    var reactRoot = ReactMount.findReactContainerForID(id);\n    return ReactMount.findComponentRoot(reactRoot, id);\n  },\n\n  /**\n   * True if the supplied `node` is rendered by React.\n   *\n   * @param {*} node DOM Element to check.\n   * @return {boolean} True if the DOM Element appears to be rendered by React.\n   * @internal\n   */\n  isRenderedByReact: function(node) {\n    if (node.nodeType !== 1) {\n      // Not a DOMElement, therefore not a React component\n      return false;\n    }\n    var id = ReactMount.getID(node);\n    return id ? id.charAt(0) === SEPARATOR : false;\n  },\n\n  /**\n   * Traverses up the ancestors of the supplied node to find a node that is a\n   * DOM representation of a React component.\n   *\n   * @param {*} node\n   * @return {?DOMEventTarget}\n   * @internal\n   */\n  getFirstReactDOM: function(node) {\n    var current = node;\n    while (current && current.parentNode !== current) {\n      if (ReactMount.isRenderedByReact(current)) {\n        return current;\n      }\n      current = current.parentNode;\n    }\n    return null;\n  },\n\n  /**\n   * Finds a node with the supplied `targetID` inside of the supplied\n   * `ancestorNode`.  Exploits the ID naming scheme to perform the search\n   * quickly.\n   *\n   * @param {DOMEventTarget} ancestorNode Search from this root.\n   * @pararm {string} targetID ID of the DOM representation of the component.\n   * @return {DOMEventTarget} DOM node with the supplied `targetID`.\n   * @internal\n   */\n  findComponentRoot: function(ancestorNode, targetID) {\n    var firstChildren = findComponentRootReusableArray;\n    var childIndex = 0;\n\n    var deepestAncestor = findDeepestCachedAncestor(targetID) || ancestorNode;\n\n    firstChildren[0] = deepestAncestor.firstChild;\n    firstChildren.length = 1;\n\n    while (childIndex < firstChildren.length) {\n      var child = firstChildren[childIndex++];\n      var targetChild;\n\n      while (child) {\n        var childID = ReactMount.getID(child);\n        if (childID) {\n          // Even if we find the node we're looking for, we finish looping\n          // through its siblings to ensure they're cached so that we don't have\n          // to revisit this node again. Otherwise, we make n^2 calls to getID\n          // when visiting the many children of a single node in order.\n\n          if (targetID === childID) {\n            targetChild = child;\n          } else if (ReactInstanceHandles.isAncestorIDOf(childID, targetID)) {\n            // If we find a child whose ID is an ancestor of the given ID,\n            // then we can be sure that we only want to search the subtree\n            // rooted at this child, so we can throw out the rest of the\n            // search state.\n            firstChildren.length = childIndex = 0;\n            firstChildren.push(child.firstChild);\n          }\n\n        } else {\n          // If this child had no ID, then there's a chance that it was\n          // injected automatically by the browser, as when a `<table>`\n          // element sprouts an extra `<tbody>` child as a side effect of\n          // `.innerHTML` parsing. Optimistically continue down this\n          // branch, but not before examining the other siblings.\n          firstChildren.push(child.firstChild);\n        }\n\n        child = child.nextSibling;\n      }\n\n      if (targetChild) {\n        // Emptying firstChildren/findComponentRootReusableArray is\n        // not necessary for correctness, but it helps the GC reclaim\n        // any nodes that were left at the end of the search.\n        firstChildren.length = 0;\n\n        return targetChild;\n      }\n    }\n\n    firstChildren.length = 0;\n\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      false,\n      'findComponentRoot(..., %s): Unable to find element. This probably ' +\n      'means the DOM was unexpectedly mutated (e.g., by the browser), ' +\n      'usually due to forgetting a <tbody> when using tables, nesting tags ' +\n      'like <form>, <p>, or <a>, or using non-SVG elements in an <svg> ' +\n      'parent. ' +\n      'Try inspecting the child nodes of the element with React ID `%s`.',\n      targetID,\n      ReactMount.getID(ancestorNode)\n    ) : invariant(false));\n  },\n\n  _mountImageIntoNode: function(markup, container, shouldReuseMarkup) {\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      container && (\n        (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE)\n      ),\n      'mountComponentIntoNode(...): Target container is not valid.'\n    ) : invariant(container && (\n      (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE)\n    )));\n\n    if (shouldReuseMarkup) {\n      var rootElement = getReactRootElementInContainer(container);\n      if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {\n        return;\n      } else {\n        var checksum = rootElement.getAttribute(\n          ReactMarkupChecksum.CHECKSUM_ATTR_NAME\n        );\n        rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);\n\n        var rootMarkup = rootElement.outerHTML;\n        rootElement.setAttribute(\n          ReactMarkupChecksum.CHECKSUM_ATTR_NAME,\n          checksum\n        );\n\n        var diffIndex = firstDifferenceIndex(markup, rootMarkup);\n        var difference = ' (client) ' +\n          markup.substring(diffIndex - 20, diffIndex + 20) +\n          '\\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);\n\n        (\"production\" !== process.env.NODE_ENV ? invariant(\n          container.nodeType !== DOC_NODE_TYPE,\n          'You\\'re trying to render a component to the document using ' +\n          'server rendering but the checksum was invalid. This usually ' +\n          'means you rendered a different component type or props on ' +\n          'the client from the one on the server, or your render() ' +\n          'methods are impure. React cannot handle this case due to ' +\n          'cross-browser quirks by rendering at the document root. You ' +\n          'should look for environment dependent code in your components ' +\n          'and ensure the props are the same client and server side:\\n%s',\n          difference\n        ) : invariant(container.nodeType !== DOC_NODE_TYPE));\n\n        if (\"production\" !== process.env.NODE_ENV) {\n          (\"production\" !== process.env.NODE_ENV ? warning(\n            false,\n            'React attempted to reuse markup in a container but the ' +\n            'checksum was invalid. This generally means that you are ' +\n            'using server rendering and the markup generated on the ' +\n            'server was not what the client was expecting. React injected ' +\n            'new markup to compensate which works but you have lost many ' +\n            'of the benefits of server rendering. Instead, figure out ' +\n            'why the markup being generated is different on the client ' +\n            'or server:\\n%s',\n            difference\n          ) : null);\n        }\n      }\n    }\n\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      container.nodeType !== DOC_NODE_TYPE,\n      'You\\'re trying to render a component to the document but ' +\n        'you didn\\'t use server rendering. We can\\'t do this ' +\n        'without using server rendering due to cross-browser quirks. ' +\n        'See React.renderToString() for server rendering.'\n    ) : invariant(container.nodeType !== DOC_NODE_TYPE));\n\n    setInnerHTML(container, markup);\n  },\n\n  /**\n   * React ID utilities.\n   */\n\n  getReactRootID: getReactRootID,\n\n  getID: getID,\n\n  setID: setID,\n\n  getNode: getNode,\n\n  getNodeFromInstance: getNodeFromInstance,\n\n  purgeID: purgeID\n};\n\nReactPerf.measureMethods(ReactMount, 'ReactMount', {\n  _renderNewRootComponent: '_renderNewRootComponent',\n  _mountImageIntoNode: '_mountImageIntoNode'\n});\n\nmodule.exports = ReactMount;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}