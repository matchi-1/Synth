{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { UnsupportedOperation } from '../common/Errors.js';\nimport { EventEmitter } from '../common/EventEmitter.js';\nimport { TimeoutSettings } from '../common/TimeoutSettings.js';\nimport { withSourcePuppeteerURLIfNone } from '../common/util.js';\n/**\n * This class represents a\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API | WebWorker}.\n *\n * @remarks\n * The events `workercreated` and `workerdestroyed` are emitted on the page\n * object to signal the worker lifecycle.\n *\n * @example\n *\n * ```ts\n * page.on('workercreated', worker =>\n *   console.log('Worker created: ' + worker.url())\n * );\n * page.on('workerdestroyed', worker =>\n *   console.log('Worker destroyed: ' + worker.url())\n * );\n *\n * console.log('Current workers:');\n * for (const worker of page.workers()) {\n *   console.log('  ' + worker.url());\n * }\n * ```\n *\n * @public\n */\nexport class WebWorker extends EventEmitter {\n  /**\n   * @internal\n   */\n  timeoutSettings = new TimeoutSettings();\n  #url;\n  /**\n   * @internal\n   */\n  constructor(url) {\n    super();\n    this.#url = url;\n  }\n  /**\n   * The URL of this web worker.\n   */\n  url() {\n    return this.#url;\n  }\n  /**\n   * Evaluates a given function in the {@link WebWorker | worker}.\n   *\n   * @remarks If the given function returns a promise,\n   * {@link WebWorker.evaluate | evaluate} will wait for the promise to resolve.\n   *\n   * As a rule of thumb, if the return value of the given function is more\n   * complicated than a JSON object (e.g. most classes), then\n   * {@link WebWorker.evaluate | evaluate} will _likely_ return some truncated\n   * value (or `{}`). This is because we are not returning the actual return\n   * value, but a deserialized version as a result of transferring the return\n   * value through a protocol to Puppeteer.\n   *\n   * In general, you should use\n   * {@link WebWorker.evaluateHandle | evaluateHandle} if\n   * {@link WebWorker.evaluate | evaluate} cannot serialize the return value\n   * properly or you need a mutable {@link JSHandle | handle} to the return\n   * object.\n   *\n   * @param func - Function to be evaluated.\n   * @param args - Arguments to pass into `func`.\n   * @returns The result of `func`.\n   */\n  async evaluate(func, ...args) {\n    func = withSourcePuppeteerURLIfNone(this.evaluate.name, func);\n    return await this.mainRealm().evaluate(func, ...args);\n  }\n  /**\n   * Evaluates a given function in the {@link WebWorker | worker}.\n   *\n   * @remarks If the given function returns a promise,\n   * {@link WebWorker.evaluate | evaluate} will wait for the promise to resolve.\n   *\n   * In general, you should use\n   * {@link WebWorker.evaluateHandle | evaluateHandle} if\n   * {@link WebWorker.evaluate | evaluate} cannot serialize the return value\n   * properly or you need a mutable {@link JSHandle | handle} to the return\n   * object.\n   *\n   * @param func - Function to be evaluated.\n   * @param args - Arguments to pass into `func`.\n   * @returns A {@link JSHandle | handle} to the return value of `func`.\n   */\n  async evaluateHandle(func, ...args) {\n    func = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, func);\n    return await this.mainRealm().evaluateHandle(func, ...args);\n  }\n  async close() {\n    throw new UnsupportedOperation('WebWorker.close() is not supported');\n  }\n}","map":{"version":3,"names":["UnsupportedOperation","EventEmitter","TimeoutSettings","withSourcePuppeteerURLIfNone","WebWorker","timeoutSettings","url","constructor","evaluate","func","args","name","mainRealm","evaluateHandle","close"],"sources":["C:\\Users\\raffy\\Desktop\\test\\node_modules\\puppeteer-core\\src\\api\\WebWorker.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {UnsupportedOperation} from '../common/Errors.js';\nimport {EventEmitter, type EventType} from '../common/EventEmitter.js';\nimport {TimeoutSettings} from '../common/TimeoutSettings.js';\nimport type {EvaluateFunc, HandleFor} from '../common/types.js';\nimport {withSourcePuppeteerURLIfNone} from '../common/util.js';\n\nimport type {CDPSession} from './CDPSession.js';\nimport type {Realm} from './Realm.js';\n\n/**\n * This class represents a\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API | WebWorker}.\n *\n * @remarks\n * The events `workercreated` and `workerdestroyed` are emitted on the page\n * object to signal the worker lifecycle.\n *\n * @example\n *\n * ```ts\n * page.on('workercreated', worker =>\n *   console.log('Worker created: ' + worker.url())\n * );\n * page.on('workerdestroyed', worker =>\n *   console.log('Worker destroyed: ' + worker.url())\n * );\n *\n * console.log('Current workers:');\n * for (const worker of page.workers()) {\n *   console.log('  ' + worker.url());\n * }\n * ```\n *\n * @public\n */\nexport abstract class WebWorker extends EventEmitter<\n  Record<EventType, unknown>\n> {\n  /**\n   * @internal\n   */\n  readonly timeoutSettings = new TimeoutSettings();\n\n  readonly #url: string;\n\n  /**\n   * @internal\n   */\n  constructor(url: string) {\n    super();\n\n    this.#url = url;\n  }\n\n  /**\n   * @internal\n   */\n  abstract mainRealm(): Realm;\n\n  /**\n   * The URL of this web worker.\n   */\n  url(): string {\n    return this.#url;\n  }\n\n  /**\n   * The CDP session client the WebWorker belongs to.\n   */\n  abstract get client(): CDPSession;\n\n  /**\n   * Evaluates a given function in the {@link WebWorker | worker}.\n   *\n   * @remarks If the given function returns a promise,\n   * {@link WebWorker.evaluate | evaluate} will wait for the promise to resolve.\n   *\n   * As a rule of thumb, if the return value of the given function is more\n   * complicated than a JSON object (e.g. most classes), then\n   * {@link WebWorker.evaluate | evaluate} will _likely_ return some truncated\n   * value (or `{}`). This is because we are not returning the actual return\n   * value, but a deserialized version as a result of transferring the return\n   * value through a protocol to Puppeteer.\n   *\n   * In general, you should use\n   * {@link WebWorker.evaluateHandle | evaluateHandle} if\n   * {@link WebWorker.evaluate | evaluate} cannot serialize the return value\n   * properly or you need a mutable {@link JSHandle | handle} to the return\n   * object.\n   *\n   * @param func - Function to be evaluated.\n   * @param args - Arguments to pass into `func`.\n   * @returns The result of `func`.\n   */\n  async evaluate<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(func: Func | string, ...args: Params): Promise<Awaited<ReturnType<Func>>> {\n    func = withSourcePuppeteerURLIfNone(this.evaluate.name, func);\n    return await this.mainRealm().evaluate(func, ...args);\n  }\n\n  /**\n   * Evaluates a given function in the {@link WebWorker | worker}.\n   *\n   * @remarks If the given function returns a promise,\n   * {@link WebWorker.evaluate | evaluate} will wait for the promise to resolve.\n   *\n   * In general, you should use\n   * {@link WebWorker.evaluateHandle | evaluateHandle} if\n   * {@link WebWorker.evaluate | evaluate} cannot serialize the return value\n   * properly or you need a mutable {@link JSHandle | handle} to the return\n   * object.\n   *\n   * @param func - Function to be evaluated.\n   * @param args - Arguments to pass into `func`.\n   * @returns A {@link JSHandle | handle} to the return value of `func`.\n   */\n  async evaluateHandle<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(\n    func: Func | string,\n    ...args: Params\n  ): Promise<HandleFor<Awaited<ReturnType<Func>>>> {\n    func = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, func);\n    return await this.mainRealm().evaluateHandle(func, ...args);\n  }\n\n  async close(): Promise<void> {\n    throw new UnsupportedOperation('WebWorker.close() is not supported');\n  }\n}\n"],"mappings":"AAAA;;;;;AAMA,SAAQA,oBAAoB,QAAO,qBAAqB;AACxD,SAAQC,YAAY,QAAuB,2BAA2B;AACtE,SAAQC,eAAe,QAAO,8BAA8B;AAE5D,SAAQC,4BAA4B,QAAO,mBAAmB;AAK9D;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA,OAAM,MAAgBC,SAAU,SAAQH,YAEvC;EACC;;;EAGSI,eAAe,GAAG,IAAIH,eAAe,EAAE;EAEvC,CAAAI,GAAI;EAEb;;;EAGAC,YAAYD,GAAW;IACrB,KAAK,EAAE;IAEP,IAAI,CAAC,CAAAA,GAAI,GAAGA,GAAG;EACjB;EAOA;;;EAGAA,GAAGA,CAAA;IACD,OAAO,IAAI,CAAC,CAAAA,GAAI;EAClB;EAOA;;;;;;;;;;;;;;;;;;;;;;;EAuBA,MAAME,QAAQA,CAGZC,IAAmB,EAAE,GAAGC,IAAY;IACpCD,IAAI,GAAGN,4BAA4B,CAAC,IAAI,CAACK,QAAQ,CAACG,IAAI,EAAEF,IAAI,CAAC;IAC7D,OAAO,MAAM,IAAI,CAACG,SAAS,EAAE,CAACJ,QAAQ,CAACC,IAAI,EAAE,GAAGC,IAAI,CAAC;EACvD;EAEA;;;;;;;;;;;;;;;;EAgBA,MAAMG,cAAcA,CAIlBJ,IAAmB,EACnB,GAAGC,IAAY;IAEfD,IAAI,GAAGN,4BAA4B,CAAC,IAAI,CAACU,cAAc,CAACF,IAAI,EAAEF,IAAI,CAAC;IACnE,OAAO,MAAM,IAAI,CAACG,SAAS,EAAE,CAACC,cAAc,CAACJ,IAAI,EAAE,GAAGC,IAAI,CAAC;EAC7D;EAEA,MAAMI,KAAKA,CAAA;IACT,MAAM,IAAId,oBAAoB,CAAC,oCAAoC,CAAC;EACtE","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}