{"ast":null,"code":"/**\n * @license\n * Copyright 2022 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { assert } from '../util/assert.js';\nimport { Deferred } from '../util/Deferred.js';\n/**\n * Device in a request prompt.\n *\n * @public\n */\nexport class DeviceRequestPromptDevice {\n  /**\n   * Device id during a prompt.\n   */\n  id;\n  /**\n   * Device name as it appears in a prompt.\n   */\n  name;\n  /**\n   * @internal\n   */\n  constructor(id, name) {\n    this.id = id;\n    this.name = name;\n  }\n}\n/**\n * Device request prompts let you respond to the page requesting for a device\n * through an API like WebBluetooth.\n *\n * @remarks\n * `DeviceRequestPrompt` instances are returned via the\n * {@link Page.waitForDevicePrompt} method.\n *\n * @example\n *\n * ```ts\n * const [devicePrompt] = Promise.all([\n *   page.waitForDevicePrompt(),\n *   page.click('#connect-bluetooth'),\n * ]);\n * await devicePrompt.select(\n *   await devicePrompt.waitForDevice(({name}) => name.includes('My Device'))\n * );\n * ```\n *\n * @public\n */\nexport class DeviceRequestPrompt {\n  #client;\n  #timeoutSettings;\n  #id;\n  #handled = false;\n  #updateDevicesHandle = this.#updateDevices.bind(this);\n  #waitForDevicePromises = new Set();\n  /**\n   * Current list of selectable devices.\n   */\n  devices = [];\n  /**\n   * @internal\n   */\n  constructor(client, timeoutSettings, firstEvent) {\n    this.#client = client;\n    this.#timeoutSettings = timeoutSettings;\n    this.#id = firstEvent.id;\n    this.#client.on('DeviceAccess.deviceRequestPrompted', this.#updateDevicesHandle);\n    this.#client.on('Target.detachedFromTarget', () => {\n      this.#client = null;\n    });\n    this.#updateDevices(firstEvent);\n  }\n  #updateDevices(event) {\n    if (event.id !== this.#id) {\n      return;\n    }\n    for (const rawDevice of event.devices) {\n      if (this.devices.some(device => {\n        return device.id === rawDevice.id;\n      })) {\n        continue;\n      }\n      const newDevice = new DeviceRequestPromptDevice(rawDevice.id, rawDevice.name);\n      this.devices.push(newDevice);\n      for (const waitForDevicePromise of this.#waitForDevicePromises) {\n        if (waitForDevicePromise.filter(newDevice)) {\n          waitForDevicePromise.promise.resolve(newDevice);\n        }\n      }\n    }\n  }\n  /**\n   * Resolve to the first device in the prompt matching a filter.\n   */\n  async waitForDevice(filter, options = {}) {\n    for (const device of this.devices) {\n      if (filter(device)) {\n        return device;\n      }\n    }\n    const {\n      timeout = this.#timeoutSettings.timeout()\n    } = options;\n    const deferred = Deferred.create({\n      message: `Waiting for \\`DeviceRequestPromptDevice\\` failed: ${timeout}ms exceeded`,\n      timeout\n    });\n    if (options.signal) {\n      options.signal.addEventListener('abort', () => {\n        deferred.reject(options.signal?.reason);\n      }, {\n        once: true\n      });\n    }\n    const handle = {\n      filter,\n      promise: deferred\n    };\n    this.#waitForDevicePromises.add(handle);\n    try {\n      return await deferred.valueOrThrow();\n    } finally {\n      this.#waitForDevicePromises.delete(handle);\n    }\n  }\n  /**\n   * Select a device in the prompt's list.\n   */\n  async select(device) {\n    assert(this.#client !== null, 'Cannot select device through detached session!');\n    assert(this.devices.includes(device), 'Cannot select unknown device!');\n    assert(!this.#handled, 'Cannot select DeviceRequestPrompt which is already handled!');\n    this.#client.off('DeviceAccess.deviceRequestPrompted', this.#updateDevicesHandle);\n    this.#handled = true;\n    return await this.#client.send('DeviceAccess.selectPrompt', {\n      id: this.#id,\n      deviceId: device.id\n    });\n  }\n  /**\n   * Cancel the prompt.\n   */\n  async cancel() {\n    assert(this.#client !== null, 'Cannot cancel prompt through detached session!');\n    assert(!this.#handled, 'Cannot cancel DeviceRequestPrompt which is already handled!');\n    this.#client.off('DeviceAccess.deviceRequestPrompted', this.#updateDevicesHandle);\n    this.#handled = true;\n    return await this.#client.send('DeviceAccess.cancelPrompt', {\n      id: this.#id\n    });\n  }\n}\n/**\n * @internal\n */\nexport class DeviceRequestPromptManager {\n  #client;\n  #timeoutSettings;\n  #deviceRequestPrompDeferreds = new Set();\n  /**\n   * @internal\n   */\n  constructor(client, timeoutSettings) {\n    this.#client = client;\n    this.#timeoutSettings = timeoutSettings;\n    this.#client.on('DeviceAccess.deviceRequestPrompted', event => {\n      this.#onDeviceRequestPrompted(event);\n    });\n    this.#client.on('Target.detachedFromTarget', () => {\n      this.#client = null;\n    });\n  }\n  /**\n   * Wait for device prompt created by an action like calling WebBluetooth's\n   * requestDevice.\n   */\n  async waitForDevicePrompt(options = {}) {\n    assert(this.#client !== null, 'Cannot wait for device prompt through detached session!');\n    const needsEnable = this.#deviceRequestPrompDeferreds.size === 0;\n    let enablePromise;\n    if (needsEnable) {\n      enablePromise = this.#client.send('DeviceAccess.enable');\n    }\n    const {\n      timeout = this.#timeoutSettings.timeout()\n    } = options;\n    const deferred = Deferred.create({\n      message: `Waiting for \\`DeviceRequestPrompt\\` failed: ${timeout}ms exceeded`,\n      timeout\n    });\n    if (options.signal) {\n      options.signal.addEventListener('abort', () => {\n        deferred.reject(options.signal?.reason);\n      }, {\n        once: true\n      });\n    }\n    this.#deviceRequestPrompDeferreds.add(deferred);\n    try {\n      const [result] = await Promise.all([deferred.valueOrThrow(), enablePromise]);\n      return result;\n    } finally {\n      this.#deviceRequestPrompDeferreds.delete(deferred);\n    }\n  }\n  /**\n   * @internal\n   */\n  #onDeviceRequestPrompted(event) {\n    if (!this.#deviceRequestPrompDeferreds.size) {\n      return;\n    }\n    assert(this.#client !== null);\n    const devicePrompt = new DeviceRequestPrompt(this.#client, this.#timeoutSettings, event);\n    for (const promise of this.#deviceRequestPrompDeferreds) {\n      promise.resolve(devicePrompt);\n    }\n    this.#deviceRequestPrompDeferreds.clear();\n  }\n}","map":{"version":3,"names":["assert","Deferred","DeviceRequestPromptDevice","id","name","constructor","DeviceRequestPrompt","client","timeoutSettings","handled","updateDevicesHandle","updateDevices","bind","waitForDevicePromises","Set","devices","firstEvent","on","#updateDevices","event","rawDevice","some","device","newDevice","push","waitForDevicePromise","filter","promise","resolve","waitForDevice","options","timeout","deferred","create","message","signal","addEventListener","reject","reason","once","handle","add","valueOrThrow","delete","select","includes","off","send","deviceId","cancel","DeviceRequestPromptManager","deviceRequestPrompDeferreds","onDeviceRequestPrompted","waitForDevicePrompt","needsEnable","size","enablePromise","result","Promise","all","#onDeviceRequestPrompted","devicePrompt","clear"],"sources":["C:\\Users\\raffy\\Desktop\\test\\node_modules\\puppeteer-core\\src\\cdp\\DeviceRequestPrompt.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2022 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport type Protocol from 'devtools-protocol';\n\nimport type {CDPSession} from '../api/CDPSession.js';\nimport type {WaitTimeoutOptions} from '../api/Page.js';\nimport type {TimeoutSettings} from '../common/TimeoutSettings.js';\nimport {assert} from '../util/assert.js';\nimport {Deferred} from '../util/Deferred.js';\n\n/**\n * Device in a request prompt.\n *\n * @public\n */\nexport class DeviceRequestPromptDevice {\n  /**\n   * Device id during a prompt.\n   */\n  id: string;\n\n  /**\n   * Device name as it appears in a prompt.\n   */\n  name: string;\n\n  /**\n   * @internal\n   */\n  constructor(id: string, name: string) {\n    this.id = id;\n    this.name = name;\n  }\n}\n\n/**\n * Device request prompts let you respond to the page requesting for a device\n * through an API like WebBluetooth.\n *\n * @remarks\n * `DeviceRequestPrompt` instances are returned via the\n * {@link Page.waitForDevicePrompt} method.\n *\n * @example\n *\n * ```ts\n * const [devicePrompt] = Promise.all([\n *   page.waitForDevicePrompt(),\n *   page.click('#connect-bluetooth'),\n * ]);\n * await devicePrompt.select(\n *   await devicePrompt.waitForDevice(({name}) => name.includes('My Device'))\n * );\n * ```\n *\n * @public\n */\nexport class DeviceRequestPrompt {\n  #client: CDPSession | null;\n  #timeoutSettings: TimeoutSettings;\n  #id: string;\n  #handled = false;\n  #updateDevicesHandle = this.#updateDevices.bind(this);\n  #waitForDevicePromises = new Set<{\n    filter: (device: DeviceRequestPromptDevice) => boolean;\n    promise: Deferred<DeviceRequestPromptDevice>;\n  }>();\n\n  /**\n   * Current list of selectable devices.\n   */\n  devices: DeviceRequestPromptDevice[] = [];\n\n  /**\n   * @internal\n   */\n  constructor(\n    client: CDPSession,\n    timeoutSettings: TimeoutSettings,\n    firstEvent: Protocol.DeviceAccess.DeviceRequestPromptedEvent\n  ) {\n    this.#client = client;\n    this.#timeoutSettings = timeoutSettings;\n    this.#id = firstEvent.id;\n\n    this.#client.on(\n      'DeviceAccess.deviceRequestPrompted',\n      this.#updateDevicesHandle\n    );\n    this.#client.on('Target.detachedFromTarget', () => {\n      this.#client = null;\n    });\n\n    this.#updateDevices(firstEvent);\n  }\n\n  #updateDevices(event: Protocol.DeviceAccess.DeviceRequestPromptedEvent) {\n    if (event.id !== this.#id) {\n      return;\n    }\n\n    for (const rawDevice of event.devices) {\n      if (\n        this.devices.some(device => {\n          return device.id === rawDevice.id;\n        })\n      ) {\n        continue;\n      }\n\n      const newDevice = new DeviceRequestPromptDevice(\n        rawDevice.id,\n        rawDevice.name\n      );\n      this.devices.push(newDevice);\n\n      for (const waitForDevicePromise of this.#waitForDevicePromises) {\n        if (waitForDevicePromise.filter(newDevice)) {\n          waitForDevicePromise.promise.resolve(newDevice);\n        }\n      }\n    }\n  }\n\n  /**\n   * Resolve to the first device in the prompt matching a filter.\n   */\n  async waitForDevice(\n    filter: (device: DeviceRequestPromptDevice) => boolean,\n    options: WaitTimeoutOptions = {}\n  ): Promise<DeviceRequestPromptDevice> {\n    for (const device of this.devices) {\n      if (filter(device)) {\n        return device;\n      }\n    }\n\n    const {timeout = this.#timeoutSettings.timeout()} = options;\n    const deferred = Deferred.create<DeviceRequestPromptDevice>({\n      message: `Waiting for \\`DeviceRequestPromptDevice\\` failed: ${timeout}ms exceeded`,\n      timeout,\n    });\n\n    if (options.signal) {\n      options.signal.addEventListener(\n        'abort',\n        () => {\n          deferred.reject(options.signal?.reason);\n        },\n        {once: true}\n      );\n    }\n\n    const handle = {filter, promise: deferred};\n    this.#waitForDevicePromises.add(handle);\n    try {\n      return await deferred.valueOrThrow();\n    } finally {\n      this.#waitForDevicePromises.delete(handle);\n    }\n  }\n\n  /**\n   * Select a device in the prompt's list.\n   */\n  async select(device: DeviceRequestPromptDevice): Promise<void> {\n    assert(\n      this.#client !== null,\n      'Cannot select device through detached session!'\n    );\n    assert(this.devices.includes(device), 'Cannot select unknown device!');\n    assert(\n      !this.#handled,\n      'Cannot select DeviceRequestPrompt which is already handled!'\n    );\n    this.#client.off(\n      'DeviceAccess.deviceRequestPrompted',\n      this.#updateDevicesHandle\n    );\n    this.#handled = true;\n    return await this.#client.send('DeviceAccess.selectPrompt', {\n      id: this.#id,\n      deviceId: device.id,\n    });\n  }\n\n  /**\n   * Cancel the prompt.\n   */\n  async cancel(): Promise<void> {\n    assert(\n      this.#client !== null,\n      'Cannot cancel prompt through detached session!'\n    );\n    assert(\n      !this.#handled,\n      'Cannot cancel DeviceRequestPrompt which is already handled!'\n    );\n    this.#client.off(\n      'DeviceAccess.deviceRequestPrompted',\n      this.#updateDevicesHandle\n    );\n    this.#handled = true;\n    return await this.#client.send('DeviceAccess.cancelPrompt', {id: this.#id});\n  }\n}\n\n/**\n * @internal\n */\nexport class DeviceRequestPromptManager {\n  #client: CDPSession | null;\n  #timeoutSettings: TimeoutSettings;\n  #deviceRequestPrompDeferreds = new Set<Deferred<DeviceRequestPrompt>>();\n\n  /**\n   * @internal\n   */\n  constructor(client: CDPSession, timeoutSettings: TimeoutSettings) {\n    this.#client = client;\n    this.#timeoutSettings = timeoutSettings;\n\n    this.#client.on('DeviceAccess.deviceRequestPrompted', event => {\n      this.#onDeviceRequestPrompted(event);\n    });\n    this.#client.on('Target.detachedFromTarget', () => {\n      this.#client = null;\n    });\n  }\n\n  /**\n   * Wait for device prompt created by an action like calling WebBluetooth's\n   * requestDevice.\n   */\n  async waitForDevicePrompt(\n    options: WaitTimeoutOptions = {}\n  ): Promise<DeviceRequestPrompt> {\n    assert(\n      this.#client !== null,\n      'Cannot wait for device prompt through detached session!'\n    );\n    const needsEnable = this.#deviceRequestPrompDeferreds.size === 0;\n    let enablePromise: Promise<void> | undefined;\n    if (needsEnable) {\n      enablePromise = this.#client.send('DeviceAccess.enable');\n    }\n\n    const {timeout = this.#timeoutSettings.timeout()} = options;\n    const deferred = Deferred.create<DeviceRequestPrompt>({\n      message: `Waiting for \\`DeviceRequestPrompt\\` failed: ${timeout}ms exceeded`,\n      timeout,\n    });\n    if (options.signal) {\n      options.signal.addEventListener(\n        'abort',\n        () => {\n          deferred.reject(options.signal?.reason);\n        },\n        {once: true}\n      );\n    }\n\n    this.#deviceRequestPrompDeferreds.add(deferred);\n\n    try {\n      const [result] = await Promise.all([\n        deferred.valueOrThrow(),\n        enablePromise,\n      ]);\n      return result;\n    } finally {\n      this.#deviceRequestPrompDeferreds.delete(deferred);\n    }\n  }\n\n  /**\n   * @internal\n   */\n  #onDeviceRequestPrompted(\n    event: Protocol.DeviceAccess.DeviceRequestPromptedEvent\n  ) {\n    if (!this.#deviceRequestPrompDeferreds.size) {\n      return;\n    }\n\n    assert(this.#client !== null);\n    const devicePrompt = new DeviceRequestPrompt(\n      this.#client,\n      this.#timeoutSettings,\n      event\n    );\n    for (const promise of this.#deviceRequestPrompDeferreds) {\n      promise.resolve(devicePrompt);\n    }\n    this.#deviceRequestPrompDeferreds.clear();\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}