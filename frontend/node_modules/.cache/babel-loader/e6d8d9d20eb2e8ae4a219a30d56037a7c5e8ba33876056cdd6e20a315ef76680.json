{"ast":null,"code":"/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactInstanceHandles\n * @typechecks static-only\n */\n\n'use strict';\n\nvar ReactRootIndex = require(\"./ReactRootIndex\");\nvar invariant = require(\"./invariant\");\nvar SEPARATOR = '.';\nvar SEPARATOR_LENGTH = SEPARATOR.length;\n\n/**\n * Maximum depth of traversals before we consider the possibility of a bad ID.\n */\nvar MAX_TREE_DEPTH = 100;\n\n/**\n * Creates a DOM ID prefix to use when mounting React components.\n *\n * @param {number} index A unique integer\n * @return {string} React root ID.\n * @internal\n */\nfunction getReactRootIDString(index) {\n  return SEPARATOR + index.toString(36);\n}\n\n/**\n * Checks if a character in the supplied ID is a separator or the end.\n *\n * @param {string} id A React DOM ID.\n * @param {number} index Index of the character to check.\n * @return {boolean} True if the character is a separator or end of the ID.\n * @private\n */\nfunction isBoundary(id, index) {\n  return id.charAt(index) === SEPARATOR || index === id.length;\n}\n\n/**\n * Checks if the supplied string is a valid React DOM ID.\n *\n * @param {string} id A React DOM ID, maybe.\n * @return {boolean} True if the string is a valid React DOM ID.\n * @private\n */\nfunction isValidID(id) {\n  return id === '' || id.charAt(0) === SEPARATOR && id.charAt(id.length - 1) !== SEPARATOR;\n}\n\n/**\n * Checks if the first ID is an ancestor of or equal to the second ID.\n *\n * @param {string} ancestorID\n * @param {string} descendantID\n * @return {boolean} True if `ancestorID` is an ancestor of `descendantID`.\n * @internal\n */\nfunction isAncestorIDOf(ancestorID, descendantID) {\n  return descendantID.indexOf(ancestorID) === 0 && isBoundary(descendantID, ancestorID.length);\n}\n\n/**\n * Gets the parent ID of the supplied React DOM ID, `id`.\n *\n * @param {string} id ID of a component.\n * @return {string} ID of the parent, or an empty string.\n * @private\n */\nfunction getParentID(id) {\n  return id ? id.substr(0, id.lastIndexOf(SEPARATOR)) : '';\n}\n\n/**\n * Gets the next DOM ID on the tree path from the supplied `ancestorID` to the\n * supplied `destinationID`. If they are equal, the ID is returned.\n *\n * @param {string} ancestorID ID of an ancestor node of `destinationID`.\n * @param {string} destinationID ID of the destination node.\n * @return {string} Next ID on the path from `ancestorID` to `destinationID`.\n * @private\n */\nfunction getNextDescendantID(ancestorID, destinationID) {\n  \"production\" !== process.env.NODE_ENV ? invariant(isValidID(ancestorID) && isValidID(destinationID), 'getNextDescendantID(%s, %s): Received an invalid React DOM ID.', ancestorID, destinationID) : invariant(isValidID(ancestorID) && isValidID(destinationID));\n  \"production\" !== process.env.NODE_ENV ? invariant(isAncestorIDOf(ancestorID, destinationID), 'getNextDescendantID(...): React has made an invalid assumption about ' + 'the DOM hierarchy. Expected `%s` to be an ancestor of `%s`.', ancestorID, destinationID) : invariant(isAncestorIDOf(ancestorID, destinationID));\n  if (ancestorID === destinationID) {\n    return ancestorID;\n  }\n  // Skip over the ancestor and the immediate separator. Traverse until we hit\n  // another separator or we reach the end of `destinationID`.\n  var start = ancestorID.length + SEPARATOR_LENGTH;\n  var i;\n  for (i = start; i < destinationID.length; i++) {\n    if (isBoundary(destinationID, i)) {\n      break;\n    }\n  }\n  return destinationID.substr(0, i);\n}\n\n/**\n * Gets the nearest common ancestor ID of two IDs.\n *\n * Using this ID scheme, the nearest common ancestor ID is the longest common\n * prefix of the two IDs that immediately preceded a \"marker\" in both strings.\n *\n * @param {string} oneID\n * @param {string} twoID\n * @return {string} Nearest common ancestor ID, or the empty string if none.\n * @private\n */\nfunction getFirstCommonAncestorID(oneID, twoID) {\n  var minLength = Math.min(oneID.length, twoID.length);\n  if (minLength === 0) {\n    return '';\n  }\n  var lastCommonMarkerIndex = 0;\n  // Use `<=` to traverse until the \"EOL\" of the shorter string.\n  for (var i = 0; i <= minLength; i++) {\n    if (isBoundary(oneID, i) && isBoundary(twoID, i)) {\n      lastCommonMarkerIndex = i;\n    } else if (oneID.charAt(i) !== twoID.charAt(i)) {\n      break;\n    }\n  }\n  var longestCommonID = oneID.substr(0, lastCommonMarkerIndex);\n  \"production\" !== process.env.NODE_ENV ? invariant(isValidID(longestCommonID), 'getFirstCommonAncestorID(%s, %s): Expected a valid React DOM ID: %s', oneID, twoID, longestCommonID) : invariant(isValidID(longestCommonID));\n  return longestCommonID;\n}\n\n/**\n * Traverses the parent path between two IDs (either up or down). The IDs must\n * not be the same, and there must exist a parent path between them. If the\n * callback returns `false`, traversal is stopped.\n *\n * @param {?string} start ID at which to start traversal.\n * @param {?string} stop ID at which to end traversal.\n * @param {function} cb Callback to invoke each ID with.\n * @param {?boolean} skipFirst Whether or not to skip the first node.\n * @param {?boolean} skipLast Whether or not to skip the last node.\n * @private\n */\nfunction traverseParentPath(start, stop, cb, arg, skipFirst, skipLast) {\n  start = start || '';\n  stop = stop || '';\n  \"production\" !== process.env.NODE_ENV ? invariant(start !== stop, 'traverseParentPath(...): Cannot traverse from and to the same ID, `%s`.', start) : invariant(start !== stop);\n  var traverseUp = isAncestorIDOf(stop, start);\n  \"production\" !== process.env.NODE_ENV ? invariant(traverseUp || isAncestorIDOf(start, stop), 'traverseParentPath(%s, %s, ...): Cannot traverse from two IDs that do ' + 'not have a parent path.', start, stop) : invariant(traverseUp || isAncestorIDOf(start, stop));\n  // Traverse from `start` to `stop` one depth at a time.\n  var depth = 0;\n  var traverse = traverseUp ? getParentID : getNextDescendantID;\n  for /* until break */\n  (var id = start;; id = traverse(id, stop)) {\n    var ret;\n    if ((!skipFirst || id !== start) && (!skipLast || id !== stop)) {\n      ret = cb(id, traverseUp, arg);\n    }\n    if (ret === false || id === stop) {\n      // Only break //after// visiting `stop`.\n      break;\n    }\n    \"production\" !== process.env.NODE_ENV ? invariant(depth++ < MAX_TREE_DEPTH, 'traverseParentPath(%s, %s, ...): Detected an infinite loop while ' + 'traversing the React DOM ID tree. This may be due to malformed IDs: %s', start, stop) : invariant(depth++ < MAX_TREE_DEPTH);\n  }\n}\n\n/**\n * Manages the IDs assigned to DOM representations of React components. This\n * uses a specific scheme in order to traverse the DOM efficiently (e.g. in\n * order to simulate events).\n *\n * @internal\n */\nvar ReactInstanceHandles = {\n  /**\n   * Constructs a React root ID\n   * @return {string} A React root ID.\n   */\n  createReactRootID: function () {\n    return getReactRootIDString(ReactRootIndex.createReactRootIndex());\n  },\n  /**\n   * Constructs a React ID by joining a root ID with a name.\n   *\n   * @param {string} rootID Root ID of a parent component.\n   * @param {string} name A component's name (as flattened children).\n   * @return {string} A React ID.\n   * @internal\n   */\n  createReactID: function (rootID, name) {\n    return rootID + name;\n  },\n  /**\n   * Gets the DOM ID of the React component that is the root of the tree that\n   * contains the React component with the supplied DOM ID.\n   *\n   * @param {string} id DOM ID of a React component.\n   * @return {?string} DOM ID of the React component that is the root.\n   * @internal\n   */\n  getReactRootIDFromNodeID: function (id) {\n    if (id && id.charAt(0) === SEPARATOR && id.length > 1) {\n      var index = id.indexOf(SEPARATOR, 1);\n      return index > -1 ? id.substr(0, index) : id;\n    }\n    return null;\n  },\n  /**\n   * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that\n   * should would receive a `mouseEnter` or `mouseLeave` event.\n   *\n   * NOTE: Does not invoke the callback on the nearest common ancestor because\n   * nothing \"entered\" or \"left\" that element.\n   *\n   * @param {string} leaveID ID being left.\n   * @param {string} enterID ID being entered.\n   * @param {function} cb Callback to invoke on each entered/left ID.\n   * @param {*} upArg Argument to invoke the callback with on left IDs.\n   * @param {*} downArg Argument to invoke the callback with on entered IDs.\n   * @internal\n   */\n  traverseEnterLeave: function (leaveID, enterID, cb, upArg, downArg) {\n    var ancestorID = getFirstCommonAncestorID(leaveID, enterID);\n    if (ancestorID !== leaveID) {\n      traverseParentPath(leaveID, ancestorID, cb, upArg, false, true);\n    }\n    if (ancestorID !== enterID) {\n      traverseParentPath(ancestorID, enterID, cb, downArg, true, false);\n    }\n  },\n  /**\n   * Simulates the traversal of a two-phase, capture/bubble event dispatch.\n   *\n   * NOTE: This traversal happens on IDs without touching the DOM.\n   *\n   * @param {string} targetID ID of the target node.\n   * @param {function} cb Callback to invoke.\n   * @param {*} arg Argument to invoke the callback with.\n   * @internal\n   */\n  traverseTwoPhase: function (targetID, cb, arg) {\n    if (targetID) {\n      traverseParentPath('', targetID, cb, arg, true, false);\n      traverseParentPath(targetID, '', cb, arg, false, true);\n    }\n  },\n  /**\n   * Traverse a node ID, calling the supplied `cb` for each ancestor ID. For\n   * example, passing `.0.$row-0.1` would result in `cb` getting called\n   * with `.0`, `.0.$row-0`, and `.0.$row-0.1`.\n   *\n   * NOTE: This traversal happens on IDs without touching the DOM.\n   *\n   * @param {string} targetID ID of the target node.\n   * @param {function} cb Callback to invoke.\n   * @param {*} arg Argument to invoke the callback with.\n   * @internal\n   */\n  traverseAncestors: function (targetID, cb, arg) {\n    traverseParentPath('', targetID, cb, arg, true, false);\n  },\n  /**\n   * Exposed for unit testing.\n   * @private\n   */\n  _getFirstCommonAncestorID: getFirstCommonAncestorID,\n  /**\n   * Exposed for unit testing.\n   * @private\n   */\n  _getNextDescendantID: getNextDescendantID,\n  isAncestorIDOf: isAncestorIDOf,\n  SEPARATOR: SEPARATOR\n};\nmodule.exports = ReactInstanceHandles;","map":{"version":3,"names":["ReactRootIndex","require","invariant","SEPARATOR","SEPARATOR_LENGTH","length","MAX_TREE_DEPTH","getReactRootIDString","index","toString","isBoundary","id","charAt","isValidID","isAncestorIDOf","ancestorID","descendantID","indexOf","getParentID","substr","lastIndexOf","getNextDescendantID","destinationID","process","env","NODE_ENV","start","i","getFirstCommonAncestorID","oneID","twoID","minLength","Math","min","lastCommonMarkerIndex","longestCommonID","traverseParentPath","stop","cb","arg","skipFirst","skipLast","traverseUp","depth","traverse","ret","ReactInstanceHandles","createReactRootID","createReactRootIndex","createReactID","rootID","name","getReactRootIDFromNodeID","traverseEnterLeave","leaveID","enterID","upArg","downArg","traverseTwoPhase","targetID","traverseAncestors","_getFirstCommonAncestorID","_getNextDescendantID","module","exports"],"sources":["C:/Users/raffy/Desktop/test/Synth/Synth/node_modules/react-embedded-browser/node_modules/react/lib/ReactInstanceHandles.js"],"sourcesContent":["/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactInstanceHandles\n * @typechecks static-only\n */\n\n'use strict';\n\nvar ReactRootIndex = require(\"./ReactRootIndex\");\n\nvar invariant = require(\"./invariant\");\n\nvar SEPARATOR = '.';\nvar SEPARATOR_LENGTH = SEPARATOR.length;\n\n/**\n * Maximum depth of traversals before we consider the possibility of a bad ID.\n */\nvar MAX_TREE_DEPTH = 100;\n\n/**\n * Creates a DOM ID prefix to use when mounting React components.\n *\n * @param {number} index A unique integer\n * @return {string} React root ID.\n * @internal\n */\nfunction getReactRootIDString(index) {\n  return SEPARATOR + index.toString(36);\n}\n\n/**\n * Checks if a character in the supplied ID is a separator or the end.\n *\n * @param {string} id A React DOM ID.\n * @param {number} index Index of the character to check.\n * @return {boolean} True if the character is a separator or end of the ID.\n * @private\n */\nfunction isBoundary(id, index) {\n  return id.charAt(index) === SEPARATOR || index === id.length;\n}\n\n/**\n * Checks if the supplied string is a valid React DOM ID.\n *\n * @param {string} id A React DOM ID, maybe.\n * @return {boolean} True if the string is a valid React DOM ID.\n * @private\n */\nfunction isValidID(id) {\n  return id === '' || (\n    id.charAt(0) === SEPARATOR && id.charAt(id.length - 1) !== SEPARATOR\n  );\n}\n\n/**\n * Checks if the first ID is an ancestor of or equal to the second ID.\n *\n * @param {string} ancestorID\n * @param {string} descendantID\n * @return {boolean} True if `ancestorID` is an ancestor of `descendantID`.\n * @internal\n */\nfunction isAncestorIDOf(ancestorID, descendantID) {\n  return (\n    descendantID.indexOf(ancestorID) === 0 &&\n    isBoundary(descendantID, ancestorID.length)\n  );\n}\n\n/**\n * Gets the parent ID of the supplied React DOM ID, `id`.\n *\n * @param {string} id ID of a component.\n * @return {string} ID of the parent, or an empty string.\n * @private\n */\nfunction getParentID(id) {\n  return id ? id.substr(0, id.lastIndexOf(SEPARATOR)) : '';\n}\n\n/**\n * Gets the next DOM ID on the tree path from the supplied `ancestorID` to the\n * supplied `destinationID`. If they are equal, the ID is returned.\n *\n * @param {string} ancestorID ID of an ancestor node of `destinationID`.\n * @param {string} destinationID ID of the destination node.\n * @return {string} Next ID on the path from `ancestorID` to `destinationID`.\n * @private\n */\nfunction getNextDescendantID(ancestorID, destinationID) {\n  (\"production\" !== process.env.NODE_ENV ? invariant(\n    isValidID(ancestorID) && isValidID(destinationID),\n    'getNextDescendantID(%s, %s): Received an invalid React DOM ID.',\n    ancestorID,\n    destinationID\n  ) : invariant(isValidID(ancestorID) && isValidID(destinationID)));\n  (\"production\" !== process.env.NODE_ENV ? invariant(\n    isAncestorIDOf(ancestorID, destinationID),\n    'getNextDescendantID(...): React has made an invalid assumption about ' +\n    'the DOM hierarchy. Expected `%s` to be an ancestor of `%s`.',\n    ancestorID,\n    destinationID\n  ) : invariant(isAncestorIDOf(ancestorID, destinationID)));\n  if (ancestorID === destinationID) {\n    return ancestorID;\n  }\n  // Skip over the ancestor and the immediate separator. Traverse until we hit\n  // another separator or we reach the end of `destinationID`.\n  var start = ancestorID.length + SEPARATOR_LENGTH;\n  var i;\n  for (i = start; i < destinationID.length; i++) {\n    if (isBoundary(destinationID, i)) {\n      break;\n    }\n  }\n  return destinationID.substr(0, i);\n}\n\n/**\n * Gets the nearest common ancestor ID of two IDs.\n *\n * Using this ID scheme, the nearest common ancestor ID is the longest common\n * prefix of the two IDs that immediately preceded a \"marker\" in both strings.\n *\n * @param {string} oneID\n * @param {string} twoID\n * @return {string} Nearest common ancestor ID, or the empty string if none.\n * @private\n */\nfunction getFirstCommonAncestorID(oneID, twoID) {\n  var minLength = Math.min(oneID.length, twoID.length);\n  if (minLength === 0) {\n    return '';\n  }\n  var lastCommonMarkerIndex = 0;\n  // Use `<=` to traverse until the \"EOL\" of the shorter string.\n  for (var i = 0; i <= minLength; i++) {\n    if (isBoundary(oneID, i) && isBoundary(twoID, i)) {\n      lastCommonMarkerIndex = i;\n    } else if (oneID.charAt(i) !== twoID.charAt(i)) {\n      break;\n    }\n  }\n  var longestCommonID = oneID.substr(0, lastCommonMarkerIndex);\n  (\"production\" !== process.env.NODE_ENV ? invariant(\n    isValidID(longestCommonID),\n    'getFirstCommonAncestorID(%s, %s): Expected a valid React DOM ID: %s',\n    oneID,\n    twoID,\n    longestCommonID\n  ) : invariant(isValidID(longestCommonID)));\n  return longestCommonID;\n}\n\n/**\n * Traverses the parent path between two IDs (either up or down). The IDs must\n * not be the same, and there must exist a parent path between them. If the\n * callback returns `false`, traversal is stopped.\n *\n * @param {?string} start ID at which to start traversal.\n * @param {?string} stop ID at which to end traversal.\n * @param {function} cb Callback to invoke each ID with.\n * @param {?boolean} skipFirst Whether or not to skip the first node.\n * @param {?boolean} skipLast Whether or not to skip the last node.\n * @private\n */\nfunction traverseParentPath(start, stop, cb, arg, skipFirst, skipLast) {\n  start = start || '';\n  stop = stop || '';\n  (\"production\" !== process.env.NODE_ENV ? invariant(\n    start !== stop,\n    'traverseParentPath(...): Cannot traverse from and to the same ID, `%s`.',\n    start\n  ) : invariant(start !== stop));\n  var traverseUp = isAncestorIDOf(stop, start);\n  (\"production\" !== process.env.NODE_ENV ? invariant(\n    traverseUp || isAncestorIDOf(start, stop),\n    'traverseParentPath(%s, %s, ...): Cannot traverse from two IDs that do ' +\n    'not have a parent path.',\n    start,\n    stop\n  ) : invariant(traverseUp || isAncestorIDOf(start, stop)));\n  // Traverse from `start` to `stop` one depth at a time.\n  var depth = 0;\n  var traverse = traverseUp ? getParentID : getNextDescendantID;\n  for (var id = start; /* until break */; id = traverse(id, stop)) {\n    var ret;\n    if ((!skipFirst || id !== start) && (!skipLast || id !== stop)) {\n      ret = cb(id, traverseUp, arg);\n    }\n    if (ret === false || id === stop) {\n      // Only break //after// visiting `stop`.\n      break;\n    }\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      depth++ < MAX_TREE_DEPTH,\n      'traverseParentPath(%s, %s, ...): Detected an infinite loop while ' +\n      'traversing the React DOM ID tree. This may be due to malformed IDs: %s',\n      start, stop\n    ) : invariant(depth++ < MAX_TREE_DEPTH));\n  }\n}\n\n/**\n * Manages the IDs assigned to DOM representations of React components. This\n * uses a specific scheme in order to traverse the DOM efficiently (e.g. in\n * order to simulate events).\n *\n * @internal\n */\nvar ReactInstanceHandles = {\n\n  /**\n   * Constructs a React root ID\n   * @return {string} A React root ID.\n   */\n  createReactRootID: function() {\n    return getReactRootIDString(ReactRootIndex.createReactRootIndex());\n  },\n\n  /**\n   * Constructs a React ID by joining a root ID with a name.\n   *\n   * @param {string} rootID Root ID of a parent component.\n   * @param {string} name A component's name (as flattened children).\n   * @return {string} A React ID.\n   * @internal\n   */\n  createReactID: function(rootID, name) {\n    return rootID + name;\n  },\n\n  /**\n   * Gets the DOM ID of the React component that is the root of the tree that\n   * contains the React component with the supplied DOM ID.\n   *\n   * @param {string} id DOM ID of a React component.\n   * @return {?string} DOM ID of the React component that is the root.\n   * @internal\n   */\n  getReactRootIDFromNodeID: function(id) {\n    if (id && id.charAt(0) === SEPARATOR && id.length > 1) {\n      var index = id.indexOf(SEPARATOR, 1);\n      return index > -1 ? id.substr(0, index) : id;\n    }\n    return null;\n  },\n\n  /**\n   * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that\n   * should would receive a `mouseEnter` or `mouseLeave` event.\n   *\n   * NOTE: Does not invoke the callback on the nearest common ancestor because\n   * nothing \"entered\" or \"left\" that element.\n   *\n   * @param {string} leaveID ID being left.\n   * @param {string} enterID ID being entered.\n   * @param {function} cb Callback to invoke on each entered/left ID.\n   * @param {*} upArg Argument to invoke the callback with on left IDs.\n   * @param {*} downArg Argument to invoke the callback with on entered IDs.\n   * @internal\n   */\n  traverseEnterLeave: function(leaveID, enterID, cb, upArg, downArg) {\n    var ancestorID = getFirstCommonAncestorID(leaveID, enterID);\n    if (ancestorID !== leaveID) {\n      traverseParentPath(leaveID, ancestorID, cb, upArg, false, true);\n    }\n    if (ancestorID !== enterID) {\n      traverseParentPath(ancestorID, enterID, cb, downArg, true, false);\n    }\n  },\n\n  /**\n   * Simulates the traversal of a two-phase, capture/bubble event dispatch.\n   *\n   * NOTE: This traversal happens on IDs without touching the DOM.\n   *\n   * @param {string} targetID ID of the target node.\n   * @param {function} cb Callback to invoke.\n   * @param {*} arg Argument to invoke the callback with.\n   * @internal\n   */\n  traverseTwoPhase: function(targetID, cb, arg) {\n    if (targetID) {\n      traverseParentPath('', targetID, cb, arg, true, false);\n      traverseParentPath(targetID, '', cb, arg, false, true);\n    }\n  },\n\n  /**\n   * Traverse a node ID, calling the supplied `cb` for each ancestor ID. For\n   * example, passing `.0.$row-0.1` would result in `cb` getting called\n   * with `.0`, `.0.$row-0`, and `.0.$row-0.1`.\n   *\n   * NOTE: This traversal happens on IDs without touching the DOM.\n   *\n   * @param {string} targetID ID of the target node.\n   * @param {function} cb Callback to invoke.\n   * @param {*} arg Argument to invoke the callback with.\n   * @internal\n   */\n  traverseAncestors: function(targetID, cb, arg) {\n    traverseParentPath('', targetID, cb, arg, true, false);\n  },\n\n  /**\n   * Exposed for unit testing.\n   * @private\n   */\n  _getFirstCommonAncestorID: getFirstCommonAncestorID,\n\n  /**\n   * Exposed for unit testing.\n   * @private\n   */\n  _getNextDescendantID: getNextDescendantID,\n\n  isAncestorIDOf: isAncestorIDOf,\n\n  SEPARATOR: SEPARATOR\n\n};\n\nmodule.exports = ReactInstanceHandles;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}