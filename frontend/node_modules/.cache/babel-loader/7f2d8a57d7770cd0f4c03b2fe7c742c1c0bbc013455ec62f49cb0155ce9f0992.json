{"ast":null,"code":"var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _EventStream_instances, _EventStream_connectedPromise, _EventStream_resolveConnectedPromise, _EventStream_rejectConnectedPromise, _EventStream_endPromise, _EventStream_resolveEndPromise, _EventStream_rejectEndPromise, _EventStream_listeners, _EventStream_ended, _EventStream_errored, _EventStream_aborted, _EventStream_catchingPromiseCreated, _EventStream_handleError;\nimport { APIUserAbortError, OpenAIError } from 'openai/error';\nexport class EventStream {\n  constructor() {\n    _EventStream_instances.add(this);\n    this.controller = new AbortController();\n    _EventStream_connectedPromise.set(this, void 0);\n    _EventStream_resolveConnectedPromise.set(this, () => {});\n    _EventStream_rejectConnectedPromise.set(this, () => {});\n    _EventStream_endPromise.set(this, void 0);\n    _EventStream_resolveEndPromise.set(this, () => {});\n    _EventStream_rejectEndPromise.set(this, () => {});\n    _EventStream_listeners.set(this, {});\n    _EventStream_ended.set(this, false);\n    _EventStream_errored.set(this, false);\n    _EventStream_aborted.set(this, false);\n    _EventStream_catchingPromiseCreated.set(this, false);\n    __classPrivateFieldSet(this, _EventStream_connectedPromise, new Promise((resolve, reject) => {\n      __classPrivateFieldSet(this, _EventStream_resolveConnectedPromise, resolve, \"f\");\n      __classPrivateFieldSet(this, _EventStream_rejectConnectedPromise, reject, \"f\");\n    }), \"f\");\n    __classPrivateFieldSet(this, _EventStream_endPromise, new Promise((resolve, reject) => {\n      __classPrivateFieldSet(this, _EventStream_resolveEndPromise, resolve, \"f\");\n      __classPrivateFieldSet(this, _EventStream_rejectEndPromise, reject, \"f\");\n    }), \"f\");\n    // Don't let these promises cause unhandled rejection errors.\n    // we will manually cause an unhandled rejection error later\n    // if the user hasn't registered any error listener or called\n    // any promise-returning method.\n    __classPrivateFieldGet(this, _EventStream_connectedPromise, \"f\").catch(() => {});\n    __classPrivateFieldGet(this, _EventStream_endPromise, \"f\").catch(() => {});\n  }\n  _run(executor) {\n    // Unfortunately if we call `executor()` immediately we get runtime errors about\n    // references to `this` before the `super()` constructor call returns.\n    setTimeout(() => {\n      executor().then(() => {\n        this._emitFinal();\n        this._emit('end');\n      }, __classPrivateFieldGet(this, _EventStream_instances, \"m\", _EventStream_handleError).bind(this));\n    }, 0);\n  }\n  _connected() {\n    if (this.ended) return;\n    __classPrivateFieldGet(this, _EventStream_resolveConnectedPromise, \"f\").call(this);\n    this._emit('connect');\n  }\n  get ended() {\n    return __classPrivateFieldGet(this, _EventStream_ended, \"f\");\n  }\n  get errored() {\n    return __classPrivateFieldGet(this, _EventStream_errored, \"f\");\n  }\n  get aborted() {\n    return __classPrivateFieldGet(this, _EventStream_aborted, \"f\");\n  }\n  abort() {\n    this.controller.abort();\n  }\n  /**\n   * Adds the listener function to the end of the listeners array for the event.\n   * No checks are made to see if the listener has already been added. Multiple calls passing\n   * the same combination of event and listener will result in the listener being added, and\n   * called, multiple times.\n   * @returns this ChatCompletionStream, so that calls can be chained\n   */\n  on(event, listener) {\n    const listeners = __classPrivateFieldGet(this, _EventStream_listeners, \"f\")[event] || (__classPrivateFieldGet(this, _EventStream_listeners, \"f\")[event] = []);\n    listeners.push({\n      listener\n    });\n    return this;\n  }\n  /**\n   * Removes the specified listener from the listener array for the event.\n   * off() will remove, at most, one instance of a listener from the listener array. If any single\n   * listener has been added multiple times to the listener array for the specified event, then\n   * off() must be called multiple times to remove each instance.\n   * @returns this ChatCompletionStream, so that calls can be chained\n   */\n  off(event, listener) {\n    const listeners = __classPrivateFieldGet(this, _EventStream_listeners, \"f\")[event];\n    if (!listeners) return this;\n    const index = listeners.findIndex(l => l.listener === listener);\n    if (index >= 0) listeners.splice(index, 1);\n    return this;\n  }\n  /**\n   * Adds a one-time listener function for the event. The next time the event is triggered,\n   * this listener is removed and then invoked.\n   * @returns this ChatCompletionStream, so that calls can be chained\n   */\n  once(event, listener) {\n    const listeners = __classPrivateFieldGet(this, _EventStream_listeners, \"f\")[event] || (__classPrivateFieldGet(this, _EventStream_listeners, \"f\")[event] = []);\n    listeners.push({\n      listener,\n      once: true\n    });\n    return this;\n  }\n  /**\n   * This is similar to `.once()`, but returns a Promise that resolves the next time\n   * the event is triggered, instead of calling a listener callback.\n   * @returns a Promise that resolves the next time given event is triggered,\n   * or rejects if an error is emitted.  (If you request the 'error' event,\n   * returns a promise that resolves with the error).\n   *\n   * Example:\n   *\n   *   const message = await stream.emitted('message') // rejects if the stream errors\n   */\n  emitted(event) {\n    return new Promise((resolve, reject) => {\n      __classPrivateFieldSet(this, _EventStream_catchingPromiseCreated, true, \"f\");\n      if (event !== 'error') this.once('error', reject);\n      this.once(event, resolve);\n    });\n  }\n  async done() {\n    __classPrivateFieldSet(this, _EventStream_catchingPromiseCreated, true, \"f\");\n    await __classPrivateFieldGet(this, _EventStream_endPromise, \"f\");\n  }\n  _emit(event, ...args) {\n    // make sure we don't emit any events after end\n    if (__classPrivateFieldGet(this, _EventStream_ended, \"f\")) {\n      return;\n    }\n    if (event === 'end') {\n      __classPrivateFieldSet(this, _EventStream_ended, true, \"f\");\n      __classPrivateFieldGet(this, _EventStream_resolveEndPromise, \"f\").call(this);\n    }\n    const listeners = __classPrivateFieldGet(this, _EventStream_listeners, \"f\")[event];\n    if (listeners) {\n      __classPrivateFieldGet(this, _EventStream_listeners, \"f\")[event] = listeners.filter(l => !l.once);\n      listeners.forEach(({\n        listener\n      }) => listener(...args));\n    }\n    if (event === 'abort') {\n      const error = args[0];\n      if (!__classPrivateFieldGet(this, _EventStream_catchingPromiseCreated, \"f\") && !listeners?.length) {\n        Promise.reject(error);\n      }\n      __classPrivateFieldGet(this, _EventStream_rejectConnectedPromise, \"f\").call(this, error);\n      __classPrivateFieldGet(this, _EventStream_rejectEndPromise, \"f\").call(this, error);\n      this._emit('end');\n      return;\n    }\n    if (event === 'error') {\n      // NOTE: _emit('error', error) should only be called from #handleError().\n      const error = args[0];\n      if (!__classPrivateFieldGet(this, _EventStream_catchingPromiseCreated, \"f\") && !listeners?.length) {\n        // Trigger an unhandled rejection if the user hasn't registered any error handlers.\n        // If you are seeing stack traces here, make sure to handle errors via either:\n        // - runner.on('error', () => ...)\n        // - await runner.done()\n        // - await runner.finalChatCompletion()\n        // - etc.\n        Promise.reject(error);\n      }\n      __classPrivateFieldGet(this, _EventStream_rejectConnectedPromise, \"f\").call(this, error);\n      __classPrivateFieldGet(this, _EventStream_rejectEndPromise, \"f\").call(this, error);\n      this._emit('end');\n    }\n  }\n  _emitFinal() {}\n}\n_EventStream_connectedPromise = new WeakMap(), _EventStream_resolveConnectedPromise = new WeakMap(), _EventStream_rejectConnectedPromise = new WeakMap(), _EventStream_endPromise = new WeakMap(), _EventStream_resolveEndPromise = new WeakMap(), _EventStream_rejectEndPromise = new WeakMap(), _EventStream_listeners = new WeakMap(), _EventStream_ended = new WeakMap(), _EventStream_errored = new WeakMap(), _EventStream_aborted = new WeakMap(), _EventStream_catchingPromiseCreated = new WeakMap(), _EventStream_instances = new WeakSet(), _EventStream_handleError = function _EventStream_handleError(error) {\n  __classPrivateFieldSet(this, _EventStream_errored, true, \"f\");\n  if (error instanceof Error && error.name === 'AbortError') {\n    error = new APIUserAbortError();\n  }\n  if (error instanceof APIUserAbortError) {\n    __classPrivateFieldSet(this, _EventStream_aborted, true, \"f\");\n    return this._emit('abort', error);\n  }\n  if (error instanceof OpenAIError) {\n    return this._emit('error', error);\n  }\n  if (error instanceof Error) {\n    const openAIError = new OpenAIError(error.message);\n    // @ts-ignore\n    openAIError.cause = error;\n    return this._emit('error', openAIError);\n  }\n  return this._emit('error', new OpenAIError(String(error)));\n};\n//# sourceMappingURL=EventStream.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}