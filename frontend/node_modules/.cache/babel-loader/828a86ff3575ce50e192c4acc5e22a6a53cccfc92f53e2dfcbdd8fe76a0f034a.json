{"ast":null,"code":"/**\n * @license\n * Copyright 2022 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * Helper class to track network events by request ID\n *\n * @internal\n */\nexport class NetworkEventManager {\n  /**\n   * There are four possible orders of events:\n   * A. `_onRequestWillBeSent`\n   * B. `_onRequestWillBeSent`, `_onRequestPaused`\n   * C. `_onRequestPaused`, `_onRequestWillBeSent`\n   * D. `_onRequestPaused`, `_onRequestWillBeSent`, `_onRequestPaused`,\n   * `_onRequestWillBeSent`, `_onRequestPaused`, `_onRequestPaused`\n   * (see crbug.com/1196004)\n   *\n   * For `_onRequest` we need the event from `_onRequestWillBeSent` and\n   * optionally the `interceptionId` from `_onRequestPaused`.\n   *\n   * If request interception is disabled, call `_onRequest` once per call to\n   * `_onRequestWillBeSent`.\n   * If request interception is enabled, call `_onRequest` once per call to\n   * `_onRequestPaused` (once per `interceptionId`).\n   *\n   * Events are stored to allow for subsequent events to call `_onRequest`.\n   *\n   * Note that (chains of) redirect requests have the same `requestId` (!) as\n   * the original request. We have to anticipate series of events like these:\n   * A. `_onRequestWillBeSent`,\n   * `_onRequestWillBeSent`, ...\n   * B. `_onRequestWillBeSent`, `_onRequestPaused`,\n   * `_onRequestWillBeSent`, `_onRequestPaused`, ...\n   * C. `_onRequestWillBeSent`, `_onRequestPaused`,\n   * `_onRequestPaused`, `_onRequestWillBeSent`, ...\n   * D. `_onRequestPaused`, `_onRequestWillBeSent`,\n   * `_onRequestPaused`, `_onRequestWillBeSent`, `_onRequestPaused`,\n   * `_onRequestWillBeSent`, `_onRequestPaused`, `_onRequestPaused`, ...\n   * (see crbug.com/1196004)\n   */\n  #requestWillBeSentMap = new Map();\n  #requestPausedMap = new Map();\n  #httpRequestsMap = new Map();\n  /*\n   * The below maps are used to reconcile Network.responseReceivedExtraInfo\n   * events with their corresponding request. Each response and redirect\n   * response gets an ExtraInfo event, and we don't know which will come first.\n   * This means that we have to store a Response or an ExtraInfo for each\n   * response, and emit the event when we get both of them. In addition, to\n   * handle redirects, we have to make them Arrays to represent the chain of\n   * events.\n   */\n  #responseReceivedExtraInfoMap = new Map();\n  #queuedRedirectInfoMap = new Map();\n  #queuedEventGroupMap = new Map();\n  forget(networkRequestId) {\n    this.#requestWillBeSentMap.delete(networkRequestId);\n    this.#requestPausedMap.delete(networkRequestId);\n    this.#queuedEventGroupMap.delete(networkRequestId);\n    this.#queuedRedirectInfoMap.delete(networkRequestId);\n    this.#responseReceivedExtraInfoMap.delete(networkRequestId);\n  }\n  responseExtraInfo(networkRequestId) {\n    if (!this.#responseReceivedExtraInfoMap.has(networkRequestId)) {\n      this.#responseReceivedExtraInfoMap.set(networkRequestId, []);\n    }\n    return this.#responseReceivedExtraInfoMap.get(networkRequestId);\n  }\n  queuedRedirectInfo(fetchRequestId) {\n    if (!this.#queuedRedirectInfoMap.has(fetchRequestId)) {\n      this.#queuedRedirectInfoMap.set(fetchRequestId, []);\n    }\n    return this.#queuedRedirectInfoMap.get(fetchRequestId);\n  }\n  queueRedirectInfo(fetchRequestId, redirectInfo) {\n    this.queuedRedirectInfo(fetchRequestId).push(redirectInfo);\n  }\n  takeQueuedRedirectInfo(fetchRequestId) {\n    return this.queuedRedirectInfo(fetchRequestId).shift();\n  }\n  inFlightRequestsCount() {\n    let inFlightRequestCounter = 0;\n    for (const request of this.#httpRequestsMap.values()) {\n      if (!request.response()) {\n        inFlightRequestCounter++;\n      }\n    }\n    return inFlightRequestCounter;\n  }\n  storeRequestWillBeSent(networkRequestId, event) {\n    this.#requestWillBeSentMap.set(networkRequestId, event);\n  }\n  getRequestWillBeSent(networkRequestId) {\n    return this.#requestWillBeSentMap.get(networkRequestId);\n  }\n  forgetRequestWillBeSent(networkRequestId) {\n    this.#requestWillBeSentMap.delete(networkRequestId);\n  }\n  getRequestPaused(networkRequestId) {\n    return this.#requestPausedMap.get(networkRequestId);\n  }\n  forgetRequestPaused(networkRequestId) {\n    this.#requestPausedMap.delete(networkRequestId);\n  }\n  storeRequestPaused(networkRequestId, event) {\n    this.#requestPausedMap.set(networkRequestId, event);\n  }\n  getRequest(networkRequestId) {\n    return this.#httpRequestsMap.get(networkRequestId);\n  }\n  storeRequest(networkRequestId, request) {\n    this.#httpRequestsMap.set(networkRequestId, request);\n  }\n  forgetRequest(networkRequestId) {\n    this.#httpRequestsMap.delete(networkRequestId);\n  }\n  getQueuedEventGroup(networkRequestId) {\n    return this.#queuedEventGroupMap.get(networkRequestId);\n  }\n  queueEventGroup(networkRequestId, event) {\n    this.#queuedEventGroupMap.set(networkRequestId, event);\n  }\n  forgetQueuedEventGroup(networkRequestId) {\n    this.#queuedEventGroupMap.delete(networkRequestId);\n  }\n}","map":{"version":3,"names":["NetworkEventManager","requestWillBeSentMap","Map","requestPausedMap","httpRequestsMap","responseReceivedExtraInfoMap","queuedRedirectInfoMap","queuedEventGroupMap","forget","networkRequestId","delete","responseExtraInfo","has","set","get","queuedRedirectInfo","fetchRequestId","queueRedirectInfo","redirectInfo","push","takeQueuedRedirectInfo","shift","inFlightRequestsCount","inFlightRequestCounter","request","values","response","storeRequestWillBeSent","event","getRequestWillBeSent","forgetRequestWillBeSent","getRequestPaused","forgetRequestPaused","storeRequestPaused","getRequest","storeRequest","forgetRequest","getQueuedEventGroup","queueEventGroup","forgetQueuedEventGroup"],"sources":["C:\\Users\\raffy\\Desktop\\test\\node_modules\\puppeteer-core\\src\\cdp\\NetworkEventManager.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2022 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport type {Protocol} from 'devtools-protocol';\n\nimport type {CdpHTTPRequest} from './HTTPRequest.js';\n\n/**\n * @internal\n */\nexport interface QueuedEventGroup {\n  responseReceivedEvent: Protocol.Network.ResponseReceivedEvent;\n  loadingFinishedEvent?: Protocol.Network.LoadingFinishedEvent;\n  loadingFailedEvent?: Protocol.Network.LoadingFailedEvent;\n}\n\n/**\n * @internal\n */\nexport type FetchRequestId = string;\n\n/**\n * @internal\n */\nexport interface RedirectInfo {\n  event: Protocol.Network.RequestWillBeSentEvent;\n  fetchRequestId?: FetchRequestId;\n}\ntype RedirectInfoList = RedirectInfo[];\n\n/**\n * @internal\n */\nexport type NetworkRequestId = string;\n\n/**\n * Helper class to track network events by request ID\n *\n * @internal\n */\nexport class NetworkEventManager {\n  /**\n   * There are four possible orders of events:\n   * A. `_onRequestWillBeSent`\n   * B. `_onRequestWillBeSent`, `_onRequestPaused`\n   * C. `_onRequestPaused`, `_onRequestWillBeSent`\n   * D. `_onRequestPaused`, `_onRequestWillBeSent`, `_onRequestPaused`,\n   * `_onRequestWillBeSent`, `_onRequestPaused`, `_onRequestPaused`\n   * (see crbug.com/1196004)\n   *\n   * For `_onRequest` we need the event from `_onRequestWillBeSent` and\n   * optionally the `interceptionId` from `_onRequestPaused`.\n   *\n   * If request interception is disabled, call `_onRequest` once per call to\n   * `_onRequestWillBeSent`.\n   * If request interception is enabled, call `_onRequest` once per call to\n   * `_onRequestPaused` (once per `interceptionId`).\n   *\n   * Events are stored to allow for subsequent events to call `_onRequest`.\n   *\n   * Note that (chains of) redirect requests have the same `requestId` (!) as\n   * the original request. We have to anticipate series of events like these:\n   * A. `_onRequestWillBeSent`,\n   * `_onRequestWillBeSent`, ...\n   * B. `_onRequestWillBeSent`, `_onRequestPaused`,\n   * `_onRequestWillBeSent`, `_onRequestPaused`, ...\n   * C. `_onRequestWillBeSent`, `_onRequestPaused`,\n   * `_onRequestPaused`, `_onRequestWillBeSent`, ...\n   * D. `_onRequestPaused`, `_onRequestWillBeSent`,\n   * `_onRequestPaused`, `_onRequestWillBeSent`, `_onRequestPaused`,\n   * `_onRequestWillBeSent`, `_onRequestPaused`, `_onRequestPaused`, ...\n   * (see crbug.com/1196004)\n   */\n  #requestWillBeSentMap = new Map<\n    NetworkRequestId,\n    Protocol.Network.RequestWillBeSentEvent\n  >();\n  #requestPausedMap = new Map<\n    NetworkRequestId,\n    Protocol.Fetch.RequestPausedEvent\n  >();\n  #httpRequestsMap = new Map<NetworkRequestId, CdpHTTPRequest>();\n\n  /*\n   * The below maps are used to reconcile Network.responseReceivedExtraInfo\n   * events with their corresponding request. Each response and redirect\n   * response gets an ExtraInfo event, and we don't know which will come first.\n   * This means that we have to store a Response or an ExtraInfo for each\n   * response, and emit the event when we get both of them. In addition, to\n   * handle redirects, we have to make them Arrays to represent the chain of\n   * events.\n   */\n  #responseReceivedExtraInfoMap = new Map<\n    NetworkRequestId,\n    Protocol.Network.ResponseReceivedExtraInfoEvent[]\n  >();\n  #queuedRedirectInfoMap = new Map<NetworkRequestId, RedirectInfoList>();\n  #queuedEventGroupMap = new Map<NetworkRequestId, QueuedEventGroup>();\n\n  forget(networkRequestId: NetworkRequestId): void {\n    this.#requestWillBeSentMap.delete(networkRequestId);\n    this.#requestPausedMap.delete(networkRequestId);\n    this.#queuedEventGroupMap.delete(networkRequestId);\n    this.#queuedRedirectInfoMap.delete(networkRequestId);\n    this.#responseReceivedExtraInfoMap.delete(networkRequestId);\n  }\n\n  responseExtraInfo(\n    networkRequestId: NetworkRequestId\n  ): Protocol.Network.ResponseReceivedExtraInfoEvent[] {\n    if (!this.#responseReceivedExtraInfoMap.has(networkRequestId)) {\n      this.#responseReceivedExtraInfoMap.set(networkRequestId, []);\n    }\n    return this.#responseReceivedExtraInfoMap.get(\n      networkRequestId\n    ) as Protocol.Network.ResponseReceivedExtraInfoEvent[];\n  }\n\n  private queuedRedirectInfo(fetchRequestId: FetchRequestId): RedirectInfoList {\n    if (!this.#queuedRedirectInfoMap.has(fetchRequestId)) {\n      this.#queuedRedirectInfoMap.set(fetchRequestId, []);\n    }\n    return this.#queuedRedirectInfoMap.get(fetchRequestId) as RedirectInfoList;\n  }\n\n  queueRedirectInfo(\n    fetchRequestId: FetchRequestId,\n    redirectInfo: RedirectInfo\n  ): void {\n    this.queuedRedirectInfo(fetchRequestId).push(redirectInfo);\n  }\n\n  takeQueuedRedirectInfo(\n    fetchRequestId: FetchRequestId\n  ): RedirectInfo | undefined {\n    return this.queuedRedirectInfo(fetchRequestId).shift();\n  }\n\n  inFlightRequestsCount(): number {\n    let inFlightRequestCounter = 0;\n    for (const request of this.#httpRequestsMap.values()) {\n      if (!request.response()) {\n        inFlightRequestCounter++;\n      }\n    }\n    return inFlightRequestCounter;\n  }\n\n  storeRequestWillBeSent(\n    networkRequestId: NetworkRequestId,\n    event: Protocol.Network.RequestWillBeSentEvent\n  ): void {\n    this.#requestWillBeSentMap.set(networkRequestId, event);\n  }\n\n  getRequestWillBeSent(\n    networkRequestId: NetworkRequestId\n  ): Protocol.Network.RequestWillBeSentEvent | undefined {\n    return this.#requestWillBeSentMap.get(networkRequestId);\n  }\n\n  forgetRequestWillBeSent(networkRequestId: NetworkRequestId): void {\n    this.#requestWillBeSentMap.delete(networkRequestId);\n  }\n\n  getRequestPaused(\n    networkRequestId: NetworkRequestId\n  ): Protocol.Fetch.RequestPausedEvent | undefined {\n    return this.#requestPausedMap.get(networkRequestId);\n  }\n\n  forgetRequestPaused(networkRequestId: NetworkRequestId): void {\n    this.#requestPausedMap.delete(networkRequestId);\n  }\n\n  storeRequestPaused(\n    networkRequestId: NetworkRequestId,\n    event: Protocol.Fetch.RequestPausedEvent\n  ): void {\n    this.#requestPausedMap.set(networkRequestId, event);\n  }\n\n  getRequest(networkRequestId: NetworkRequestId): CdpHTTPRequest | undefined {\n    return this.#httpRequestsMap.get(networkRequestId);\n  }\n\n  storeRequest(\n    networkRequestId: NetworkRequestId,\n    request: CdpHTTPRequest\n  ): void {\n    this.#httpRequestsMap.set(networkRequestId, request);\n  }\n\n  forgetRequest(networkRequestId: NetworkRequestId): void {\n    this.#httpRequestsMap.delete(networkRequestId);\n  }\n\n  getQueuedEventGroup(\n    networkRequestId: NetworkRequestId\n  ): QueuedEventGroup | undefined {\n    return this.#queuedEventGroupMap.get(networkRequestId);\n  }\n\n  queueEventGroup(\n    networkRequestId: NetworkRequestId,\n    event: QueuedEventGroup\n  ): void {\n    this.#queuedEventGroupMap.set(networkRequestId, event);\n  }\n\n  forgetQueuedEventGroup(networkRequestId: NetworkRequestId): void {\n    this.#queuedEventGroupMap.delete(networkRequestId);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}