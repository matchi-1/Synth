{"ast":null,"code":"import { ContentFilterFinishReasonError, LengthFinishReasonError, OpenAIError } from 'openai/error';\nexport function makeParseableResponseFormat(response_format, parser) {\n  const obj = {\n    ...response_format\n  };\n  Object.defineProperties(obj, {\n    $brand: {\n      value: 'auto-parseable-response-format',\n      enumerable: false\n    },\n    $parseRaw: {\n      value: parser,\n      enumerable: false\n    }\n  });\n  return obj;\n}\nexport function isAutoParsableResponseFormat(response_format) {\n  return response_format?.['$brand'] === 'auto-parseable-response-format';\n}\nexport function makeParseableTool(tool, {\n  parser,\n  callback\n}) {\n  const obj = {\n    ...tool\n  };\n  Object.defineProperties(obj, {\n    $brand: {\n      value: 'auto-parseable-tool',\n      enumerable: false\n    },\n    $parseRaw: {\n      value: parser,\n      enumerable: false\n    },\n    $callback: {\n      value: callback,\n      enumerable: false\n    }\n  });\n  return obj;\n}\nexport function isAutoParsableTool(tool) {\n  return tool?.['$brand'] === 'auto-parseable-tool';\n}\nexport function maybeParseChatCompletion(completion, params) {\n  if (!params || !hasAutoParseableInput(params)) {\n    return {\n      ...completion,\n      choices: completion.choices.map(choice => ({\n        ...choice,\n        message: {\n          ...choice.message,\n          parsed: null,\n          tool_calls: choice.message.tool_calls ?? []\n        }\n      }))\n    };\n  }\n  return parseChatCompletion(completion, params);\n}\nexport function parseChatCompletion(completion, params) {\n  const choices = completion.choices.map(choice => {\n    if (choice.finish_reason === 'length') {\n      throw new LengthFinishReasonError();\n    }\n    if (choice.finish_reason === 'content_filter') {\n      throw new ContentFilterFinishReasonError();\n    }\n    return {\n      ...choice,\n      message: {\n        ...choice.message,\n        tool_calls: choice.message.tool_calls?.map(toolCall => parseToolCall(params, toolCall)) ?? [],\n        parsed: choice.message.content && !choice.message.refusal ? parseResponseFormat(params, choice.message.content) : null\n      }\n    };\n  });\n  return {\n    ...completion,\n    choices\n  };\n}\nfunction parseResponseFormat(params, content) {\n  if (params.response_format?.type !== 'json_schema') {\n    return null;\n  }\n  if (params.response_format?.type === 'json_schema') {\n    if ('$parseRaw' in params.response_format) {\n      const response_format = params.response_format;\n      return response_format.$parseRaw(content);\n    }\n    return JSON.parse(content);\n  }\n  return null;\n}\nfunction parseToolCall(params, toolCall) {\n  const inputTool = params.tools?.find(inputTool => inputTool.function?.name === toolCall.function.name);\n  return {\n    ...toolCall,\n    function: {\n      ...toolCall.function,\n      parsed_arguments: isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCall.function.arguments) : inputTool?.function.strict ? JSON.parse(toolCall.function.arguments) : null\n    }\n  };\n}\nexport function shouldParseToolCall(params, toolCall) {\n  if (!params) {\n    return false;\n  }\n  const inputTool = params.tools?.find(inputTool => inputTool.function?.name === toolCall.function.name);\n  return isAutoParsableTool(inputTool) || inputTool?.function.strict || false;\n}\nexport function hasAutoParseableInput(params) {\n  if (isAutoParsableResponseFormat(params.response_format)) {\n    return true;\n  }\n  return params.tools?.some(t => isAutoParsableTool(t) || t.type === 'function' && t.function.strict === true) ?? false;\n}\nexport function validateInputTools(tools) {\n  for (const tool of tools ?? []) {\n    if (tool.type !== 'function') {\n      throw new OpenAIError(`Currently only \\`function\\` tool types support auto-parsing; Received \\`${tool.type}\\``);\n    }\n    if (tool.function.strict !== true) {\n      throw new OpenAIError(`The \\`${tool.function.name}\\` tool is not marked with \\`strict: true\\`. Only strict function tools can be auto-parsed`);\n    }\n  }\n}\n//# sourceMappingURL=parser.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}