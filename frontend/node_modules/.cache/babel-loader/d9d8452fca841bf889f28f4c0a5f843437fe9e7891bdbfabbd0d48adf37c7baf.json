{"ast":null,"code":"/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactDefaultPerfAnalysis\n */\n\nvar assign = require(\"./Object.assign\");\n\n// Don't try to save users less than 1.2ms (a number I made up)\nvar DONT_CARE_THRESHOLD = 1.2;\nvar DOM_OPERATION_TYPES = {\n  '_mountImageIntoNode': 'set innerHTML',\n  INSERT_MARKUP: 'set innerHTML',\n  MOVE_EXISTING: 'move',\n  REMOVE_NODE: 'remove',\n  TEXT_CONTENT: 'set textContent',\n  'updatePropertyByID': 'update attribute',\n  'deletePropertyByID': 'delete attribute',\n  'updateStylesByID': 'update styles',\n  'updateInnerHTMLByID': 'set innerHTML',\n  'dangerouslyReplaceNodeWithMarkupByID': 'replace'\n};\nfunction getTotalTime(measurements) {\n  // TODO: return number of DOM ops? could be misleading.\n  // TODO: measure dropped frames after reconcile?\n  // TODO: log total time of each reconcile and the top-level component\n  // class that triggered it.\n  var totalTime = 0;\n  for (var i = 0; i < measurements.length; i++) {\n    var measurement = measurements[i];\n    totalTime += measurement.totalTime;\n  }\n  return totalTime;\n}\nfunction getDOMSummary(measurements) {\n  var items = [];\n  for (var i = 0; i < measurements.length; i++) {\n    var measurement = measurements[i];\n    var id;\n    for (id in measurement.writes) {\n      measurement.writes[id].forEach(function (write) {\n        items.push({\n          id: id,\n          type: DOM_OPERATION_TYPES[write.type] || write.type,\n          args: write.args\n        });\n      });\n    }\n  }\n  return items;\n}\nfunction getExclusiveSummary(measurements) {\n  var candidates = {};\n  var displayName;\n  for (var i = 0; i < measurements.length; i++) {\n    var measurement = measurements[i];\n    var allIDs = assign({}, measurement.exclusive, measurement.inclusive);\n    for (var id in allIDs) {\n      displayName = measurement.displayNames[id].current;\n      candidates[displayName] = candidates[displayName] || {\n        componentName: displayName,\n        inclusive: 0,\n        exclusive: 0,\n        render: 0,\n        count: 0\n      };\n      if (measurement.render[id]) {\n        candidates[displayName].render += measurement.render[id];\n      }\n      if (measurement.exclusive[id]) {\n        candidates[displayName].exclusive += measurement.exclusive[id];\n      }\n      if (measurement.inclusive[id]) {\n        candidates[displayName].inclusive += measurement.inclusive[id];\n      }\n      if (measurement.counts[id]) {\n        candidates[displayName].count += measurement.counts[id];\n      }\n    }\n  }\n\n  // Now make a sorted array with the results.\n  var arr = [];\n  for (displayName in candidates) {\n    if (candidates[displayName].exclusive >= DONT_CARE_THRESHOLD) {\n      arr.push(candidates[displayName]);\n    }\n  }\n  arr.sort(function (a, b) {\n    return b.exclusive - a.exclusive;\n  });\n  return arr;\n}\nfunction getInclusiveSummary(measurements, onlyClean) {\n  var candidates = {};\n  var inclusiveKey;\n  for (var i = 0; i < measurements.length; i++) {\n    var measurement = measurements[i];\n    var allIDs = assign({}, measurement.exclusive, measurement.inclusive);\n    var cleanComponents;\n    if (onlyClean) {\n      cleanComponents = getUnchangedComponents(measurement);\n    }\n    for (var id in allIDs) {\n      if (onlyClean && !cleanComponents[id]) {\n        continue;\n      }\n      var displayName = measurement.displayNames[id];\n\n      // Inclusive time is not useful for many components without knowing where\n      // they are instantiated. So we aggregate inclusive time with both the\n      // owner and current displayName as the key.\n      inclusiveKey = displayName.owner + ' > ' + displayName.current;\n      candidates[inclusiveKey] = candidates[inclusiveKey] || {\n        componentName: inclusiveKey,\n        time: 0,\n        count: 0\n      };\n      if (measurement.inclusive[id]) {\n        candidates[inclusiveKey].time += measurement.inclusive[id];\n      }\n      if (measurement.counts[id]) {\n        candidates[inclusiveKey].count += measurement.counts[id];\n      }\n    }\n  }\n\n  // Now make a sorted array with the results.\n  var arr = [];\n  for (inclusiveKey in candidates) {\n    if (candidates[inclusiveKey].time >= DONT_CARE_THRESHOLD) {\n      arr.push(candidates[inclusiveKey]);\n    }\n  }\n  arr.sort(function (a, b) {\n    return b.time - a.time;\n  });\n  return arr;\n}\nfunction getUnchangedComponents(measurement) {\n  // For a given reconcile, look at which components did not actually\n  // render anything to the DOM and return a mapping of their ID to\n  // the amount of time it took to render the entire subtree.\n  var cleanComponents = {};\n  var dirtyLeafIDs = Object.keys(measurement.writes);\n  var allIDs = assign({}, measurement.exclusive, measurement.inclusive);\n  for (var id in allIDs) {\n    var isDirty = false;\n    // For each component that rendered, see if a component that triggered\n    // a DOM op is in its subtree.\n    for (var i = 0; i < dirtyLeafIDs.length; i++) {\n      if (dirtyLeafIDs[i].indexOf(id) === 0) {\n        isDirty = true;\n        break;\n      }\n    }\n    if (!isDirty && measurement.counts[id] > 0) {\n      cleanComponents[id] = true;\n    }\n  }\n  return cleanComponents;\n}\nvar ReactDefaultPerfAnalysis = {\n  getExclusiveSummary: getExclusiveSummary,\n  getInclusiveSummary: getInclusiveSummary,\n  getDOMSummary: getDOMSummary,\n  getTotalTime: getTotalTime\n};\nmodule.exports = ReactDefaultPerfAnalysis;","map":{"version":3,"names":["assign","require","DONT_CARE_THRESHOLD","DOM_OPERATION_TYPES","INSERT_MARKUP","MOVE_EXISTING","REMOVE_NODE","TEXT_CONTENT","getTotalTime","measurements","totalTime","i","length","measurement","getDOMSummary","items","id","writes","forEach","write","push","type","args","getExclusiveSummary","candidates","displayName","allIDs","exclusive","inclusive","displayNames","current","componentName","render","count","counts","arr","sort","a","b","getInclusiveSummary","onlyClean","inclusiveKey","cleanComponents","getUnchangedComponents","owner","time","dirtyLeafIDs","Object","keys","isDirty","indexOf","ReactDefaultPerfAnalysis","module","exports"],"sources":["C:/Users/raffy/Desktop/test/Synth/Synth/node_modules/react-embedded-browser/node_modules/react/lib/ReactDefaultPerfAnalysis.js"],"sourcesContent":["/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactDefaultPerfAnalysis\n */\n\nvar assign = require(\"./Object.assign\");\n\n// Don't try to save users less than 1.2ms (a number I made up)\nvar DONT_CARE_THRESHOLD = 1.2;\nvar DOM_OPERATION_TYPES = {\n  '_mountImageIntoNode': 'set innerHTML',\n  INSERT_MARKUP: 'set innerHTML',\n  MOVE_EXISTING: 'move',\n  REMOVE_NODE: 'remove',\n  TEXT_CONTENT: 'set textContent',\n  'updatePropertyByID': 'update attribute',\n  'deletePropertyByID': 'delete attribute',\n  'updateStylesByID': 'update styles',\n  'updateInnerHTMLByID': 'set innerHTML',\n  'dangerouslyReplaceNodeWithMarkupByID': 'replace'\n};\n\nfunction getTotalTime(measurements) {\n  // TODO: return number of DOM ops? could be misleading.\n  // TODO: measure dropped frames after reconcile?\n  // TODO: log total time of each reconcile and the top-level component\n  // class that triggered it.\n  var totalTime = 0;\n  for (var i = 0; i < measurements.length; i++) {\n    var measurement = measurements[i];\n    totalTime += measurement.totalTime;\n  }\n  return totalTime;\n}\n\nfunction getDOMSummary(measurements) {\n  var items = [];\n  for (var i = 0; i < measurements.length; i++) {\n    var measurement = measurements[i];\n    var id;\n\n    for (id in measurement.writes) {\n      measurement.writes[id].forEach(function(write) {\n        items.push({\n          id: id,\n          type: DOM_OPERATION_TYPES[write.type] || write.type,\n          args: write.args\n        });\n      });\n    }\n  }\n  return items;\n}\n\nfunction getExclusiveSummary(measurements) {\n  var candidates = {};\n  var displayName;\n\n  for (var i = 0; i < measurements.length; i++) {\n    var measurement = measurements[i];\n    var allIDs = assign(\n      {},\n      measurement.exclusive,\n      measurement.inclusive\n    );\n\n    for (var id in allIDs) {\n      displayName = measurement.displayNames[id].current;\n\n      candidates[displayName] = candidates[displayName] || {\n        componentName: displayName,\n        inclusive: 0,\n        exclusive: 0,\n        render: 0,\n        count: 0\n      };\n      if (measurement.render[id]) {\n        candidates[displayName].render += measurement.render[id];\n      }\n      if (measurement.exclusive[id]) {\n        candidates[displayName].exclusive += measurement.exclusive[id];\n      }\n      if (measurement.inclusive[id]) {\n        candidates[displayName].inclusive += measurement.inclusive[id];\n      }\n      if (measurement.counts[id]) {\n        candidates[displayName].count += measurement.counts[id];\n      }\n    }\n  }\n\n  // Now make a sorted array with the results.\n  var arr = [];\n  for (displayName in candidates) {\n    if (candidates[displayName].exclusive >= DONT_CARE_THRESHOLD) {\n      arr.push(candidates[displayName]);\n    }\n  }\n\n  arr.sort(function(a, b) {\n    return b.exclusive - a.exclusive;\n  });\n\n  return arr;\n}\n\nfunction getInclusiveSummary(measurements, onlyClean) {\n  var candidates = {};\n  var inclusiveKey;\n\n  for (var i = 0; i < measurements.length; i++) {\n    var measurement = measurements[i];\n    var allIDs = assign(\n      {},\n      measurement.exclusive,\n      measurement.inclusive\n    );\n    var cleanComponents;\n\n    if (onlyClean) {\n      cleanComponents = getUnchangedComponents(measurement);\n    }\n\n    for (var id in allIDs) {\n      if (onlyClean && !cleanComponents[id]) {\n        continue;\n      }\n\n      var displayName = measurement.displayNames[id];\n\n      // Inclusive time is not useful for many components without knowing where\n      // they are instantiated. So we aggregate inclusive time with both the\n      // owner and current displayName as the key.\n      inclusiveKey = displayName.owner + ' > ' + displayName.current;\n\n      candidates[inclusiveKey] = candidates[inclusiveKey] || {\n        componentName: inclusiveKey,\n        time: 0,\n        count: 0\n      };\n\n      if (measurement.inclusive[id]) {\n        candidates[inclusiveKey].time += measurement.inclusive[id];\n      }\n      if (measurement.counts[id]) {\n        candidates[inclusiveKey].count += measurement.counts[id];\n      }\n    }\n  }\n\n  // Now make a sorted array with the results.\n  var arr = [];\n  for (inclusiveKey in candidates) {\n    if (candidates[inclusiveKey].time >= DONT_CARE_THRESHOLD) {\n      arr.push(candidates[inclusiveKey]);\n    }\n  }\n\n  arr.sort(function(a, b) {\n    return b.time - a.time;\n  });\n\n  return arr;\n}\n\nfunction getUnchangedComponents(measurement) {\n  // For a given reconcile, look at which components did not actually\n  // render anything to the DOM and return a mapping of their ID to\n  // the amount of time it took to render the entire subtree.\n  var cleanComponents = {};\n  var dirtyLeafIDs = Object.keys(measurement.writes);\n  var allIDs = assign({}, measurement.exclusive, measurement.inclusive);\n\n  for (var id in allIDs) {\n    var isDirty = false;\n    // For each component that rendered, see if a component that triggered\n    // a DOM op is in its subtree.\n    for (var i = 0; i < dirtyLeafIDs.length; i++) {\n      if (dirtyLeafIDs[i].indexOf(id) === 0) {\n        isDirty = true;\n        break;\n      }\n    }\n    if (!isDirty && measurement.counts[id] > 0) {\n      cleanComponents[id] = true;\n    }\n  }\n  return cleanComponents;\n}\n\nvar ReactDefaultPerfAnalysis = {\n  getExclusiveSummary: getExclusiveSummary,\n  getInclusiveSummary: getInclusiveSummary,\n  getDOMSummary: getDOMSummary,\n  getTotalTime: getTotalTime\n};\n\nmodule.exports = ReactDefaultPerfAnalysis;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}