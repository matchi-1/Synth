{"ast":null,"code":"//Const\nconst NOAH_ARK_CAPACITY = 3;\nexport var EntryType;\n(function (EntryType) {\n  EntryType[EntryType[\"Marker\"] = 0] = \"Marker\";\n  EntryType[EntryType[\"Element\"] = 1] = \"Element\";\n})(EntryType = EntryType || (EntryType = {}));\nconst MARKER = {\n  type: EntryType.Marker\n};\n//List of formatting elements\nexport class FormattingElementList {\n  constructor(treeAdapter) {\n    this.treeAdapter = treeAdapter;\n    this.entries = [];\n    this.bookmark = null;\n  }\n  //Noah Ark's condition\n  //OPTIMIZATION: at first we try to find possible candidates for exclusion using\n  //lightweight heuristics without thorough attributes check.\n  _getNoahArkConditionCandidates(newElement, neAttrs) {\n    const candidates = [];\n    const neAttrsLength = neAttrs.length;\n    const neTagName = this.treeAdapter.getTagName(newElement);\n    const neNamespaceURI = this.treeAdapter.getNamespaceURI(newElement);\n    for (let i = 0; i < this.entries.length; i++) {\n      const entry = this.entries[i];\n      if (entry.type === EntryType.Marker) {\n        break;\n      }\n      const {\n        element\n      } = entry;\n      if (this.treeAdapter.getTagName(element) === neTagName && this.treeAdapter.getNamespaceURI(element) === neNamespaceURI) {\n        const elementAttrs = this.treeAdapter.getAttrList(element);\n        if (elementAttrs.length === neAttrsLength) {\n          candidates.push({\n            idx: i,\n            attrs: elementAttrs\n          });\n        }\n      }\n    }\n    return candidates;\n  }\n  _ensureNoahArkCondition(newElement) {\n    if (this.entries.length < NOAH_ARK_CAPACITY) return;\n    const neAttrs = this.treeAdapter.getAttrList(newElement);\n    const candidates = this._getNoahArkConditionCandidates(newElement, neAttrs);\n    if (candidates.length < NOAH_ARK_CAPACITY) return;\n    //NOTE: build attrs map for the new element, so we can perform fast lookups\n    const neAttrsMap = new Map(neAttrs.map(neAttr => [neAttr.name, neAttr.value]));\n    let validCandidates = 0;\n    //NOTE: remove bottommost candidates, until Noah's Ark condition will not be met\n    for (let i = 0; i < candidates.length; i++) {\n      const candidate = candidates[i];\n      // We know that `candidate.attrs.length === neAttrs.length`\n      if (candidate.attrs.every(cAttr => neAttrsMap.get(cAttr.name) === cAttr.value)) {\n        validCandidates += 1;\n        if (validCandidates >= NOAH_ARK_CAPACITY) {\n          this.entries.splice(candidate.idx, 1);\n        }\n      }\n    }\n  }\n  //Mutations\n  insertMarker() {\n    this.entries.unshift(MARKER);\n  }\n  pushElement(element, token) {\n    this._ensureNoahArkCondition(element);\n    this.entries.unshift({\n      type: EntryType.Element,\n      element,\n      token\n    });\n  }\n  insertElementAfterBookmark(element, token) {\n    const bookmarkIdx = this.entries.indexOf(this.bookmark);\n    this.entries.splice(bookmarkIdx, 0, {\n      type: EntryType.Element,\n      element,\n      token\n    });\n  }\n  removeEntry(entry) {\n    const entryIndex = this.entries.indexOf(entry);\n    if (entryIndex >= 0) {\n      this.entries.splice(entryIndex, 1);\n    }\n  }\n  /**\n   * Clears the list of formatting elements up to the last marker.\n   *\n   * @see https://html.spec.whatwg.org/multipage/parsing.html#clear-the-list-of-active-formatting-elements-up-to-the-last-marker\n   */\n  clearToLastMarker() {\n    const markerIdx = this.entries.indexOf(MARKER);\n    if (markerIdx >= 0) {\n      this.entries.splice(0, markerIdx + 1);\n    } else {\n      this.entries.length = 0;\n    }\n  }\n  //Search\n  getElementEntryInScopeWithTagName(tagName) {\n    const entry = this.entries.find(entry => entry.type === EntryType.Marker || this.treeAdapter.getTagName(entry.element) === tagName);\n    return entry && entry.type === EntryType.Element ? entry : null;\n  }\n  getElementEntry(element) {\n    return this.entries.find(entry => entry.type === EntryType.Element && entry.element === element);\n  }\n}\n//# sourceMappingURL=formatting-element-list.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}