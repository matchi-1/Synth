{"ast":null,"code":"const tokenize = input => {\n    let current = 0;\n    let tokens = [];\n    while (current < input.length) {\n      let char = input[current];\n      if (char === '\\\\') {\n        current++;\n        continue;\n      }\n      if (char === '{') {\n        tokens.push({\n          type: 'brace',\n          value: '{'\n        });\n        current++;\n        continue;\n      }\n      if (char === '}') {\n        tokens.push({\n          type: 'brace',\n          value: '}'\n        });\n        current++;\n        continue;\n      }\n      if (char === '[') {\n        tokens.push({\n          type: 'paren',\n          value: '['\n        });\n        current++;\n        continue;\n      }\n      if (char === ']') {\n        tokens.push({\n          type: 'paren',\n          value: ']'\n        });\n        current++;\n        continue;\n      }\n      if (char === ':') {\n        tokens.push({\n          type: 'separator',\n          value: ':'\n        });\n        current++;\n        continue;\n      }\n      if (char === ',') {\n        tokens.push({\n          type: 'delimiter',\n          value: ','\n        });\n        current++;\n        continue;\n      }\n      if (char === '\"') {\n        let value = '';\n        let danglingQuote = false;\n        char = input[++current];\n        while (char !== '\"') {\n          if (current === input.length) {\n            danglingQuote = true;\n            break;\n          }\n          if (char === '\\\\') {\n            current++;\n            if (current === input.length) {\n              danglingQuote = true;\n              break;\n            }\n            value += char + input[current];\n            char = input[++current];\n          } else {\n            value += char;\n            char = input[++current];\n          }\n        }\n        char = input[++current];\n        if (!danglingQuote) {\n          tokens.push({\n            type: 'string',\n            value\n          });\n        }\n        continue;\n      }\n      let WHITESPACE = /\\s/;\n      if (char && WHITESPACE.test(char)) {\n        current++;\n        continue;\n      }\n      let NUMBERS = /[0-9]/;\n      if (char && NUMBERS.test(char) || char === '-' || char === '.') {\n        let value = '';\n        if (char === '-') {\n          value += char;\n          char = input[++current];\n        }\n        while (char && NUMBERS.test(char) || char === '.') {\n          value += char;\n          char = input[++current];\n        }\n        tokens.push({\n          type: 'number',\n          value\n        });\n        continue;\n      }\n      let LETTERS = /[a-z]/i;\n      if (char && LETTERS.test(char)) {\n        let value = '';\n        while (char && LETTERS.test(char)) {\n          if (current === input.length) {\n            break;\n          }\n          value += char;\n          char = input[++current];\n        }\n        if (value == 'true' || value == 'false' || value === 'null') {\n          tokens.push({\n            type: 'name',\n            value\n          });\n        } else {\n          // unknown token, e.g. `nul` which isn't quite `null`\n          current++;\n          continue;\n        }\n        continue;\n      }\n      current++;\n    }\n    return tokens;\n  },\n  strip = tokens => {\n    if (tokens.length === 0) {\n      return tokens;\n    }\n    let lastToken = tokens[tokens.length - 1];\n    switch (lastToken.type) {\n      case 'separator':\n        tokens = tokens.slice(0, tokens.length - 1);\n        return strip(tokens);\n        break;\n      case 'number':\n        let lastCharacterOfLastToken = lastToken.value[lastToken.value.length - 1];\n        if (lastCharacterOfLastToken === '.' || lastCharacterOfLastToken === '-') {\n          tokens = tokens.slice(0, tokens.length - 1);\n          return strip(tokens);\n        }\n      case 'string':\n        let tokenBeforeTheLastToken = tokens[tokens.length - 2];\n        if (tokenBeforeTheLastToken?.type === 'delimiter') {\n          tokens = tokens.slice(0, tokens.length - 1);\n          return strip(tokens);\n        } else if (tokenBeforeTheLastToken?.type === 'brace' && tokenBeforeTheLastToken.value === '{') {\n          tokens = tokens.slice(0, tokens.length - 1);\n          return strip(tokens);\n        }\n        break;\n      case 'delimiter':\n        tokens = tokens.slice(0, tokens.length - 1);\n        return strip(tokens);\n        break;\n    }\n    return tokens;\n  },\n  unstrip = tokens => {\n    let tail = [];\n    tokens.map(token => {\n      if (token.type === 'brace') {\n        if (token.value === '{') {\n          tail.push('}');\n        } else {\n          tail.splice(tail.lastIndexOf('}'), 1);\n        }\n      }\n      if (token.type === 'paren') {\n        if (token.value === '[') {\n          tail.push(']');\n        } else {\n          tail.splice(tail.lastIndexOf(']'), 1);\n        }\n      }\n    });\n    if (tail.length > 0) {\n      tail.reverse().map(item => {\n        if (item === '}') {\n          tokens.push({\n            type: 'brace',\n            value: '}'\n          });\n        } else if (item === ']') {\n          tokens.push({\n            type: 'paren',\n            value: ']'\n          });\n        }\n      });\n    }\n    return tokens;\n  },\n  generate = tokens => {\n    let output = '';\n    tokens.map(token => {\n      switch (token.type) {\n        case 'string':\n          output += '\"' + token.value + '\"';\n          break;\n        default:\n          output += token.value;\n          break;\n      }\n    });\n    return output;\n  },\n  partialParse = input => JSON.parse(generate(unstrip(strip(tokenize(input)))));\nexport { partialParse };\n//# sourceMappingURL=parser.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}