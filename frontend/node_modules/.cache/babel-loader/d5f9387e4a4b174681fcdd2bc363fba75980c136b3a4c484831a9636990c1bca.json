{"ast":null,"code":"/**\n * @license\n * Copyright 2023 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\nvar __addDisposableResource = this && this.__addDisposableResource || function (env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose;\n    if (async) {\n      if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n      dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n      if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n      dispose = value[Symbol.dispose];\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    env.stack.push({\n      value: value,\n      dispose: dispose,\n      async: async\n    });\n  } else if (async) {\n    env.stack.push({\n      async: true\n    });\n  }\n  return value;\n};\nvar __disposeResources = this && this.__disposeResources || function (SuppressedError) {\n  return function (env) {\n    function fail(e) {\n      env.error = env.hasError ? new SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n      env.hasError = true;\n    }\n    function next() {\n      while (env.stack.length) {\n        var rec = env.stack.pop();\n        try {\n          var result = rec.dispose && rec.dispose.call(rec.value);\n          if (rec.async) return Promise.resolve(result).then(next, function (e) {\n            fail(e);\n            return next();\n          });\n        } catch (e) {\n          fail(e);\n        }\n      }\n      if (env.hasError) throw env.error;\n    }\n    return next();\n  };\n}(typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n});\nimport { asyncDisposeSymbol, disposeSymbol } from './disposable.js';\nimport { Mutex } from './Mutex.js';\nconst instances = new WeakSet();\nexport function moveable(Class, _) {\n  let hasDispose = false;\n  if (Class.prototype[disposeSymbol]) {\n    const dispose = Class.prototype[disposeSymbol];\n    Class.prototype[disposeSymbol] = function () {\n      if (instances.has(this)) {\n        instances.delete(this);\n        return;\n      }\n      return dispose.call(this);\n    };\n    hasDispose = true;\n  }\n  if (Class.prototype[asyncDisposeSymbol]) {\n    const asyncDispose = Class.prototype[asyncDisposeSymbol];\n    Class.prototype[asyncDisposeSymbol] = function () {\n      if (instances.has(this)) {\n        instances.delete(this);\n        return;\n      }\n      return asyncDispose.call(this);\n    };\n    hasDispose = true;\n  }\n  if (hasDispose) {\n    Class.prototype.move = function () {\n      instances.add(this);\n      return this;\n    };\n  }\n  return Class;\n}\nexport function throwIfDisposed(message = value => {\n  return `Attempted to use disposed ${value.constructor.name}.`;\n}) {\n  return (target, _) => {\n    return function (...args) {\n      if (this.disposed) {\n        throw new Error(message(this));\n      }\n      return target.call(this, ...args);\n    };\n  };\n}\nexport function inertIfDisposed(target, _) {\n  return function (...args) {\n    if (this.disposed) {\n      return;\n    }\n    return target.call(this, ...args);\n  };\n}\n/**\n * The decorator only invokes the target if the target has not been invoked with\n * the same arguments before. The decorated method throws an error if it's\n * invoked with a different number of elements: if you decorate a method, it\n * should have the same number of arguments\n *\n * @internal\n */\nexport function invokeAtMostOnceForArguments(target, _) {\n  const cache = new WeakMap();\n  let cacheDepth = -1;\n  return function (...args) {\n    if (cacheDepth === -1) {\n      cacheDepth = args.length;\n    }\n    if (cacheDepth !== args.length) {\n      throw new Error('Memoized method was called with the wrong number of arguments');\n    }\n    let freshArguments = false;\n    let cacheIterator = cache;\n    for (const arg of args) {\n      if (cacheIterator.has(arg)) {\n        cacheIterator = cacheIterator.get(arg);\n      } else {\n        freshArguments = true;\n        cacheIterator.set(arg, new WeakMap());\n        cacheIterator = cacheIterator.get(arg);\n      }\n    }\n    if (!freshArguments) {\n      return;\n    }\n    return target.call(this, ...args);\n  };\n}\nexport function guarded(getKey = function () {\n  return this;\n}) {\n  return (target, _) => {\n    const mutexes = new WeakMap();\n    return async function (...args) {\n      const env_1 = {\n        stack: [],\n        error: void 0,\n        hasError: false\n      };\n      try {\n        const key = getKey.call(this);\n        let mutex = mutexes.get(key);\n        if (!mutex) {\n          mutex = new Mutex();\n          mutexes.set(key, mutex);\n        }\n        const _ = __addDisposableResource(env_1, await mutex.acquire(), true);\n        return await target.call(this, ...args);\n      } catch (e_1) {\n        env_1.error = e_1;\n        env_1.hasError = true;\n      } finally {\n        const result_1 = __disposeResources(env_1);\n        if (result_1) await result_1;\n      }\n    };\n  };\n}\nconst bubbleHandlers = new WeakMap();\nconst bubbleInitializer = function (events) {\n  const handlers = bubbleHandlers.get(this) ?? new Map();\n  if (handlers.has(events)) {\n    return;\n  }\n  const handler = events !== undefined ? (type, event) => {\n    if (events.includes(type)) {\n      this.emit(type, event);\n    }\n  } : (type, event) => {\n    this.emit(type, event);\n  };\n  handlers.set(events, handler);\n  bubbleHandlers.set(this, handlers);\n};\n/**\n * Event emitter fields marked with `bubble` will have their events bubble up\n * the field owner.\n */\n// The type is too complicated to type.\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function bubble(events) {\n  return ({\n    set,\n    get\n  }, context) => {\n    context.addInitializer(function () {\n      return bubbleInitializer.apply(this, [events]);\n    });\n    return {\n      set(emitter) {\n        const handler = bubbleHandlers.get(this).get(events);\n        // In case we are re-setting.\n        const oldEmitter = get.call(this);\n        if (oldEmitter !== undefined) {\n          oldEmitter.off('*', handler);\n        }\n        if (emitter === undefined) {\n          return;\n        }\n        emitter.on('*', handler);\n        set.call(this, emitter);\n      },\n      init(emitter) {\n        if (emitter === undefined) {\n          return emitter;\n        }\n        bubbleInitializer.apply(this, [events]);\n        const handler = bubbleHandlers.get(this).get(events);\n        emitter.on('*', handler);\n        return emitter;\n      }\n    };\n  };\n}","map":{"version":3,"names":["asyncDisposeSymbol","disposeSymbol","Mutex","instances","WeakSet","moveable","Class","_","hasDispose","prototype","dispose","has","delete","call","asyncDispose","move","add","throwIfDisposed","message","value","constructor","name","target","args","disposed","Error","inertIfDisposed","invokeAtMostOnceForArguments","cache","WeakMap","cacheDepth","length","freshArguments","cacheIterator","arg","get","set","guarded","getKey","mutexes","key","mutex","__addDisposableResource","env_1","acquire","bubbleHandlers","bubbleInitializer","events","handlers","Map","handler","undefined","type","event","includes","emit","bubble","context","addInitializer","apply","emitter","oldEmitter","off","on","init"],"sources":["C:\\Users\\raffy\\Desktop\\test\\node_modules\\puppeteer-core\\src\\util\\decorators.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2023 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport type {EventType} from '../common/EventEmitter.js';\nimport type {EventEmitter} from '../common/EventEmitter.js';\nimport type {Disposed, Moveable} from '../common/types.js';\n\nimport {asyncDisposeSymbol, disposeSymbol} from './disposable.js';\nimport {Mutex} from './Mutex.js';\n\nconst instances = new WeakSet<object>();\n\nexport function moveable<\n  Class extends abstract new (...args: never[]) => Moveable,\n>(Class: Class, _: ClassDecoratorContext<Class>): Class {\n  let hasDispose = false;\n  if (Class.prototype[disposeSymbol]) {\n    const dispose = Class.prototype[disposeSymbol];\n    Class.prototype[disposeSymbol] = function (this: InstanceType<Class>) {\n      if (instances.has(this)) {\n        instances.delete(this);\n        return;\n      }\n      return dispose.call(this);\n    };\n    hasDispose = true;\n  }\n  if (Class.prototype[asyncDisposeSymbol]) {\n    const asyncDispose = Class.prototype[asyncDisposeSymbol];\n    Class.prototype[asyncDisposeSymbol] = function (this: InstanceType<Class>) {\n      if (instances.has(this)) {\n        instances.delete(this);\n        return;\n      }\n      return asyncDispose.call(this);\n    };\n    hasDispose = true;\n  }\n  if (hasDispose) {\n    Class.prototype.move = function (\n      this: InstanceType<Class>\n    ): InstanceType<Class> {\n      instances.add(this);\n      return this;\n    };\n  }\n  return Class;\n}\n\nexport function throwIfDisposed<This extends Disposed>(\n  message: (value: This) => string = value => {\n    return `Attempted to use disposed ${value.constructor.name}.`;\n  }\n) {\n  return (target: (this: This, ...args: any[]) => any, _: unknown) => {\n    return function (this: This, ...args: any[]): any {\n      if (this.disposed) {\n        throw new Error(message(this));\n      }\n      return target.call(this, ...args);\n    };\n  };\n}\n\nexport function inertIfDisposed<This extends Disposed>(\n  target: (this: This, ...args: any[]) => any,\n  _: unknown\n) {\n  return function (this: This, ...args: any[]): any {\n    if (this.disposed) {\n      return;\n    }\n    return target.call(this, ...args);\n  };\n}\n\n/**\n * The decorator only invokes the target if the target has not been invoked with\n * the same arguments before. The decorated method throws an error if it's\n * invoked with a different number of elements: if you decorate a method, it\n * should have the same number of arguments\n *\n * @internal\n */\nexport function invokeAtMostOnceForArguments(\n  target: (this: unknown, ...args: any[]) => any,\n  _: unknown\n): typeof target {\n  const cache = new WeakMap();\n  let cacheDepth = -1;\n  return function (this: unknown, ...args: unknown[]) {\n    if (cacheDepth === -1) {\n      cacheDepth = args.length;\n    }\n    if (cacheDepth !== args.length) {\n      throw new Error(\n        'Memoized method was called with the wrong number of arguments'\n      );\n    }\n    let freshArguments = false;\n    let cacheIterator = cache;\n    for (const arg of args) {\n      if (cacheIterator.has(arg as object)) {\n        cacheIterator = cacheIterator.get(arg as object)!;\n      } else {\n        freshArguments = true;\n        cacheIterator.set(arg as object, new WeakMap());\n        cacheIterator = cacheIterator.get(arg as object)!;\n      }\n    }\n    if (!freshArguments) {\n      return;\n    }\n    return target.call(this, ...args);\n  };\n}\n\nexport function guarded<T extends object>(\n  getKey = function (this: T): object {\n    return this;\n  }\n) {\n  return (\n    target: (this: T, ...args: any[]) => Promise<any>,\n    _: ClassMethodDecoratorContext<T>\n  ): typeof target => {\n    const mutexes = new WeakMap<object, Mutex>();\n    return async function (...args) {\n      const key = getKey.call(this);\n      let mutex = mutexes.get(key);\n      if (!mutex) {\n        mutex = new Mutex();\n        mutexes.set(key, mutex);\n      }\n      await using _ = await mutex.acquire();\n      return await target.call(this, ...args);\n    };\n  };\n}\n\nconst bubbleHandlers = new WeakMap<object, Map<any, any>>();\nconst bubbleInitializer = function <\n  T extends EventType[],\n  This extends EventEmitter<any>,\n>(this: This, events?: T) {\n  const handlers = bubbleHandlers.get(this) ?? new Map();\n  if (handlers.has(events)) {\n    return;\n  }\n\n  const handler =\n    events !== undefined\n      ? (type: EventType, event: unknown) => {\n          if (events.includes(type)) {\n            this.emit(type, event);\n          }\n        }\n      : (type: EventType, event: unknown) => {\n          this.emit(type, event);\n        };\n\n  handlers.set(events, handler);\n  bubbleHandlers.set(this, handlers);\n};\n/**\n * Event emitter fields marked with `bubble` will have their events bubble up\n * the field owner.\n */\n// The type is too complicated to type.\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function bubble<T extends EventType[]>(events?: T) {\n  return <This extends EventEmitter<any>, Value extends EventEmitter<any>>(\n    {set, get}: ClassAccessorDecoratorTarget<This, Value>,\n    context: ClassAccessorDecoratorContext<This, Value>\n  ): ClassAccessorDecoratorResult<This, Value> => {\n    context.addInitializer(function () {\n      return bubbleInitializer.apply(this, [events]);\n    });\n    return {\n      set(emitter) {\n        const handler = bubbleHandlers.get(this)!.get(events)!;\n\n        // In case we are re-setting.\n        const oldEmitter = get.call(this);\n        if (oldEmitter !== undefined) {\n          oldEmitter.off('*', handler);\n        }\n\n        if (emitter === undefined) {\n          return;\n        }\n        emitter.on('*', handler);\n        set.call(this, emitter);\n      },\n      init(emitter) {\n        if (emitter === undefined) {\n          return emitter;\n        }\n\n        bubbleInitializer.apply(this, [events]);\n\n        const handler = bubbleHandlers.get(this)!.get(events)!;\n        emitter.on('*', handler as any);\n        return emitter;\n      },\n    };\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}