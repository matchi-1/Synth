{"ast":null,"code":"/**\n * @license\n * Copyright 2023 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\nvar __runInitializers = this && this.__runInitializers || function (thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\nvar __esDecorate = this && this.__esDecorate || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) {\n    if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\");\n    return f;\n  }\n  var kind = contextIn.kind,\n    key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _,\n    done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n    var context = {};\n    for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n    for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n    context.addInitializer = function (f) {\n      if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\");\n      extraInitializers.push(accept(f || null));\n    };\n    var result = (0, decorators[i])(kind === \"accessor\" ? {\n      get: descriptor.get,\n      set: descriptor.set\n    } : descriptor[key], context);\n    if (kind === \"accessor\") {\n      if (result === void 0) continue;\n      if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n      if (_ = accept(result.get)) descriptor.get = _;\n      if (_ = accept(result.set)) descriptor.set = _;\n      if (_ = accept(result.init)) initializers.unshift(_);\n    } else if (_ = accept(result)) {\n      if (kind === \"field\") initializers.unshift(_);else descriptor[key] = _;\n    }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\nvar __addDisposableResource = this && this.__addDisposableResource || function (env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose;\n    if (async) {\n      if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n      dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n      if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n      dispose = value[Symbol.dispose];\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    env.stack.push({\n      value: value,\n      dispose: dispose,\n      async: async\n    });\n  } else if (async) {\n    env.stack.push({\n      async: true\n    });\n  }\n  return value;\n};\nvar __disposeResources = this && this.__disposeResources || function (SuppressedError) {\n  return function (env) {\n    function fail(e) {\n      env.error = env.hasError ? new SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n      env.hasError = true;\n    }\n    function next() {\n      while (env.stack.length) {\n        var rec = env.stack.pop();\n        try {\n          var result = rec.dispose && rec.dispose.call(rec.value);\n          if (rec.async) return Promise.resolve(result).then(next, function (e) {\n            fail(e);\n            return next();\n          });\n        } catch (e) {\n          fail(e);\n        }\n      }\n      if (env.hasError) throw env.error;\n    }\n    return next();\n  };\n}(typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n});\nimport { debugError, withSourcePuppeteerURLIfNone } from '../common/util.js';\nimport { moveable, throwIfDisposed } from '../util/decorators.js';\nimport { disposeSymbol, asyncDisposeSymbol } from '../util/disposable.js';\n/**\n * Represents a reference to a JavaScript object. Instances can be created using\n * {@link Page.evaluateHandle}.\n *\n * Handles prevent the referenced JavaScript object from being garbage-collected\n * unless the handle is purposely {@link JSHandle.dispose | disposed}. JSHandles\n * are auto-disposed when their associated frame is navigated away or the parent\n * context gets destroyed.\n *\n * Handles can be used as arguments for any evaluation function such as\n * {@link Page.$eval}, {@link Page.evaluate}, and {@link Page.evaluateHandle}.\n * They are resolved to their referenced object.\n *\n * @example\n *\n * ```ts\n * const windowHandle = await page.evaluateHandle(() => window);\n * ```\n *\n * @public\n */\nlet JSHandle = (() => {\n  let _classDecorators = [moveable];\n  let _classDescriptor;\n  let _classExtraInitializers = [];\n  let _classThis;\n  let _instanceExtraInitializers = [];\n  let _getProperty_decorators;\n  let _getProperties_decorators;\n  var JSHandle = class {\n    static {\n      _classThis = this;\n    }\n    static {\n      const _metadata = typeof Symbol === \"function\" && Symbol.metadata ? Object.create(null) : void 0;\n      __esDecorate(this, null, _getProperty_decorators, {\n        kind: \"method\",\n        name: \"getProperty\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"getProperty\" in obj,\n          get: obj => obj.getProperty\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _getProperties_decorators, {\n        kind: \"method\",\n        name: \"getProperties\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"getProperties\" in obj,\n          get: obj => obj.getProperties\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(null, _classDescriptor = {\n        value: _classThis\n      }, _classDecorators, {\n        kind: \"class\",\n        name: _classThis.name,\n        metadata: _metadata\n      }, null, _classExtraInitializers);\n      JSHandle = _classThis = _classDescriptor.value;\n      if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value: _metadata\n      });\n      __runInitializers(_classThis, _classExtraInitializers);\n    }\n    /**\n     * @internal\n     */\n    constructor() {\n      __runInitializers(this, _instanceExtraInitializers);\n    }\n    /**\n     * Evaluates the given function with the current handle as its first argument.\n     */\n    async evaluate(pageFunction, ...args) {\n      pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);\n      return await this.realm.evaluate(pageFunction, this, ...args);\n    }\n    /**\n     * Evaluates the given function with the current handle as its first argument.\n     *\n     */\n    async evaluateHandle(pageFunction, ...args) {\n      pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);\n      return await this.realm.evaluateHandle(pageFunction, this, ...args);\n    }\n    /**\n     * @internal\n     */\n    async getProperty(propertyName) {\n      return await this.evaluateHandle((object, propertyName) => {\n        return object[propertyName];\n      }, propertyName);\n    }\n    /**\n     * Gets a map of handles representing the properties of the current handle.\n     *\n     * @example\n     *\n     * ```ts\n     * const listHandle = await page.evaluateHandle(() => document.body.children);\n     * const properties = await listHandle.getProperties();\n     * const children = [];\n     * for (const property of properties.values()) {\n     *   const element = property.asElement();\n     *   if (element) {\n     *     children.push(element);\n     *   }\n     * }\n     * children; // holds elementHandles to all children of document.body\n     * ```\n     */\n    async getProperties() {\n      const propertyNames = await this.evaluate(object => {\n        const enumerableProperties = [];\n        const descriptors = Object.getOwnPropertyDescriptors(object);\n        for (const propertyName in descriptors) {\n          if (descriptors[propertyName]?.enumerable) {\n            enumerableProperties.push(propertyName);\n          }\n        }\n        return enumerableProperties;\n      });\n      const map = new Map();\n      const results = await Promise.all(propertyNames.map(key => {\n        return this.getProperty(key);\n      }));\n      for (const [key, value] of Object.entries(propertyNames)) {\n        const env_1 = {\n          stack: [],\n          error: void 0,\n          hasError: false\n        };\n        try {\n          const handle = __addDisposableResource(env_1, results[key], false);\n          if (handle) {\n            map.set(value, handle.move());\n          }\n        } catch (e_1) {\n          env_1.error = e_1;\n          env_1.hasError = true;\n        } finally {\n          __disposeResources(env_1);\n        }\n      }\n      return map;\n    }\n    /** @internal */\n    [(_getProperty_decorators = [throwIfDisposed()], _getProperties_decorators = [throwIfDisposed()], disposeSymbol)]() {\n      return void this.dispose().catch(debugError);\n    }\n    /** @internal */\n    [asyncDisposeSymbol]() {\n      return this.dispose();\n    }\n  };\n  return JSHandle = _classThis;\n})();\nexport { JSHandle };","map":{"version":3,"names":["debugError","withSourcePuppeteerURLIfNone","moveable","throwIfDisposed","disposeSymbol","asyncDisposeSymbol","JSHandle","__esDecorate","_getProperty_decorators","kind","name","static","private","access","has","obj","get","getProperty","metadata","_metadata","_instanceExtraInitializers","_getProperties_decorators","getProperties","_classDescriptor","value","_classThis","_classDecorators","_classExtraInitializers","__runInitializers","constructor","evaluate","pageFunction","args","realm","evaluateHandle","propertyName","object","propertyNames","enumerableProperties","descriptors","Object","getOwnPropertyDescriptors","enumerable","push","map","Map","results","Promise","all","key","entries","handle","__addDisposableResource","env_1","set","move","dispose","catch"],"sources":["C:\\Users\\raffy\\Desktop\\test\\node_modules\\puppeteer-core\\src\\api\\JSHandle.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2023 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport type Protocol from 'devtools-protocol';\n\nimport type {EvaluateFuncWith, HandleFor, HandleOr} from '../common/types.js';\nimport {debugError, withSourcePuppeteerURLIfNone} from '../common/util.js';\nimport {moveable, throwIfDisposed} from '../util/decorators.js';\nimport {disposeSymbol, asyncDisposeSymbol} from '../util/disposable.js';\n\nimport type {ElementHandle} from './ElementHandle.js';\nimport type {Realm} from './Realm.js';\n\n/**\n * Represents a reference to a JavaScript object. Instances can be created using\n * {@link Page.evaluateHandle}.\n *\n * Handles prevent the referenced JavaScript object from being garbage-collected\n * unless the handle is purposely {@link JSHandle.dispose | disposed}. JSHandles\n * are auto-disposed when their associated frame is navigated away or the parent\n * context gets destroyed.\n *\n * Handles can be used as arguments for any evaluation function such as\n * {@link Page.$eval}, {@link Page.evaluate}, and {@link Page.evaluateHandle}.\n * They are resolved to their referenced object.\n *\n * @example\n *\n * ```ts\n * const windowHandle = await page.evaluateHandle(() => window);\n * ```\n *\n * @public\n */\n@moveable\nexport abstract class JSHandle<T = unknown> {\n  declare move: () => this;\n\n  /**\n   * Used for nominally typing {@link JSHandle}.\n   */\n  declare _?: T;\n\n  /**\n   * @internal\n   */\n  constructor() {}\n\n  /**\n   * @internal\n   */\n  abstract get realm(): Realm;\n\n  /**\n   * @internal\n   */\n  abstract get disposed(): boolean;\n\n  /**\n   * Evaluates the given function with the current handle as its first argument.\n   */\n  async evaluate<\n    Params extends unknown[],\n    Func extends EvaluateFuncWith<T, Params> = EvaluateFuncWith<T, Params>,\n  >(\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<Awaited<ReturnType<Func>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(\n      this.evaluate.name,\n      pageFunction\n    );\n    return await this.realm.evaluate(pageFunction, this, ...args);\n  }\n\n  /**\n   * Evaluates the given function with the current handle as its first argument.\n   *\n   */\n  async evaluateHandle<\n    Params extends unknown[],\n    Func extends EvaluateFuncWith<T, Params> = EvaluateFuncWith<T, Params>,\n  >(\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<HandleFor<Awaited<ReturnType<Func>>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(\n      this.evaluateHandle.name,\n      pageFunction\n    );\n    return await this.realm.evaluateHandle(pageFunction, this, ...args);\n  }\n\n  /**\n   * Fetches a single property from the referenced object.\n   */\n  getProperty<K extends keyof T>(\n    propertyName: HandleOr<K>\n  ): Promise<HandleFor<T[K]>>;\n  getProperty(propertyName: string): Promise<JSHandle<unknown>>;\n\n  /**\n   * @internal\n   */\n  @throwIfDisposed()\n  async getProperty<K extends keyof T>(\n    propertyName: HandleOr<K>\n  ): Promise<HandleFor<T[K]>> {\n    return await this.evaluateHandle((object, propertyName) => {\n      return object[propertyName as K];\n    }, propertyName);\n  }\n\n  /**\n   * Gets a map of handles representing the properties of the current handle.\n   *\n   * @example\n   *\n   * ```ts\n   * const listHandle = await page.evaluateHandle(() => document.body.children);\n   * const properties = await listHandle.getProperties();\n   * const children = [];\n   * for (const property of properties.values()) {\n   *   const element = property.asElement();\n   *   if (element) {\n   *     children.push(element);\n   *   }\n   * }\n   * children; // holds elementHandles to all children of document.body\n   * ```\n   */\n  @throwIfDisposed()\n  async getProperties(): Promise<Map<string, JSHandle>> {\n    const propertyNames = await this.evaluate(object => {\n      const enumerableProperties = [];\n      const descriptors = Object.getOwnPropertyDescriptors(object);\n      for (const propertyName in descriptors) {\n        if (descriptors[propertyName]?.enumerable) {\n          enumerableProperties.push(propertyName);\n        }\n      }\n      return enumerableProperties;\n    });\n    const map = new Map<string, JSHandle>();\n    const results = await Promise.all(\n      propertyNames.map(key => {\n        return this.getProperty(key);\n      })\n    );\n    for (const [key, value] of Object.entries(propertyNames)) {\n      using handle = results[key as any];\n      if (handle) {\n        map.set(value, handle.move());\n      }\n    }\n    return map;\n  }\n\n  /**\n   * A vanilla object representing the serializable portions of the\n   * referenced object.\n   * @throws Throws if the object cannot be serialized due to circularity.\n   *\n   * @remarks\n   * If the object has a `toJSON` function, it **will not** be called.\n   */\n  abstract jsonValue(): Promise<T>;\n\n  /**\n   * Either `null` or the handle itself if the handle is an\n   * instance of {@link ElementHandle}.\n   */\n  abstract asElement(): ElementHandle<Node> | null;\n\n  /**\n   * Releases the object referenced by the handle for garbage collection.\n   */\n  abstract dispose(): Promise<void>;\n\n  /**\n   * Returns a string representation of the JSHandle.\n   *\n   * @remarks\n   * Useful during debugging.\n   */\n  abstract toString(): string;\n\n  /**\n   * @internal\n   */\n  abstract get id(): string | undefined;\n\n  /**\n   * Provides access to the\n   * {@link https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#type-RemoteObject | Protocol.Runtime.RemoteObject}\n   * backing this handle.\n   */\n  abstract remoteObject(): Protocol.Runtime.RemoteObject;\n\n  /** @internal */\n  [disposeSymbol](): void {\n    return void this.dispose().catch(debugError);\n  }\n\n  /** @internal */\n  [asyncDisposeSymbol](): Promise<void> {\n    return this.dispose();\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}