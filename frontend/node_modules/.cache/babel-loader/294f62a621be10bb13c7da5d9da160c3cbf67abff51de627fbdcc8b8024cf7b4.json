{"ast":null,"code":"/**\n * @license\n * Copyright 2023 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\nSymbol.dispose ??= Symbol('dispose');\nSymbol.asyncDispose ??= Symbol('asyncDispose');\n/**\n * @internal\n */\nexport const disposeSymbol = Symbol.dispose;\n/**\n * @internal\n */\nexport const asyncDisposeSymbol = Symbol.asyncDispose;\n/**\n * @internal\n */\nexport class DisposableStack {\n  #disposed = false;\n  #stack = [];\n  /**\n   * Returns a value indicating whether this stack has been disposed.\n   */\n  get disposed() {\n    return this.#disposed;\n  }\n  /**\n   * Disposes each resource in the stack in the reverse order that they were added.\n   */\n  dispose() {\n    if (this.#disposed) {\n      return;\n    }\n    this.#disposed = true;\n    for (const resource of this.#stack.reverse()) {\n      resource[disposeSymbol]();\n    }\n  }\n  /**\n   * Adds a disposable resource to the stack, returning the resource.\n   *\n   * @param value - The resource to add. `null` and `undefined` will not be added,\n   * but will be returned.\n   * @returns The provided `value`.\n   */\n  use(value) {\n    if (value) {\n      this.#stack.push(value);\n    }\n    return value;\n  }\n  /**\n   * Adds a value and associated disposal callback as a resource to the stack.\n   *\n   * @param value - The value to add.\n   * @param onDispose - The callback to use in place of a `[disposeSymbol]()`\n   * method. Will be invoked with `value` as the first parameter.\n   * @returns The provided `value`.\n   */\n  adopt(value, onDispose) {\n    this.#stack.push({\n      [disposeSymbol]() {\n        onDispose(value);\n      }\n    });\n    return value;\n  }\n  /**\n   * Adds a callback to be invoked when the stack is disposed.\n   */\n  defer(onDispose) {\n    this.#stack.push({\n      [disposeSymbol]() {\n        onDispose();\n      }\n    });\n  }\n  /**\n   * Move all resources out of this stack and into a new `DisposableStack`, and\n   * marks this stack as disposed.\n   *\n   * @example\n   *\n   * ```ts\n   * class C {\n   *   #res1: Disposable;\n   *   #res2: Disposable;\n   *   #disposables: DisposableStack;\n   *   constructor() {\n   *     // stack will be disposed when exiting constructor for any reason\n   *     using stack = new DisposableStack();\n   *\n   *     // get first resource\n   *     this.#res1 = stack.use(getResource1());\n   *\n   *     // get second resource. If this fails, both `stack` and `#res1` will be disposed.\n   *     this.#res2 = stack.use(getResource2());\n   *\n   *     // all operations succeeded, move resources out of `stack` so that\n   *     // they aren't disposed when constructor exits\n   *     this.#disposables = stack.move();\n   *   }\n   *\n   *   [disposeSymbol]() {\n   *     this.#disposables.dispose();\n   *   }\n   * }\n   * ```\n   */\n  move() {\n    if (this.#disposed) {\n      throw new ReferenceError('a disposed stack can not use anything new'); // step 3\n    }\n    const stack = new DisposableStack(); // step 4-5\n    stack.#stack = this.#stack;\n    this.#disposed = true;\n    return stack;\n  }\n  [disposeSymbol] = this.dispose;\n  [Symbol.toStringTag] = 'DisposableStack';\n}\n/**\n * @internal\n */\nexport class AsyncDisposableStack {\n  #disposed = false;\n  #stack = [];\n  /**\n   * Returns a value indicating whether this stack has been disposed.\n   */\n  get disposed() {\n    return this.#disposed;\n  }\n  /**\n   * Disposes each resource in the stack in the reverse order that they were added.\n   */\n  async dispose() {\n    if (this.#disposed) {\n      return;\n    }\n    this.#disposed = true;\n    for (const resource of this.#stack.reverse()) {\n      await resource[asyncDisposeSymbol]();\n    }\n  }\n  /**\n   * Adds a disposable resource to the stack, returning the resource.\n   *\n   * @param value - The resource to add. `null` and `undefined` will not be added,\n   * but will be returned.\n   * @returns The provided `value`.\n   */\n  use(value) {\n    if (value) {\n      this.#stack.push(value);\n    }\n    return value;\n  }\n  /**\n   * Adds a value and associated disposal callback as a resource to the stack.\n   *\n   * @param value - The value to add.\n   * @param onDispose - The callback to use in place of a `[disposeSymbol]()`\n   * method. Will be invoked with `value` as the first parameter.\n   * @returns The provided `value`.\n   */\n  adopt(value, onDispose) {\n    this.#stack.push({\n      [asyncDisposeSymbol]() {\n        return onDispose(value);\n      }\n    });\n    return value;\n  }\n  /**\n   * Adds a callback to be invoked when the stack is disposed.\n   */\n  defer(onDispose) {\n    this.#stack.push({\n      [asyncDisposeSymbol]() {\n        return onDispose();\n      }\n    });\n  }\n  /**\n   * Move all resources out of this stack and into a new `DisposableStack`, and\n   * marks this stack as disposed.\n   *\n   * @example\n   *\n   * ```ts\n   * class C {\n   *   #res1: Disposable;\n   *   #res2: Disposable;\n   *   #disposables: DisposableStack;\n   *   constructor() {\n   *     // stack will be disposed when exiting constructor for any reason\n   *     using stack = new DisposableStack();\n   *\n   *     // get first resource\n   *     this.#res1 = stack.use(getResource1());\n   *\n   *     // get second resource. If this fails, both `stack` and `#res1` will be disposed.\n   *     this.#res2 = stack.use(getResource2());\n   *\n   *     // all operations succeeded, move resources out of `stack` so that\n   *     // they aren't disposed when constructor exits\n   *     this.#disposables = stack.move();\n   *   }\n   *\n   *   [disposeSymbol]() {\n   *     this.#disposables.dispose();\n   *   }\n   * }\n   * ```\n   */\n  move() {\n    if (this.#disposed) {\n      throw new ReferenceError('a disposed stack can not use anything new'); // step 3\n    }\n    const stack = new AsyncDisposableStack(); // step 4-5\n    stack.#stack = this.#stack;\n    this.#disposed = true;\n    return stack;\n  }\n  [asyncDisposeSymbol] = this.dispose;\n  [Symbol.toStringTag] = 'AsyncDisposableStack';\n}","map":{"version":3,"names":["Symbol","dispose","asyncDispose","disposeSymbol","asyncDisposeSymbol","DisposableStack","disposed","stack","resource","reverse","use","value","push","adopt","onDispose","defer","move","ReferenceError","toStringTag","AsyncDisposableStack"],"sources":["C:\\Users\\raffy\\Desktop\\test\\node_modules\\puppeteer-core\\src\\util\\disposable.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2023 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n\ndeclare global {\n  interface SymbolConstructor {\n    /**\n     * A method that is used to release resources held by an object. Called by\n     * the semantics of the `using` statement.\n     */\n    readonly dispose: unique symbol;\n\n    /**\n     * A method that is used to asynchronously release resources held by an\n     * object. Called by the semantics of the `await using` statement.\n     */\n    readonly asyncDispose: unique symbol;\n  }\n\n  interface Disposable {\n    [Symbol.dispose](): void;\n  }\n\n  interface AsyncDisposable {\n    [Symbol.asyncDispose](): PromiseLike<void>;\n  }\n}\n\n(Symbol as any).dispose ??= Symbol('dispose');\n(Symbol as any).asyncDispose ??= Symbol('asyncDispose');\n\n/**\n * @internal\n */\nexport const disposeSymbol: typeof Symbol.dispose = Symbol.dispose;\n\n/**\n * @internal\n */\nexport const asyncDisposeSymbol: typeof Symbol.asyncDispose =\n  Symbol.asyncDispose;\n\n/**\n * @internal\n */\nexport class DisposableStack {\n  #disposed = false;\n  #stack: Disposable[] = [];\n\n  /**\n   * Returns a value indicating whether this stack has been disposed.\n   */\n  get disposed(): boolean {\n    return this.#disposed;\n  }\n\n  /**\n   * Disposes each resource in the stack in the reverse order that they were added.\n   */\n  dispose(): void {\n    if (this.#disposed) {\n      return;\n    }\n    this.#disposed = true;\n    for (const resource of this.#stack.reverse()) {\n      resource[disposeSymbol]();\n    }\n  }\n\n  /**\n   * Adds a disposable resource to the stack, returning the resource.\n   *\n   * @param value - The resource to add. `null` and `undefined` will not be added,\n   * but will be returned.\n   * @returns The provided `value`.\n   */\n  use<T extends Disposable | null | undefined>(value: T): T {\n    if (value) {\n      this.#stack.push(value);\n    }\n    return value;\n  }\n\n  /**\n   * Adds a value and associated disposal callback as a resource to the stack.\n   *\n   * @param value - The value to add.\n   * @param onDispose - The callback to use in place of a `[disposeSymbol]()`\n   * method. Will be invoked with `value` as the first parameter.\n   * @returns The provided `value`.\n   */\n  adopt<T>(value: T, onDispose: (value: T) => void): T {\n    this.#stack.push({\n      [disposeSymbol]() {\n        onDispose(value);\n      },\n    });\n    return value;\n  }\n\n  /**\n   * Adds a callback to be invoked when the stack is disposed.\n   */\n  defer(onDispose: () => void): void {\n    this.#stack.push({\n      [disposeSymbol]() {\n        onDispose();\n      },\n    });\n  }\n\n  /**\n   * Move all resources out of this stack and into a new `DisposableStack`, and\n   * marks this stack as disposed.\n   *\n   * @example\n   *\n   * ```ts\n   * class C {\n   *   #res1: Disposable;\n   *   #res2: Disposable;\n   *   #disposables: DisposableStack;\n   *   constructor() {\n   *     // stack will be disposed when exiting constructor for any reason\n   *     using stack = new DisposableStack();\n   *\n   *     // get first resource\n   *     this.#res1 = stack.use(getResource1());\n   *\n   *     // get second resource. If this fails, both `stack` and `#res1` will be disposed.\n   *     this.#res2 = stack.use(getResource2());\n   *\n   *     // all operations succeeded, move resources out of `stack` so that\n   *     // they aren't disposed when constructor exits\n   *     this.#disposables = stack.move();\n   *   }\n   *\n   *   [disposeSymbol]() {\n   *     this.#disposables.dispose();\n   *   }\n   * }\n   * ```\n   */\n  move(): DisposableStack {\n    if (this.#disposed) {\n      throw new ReferenceError('a disposed stack can not use anything new'); // step 3\n    }\n    const stack = new DisposableStack(); // step 4-5\n    stack.#stack = this.#stack;\n    this.#disposed = true;\n    return stack;\n  }\n\n  [disposeSymbol] = this.dispose;\n\n  readonly [Symbol.toStringTag] = 'DisposableStack';\n}\n\n/**\n * @internal\n */\nexport class AsyncDisposableStack {\n  #disposed = false;\n  #stack: AsyncDisposable[] = [];\n\n  /**\n   * Returns a value indicating whether this stack has been disposed.\n   */\n  get disposed(): boolean {\n    return this.#disposed;\n  }\n\n  /**\n   * Disposes each resource in the stack in the reverse order that they were added.\n   */\n  async dispose(): Promise<void> {\n    if (this.#disposed) {\n      return;\n    }\n    this.#disposed = true;\n    for (const resource of this.#stack.reverse()) {\n      await resource[asyncDisposeSymbol]();\n    }\n  }\n\n  /**\n   * Adds a disposable resource to the stack, returning the resource.\n   *\n   * @param value - The resource to add. `null` and `undefined` will not be added,\n   * but will be returned.\n   * @returns The provided `value`.\n   */\n  use<T extends AsyncDisposable | null | undefined>(value: T): T {\n    if (value) {\n      this.#stack.push(value);\n    }\n    return value;\n  }\n\n  /**\n   * Adds a value and associated disposal callback as a resource to the stack.\n   *\n   * @param value - The value to add.\n   * @param onDispose - The callback to use in place of a `[disposeSymbol]()`\n   * method. Will be invoked with `value` as the first parameter.\n   * @returns The provided `value`.\n   */\n  adopt<T>(value: T, onDispose: (value: T) => Promise<void>): T {\n    this.#stack.push({\n      [asyncDisposeSymbol]() {\n        return onDispose(value);\n      },\n    });\n    return value;\n  }\n\n  /**\n   * Adds a callback to be invoked when the stack is disposed.\n   */\n  defer(onDispose: () => Promise<void>): void {\n    this.#stack.push({\n      [asyncDisposeSymbol]() {\n        return onDispose();\n      },\n    });\n  }\n\n  /**\n   * Move all resources out of this stack and into a new `DisposableStack`, and\n   * marks this stack as disposed.\n   *\n   * @example\n   *\n   * ```ts\n   * class C {\n   *   #res1: Disposable;\n   *   #res2: Disposable;\n   *   #disposables: DisposableStack;\n   *   constructor() {\n   *     // stack will be disposed when exiting constructor for any reason\n   *     using stack = new DisposableStack();\n   *\n   *     // get first resource\n   *     this.#res1 = stack.use(getResource1());\n   *\n   *     // get second resource. If this fails, both `stack` and `#res1` will be disposed.\n   *     this.#res2 = stack.use(getResource2());\n   *\n   *     // all operations succeeded, move resources out of `stack` so that\n   *     // they aren't disposed when constructor exits\n   *     this.#disposables = stack.move();\n   *   }\n   *\n   *   [disposeSymbol]() {\n   *     this.#disposables.dispose();\n   *   }\n   * }\n   * ```\n   */\n  move(): AsyncDisposableStack {\n    if (this.#disposed) {\n      throw new ReferenceError('a disposed stack can not use anything new'); // step 3\n    }\n    const stack = new AsyncDisposableStack(); // step 4-5\n    stack.#stack = this.#stack;\n    this.#disposed = true;\n    return stack;\n  }\n\n  [asyncDisposeSymbol] = this.dispose;\n\n  readonly [Symbol.toStringTag] = 'AsyncDisposableStack';\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}