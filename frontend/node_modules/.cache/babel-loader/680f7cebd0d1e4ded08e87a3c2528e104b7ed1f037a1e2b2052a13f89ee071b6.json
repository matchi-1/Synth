{"ast":null,"code":"/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactUpdates\n */\n\n'use strict';\n\nvar CallbackQueue = require(\"./CallbackQueue\");\nvar PooledClass = require(\"./PooledClass\");\nvar ReactCurrentOwner = require(\"./ReactCurrentOwner\");\nvar ReactPerf = require(\"./ReactPerf\");\nvar ReactReconciler = require(\"./ReactReconciler\");\nvar Transaction = require(\"./Transaction\");\nvar assign = require(\"./Object.assign\");\nvar invariant = require(\"./invariant\");\nvar warning = require(\"./warning\");\nvar dirtyComponents = [];\nvar asapCallbackQueue = CallbackQueue.getPooled();\nvar asapEnqueued = false;\nvar batchingStrategy = null;\nfunction ensureInjected() {\n  \"production\" !== process.env.NODE_ENV ? invariant(ReactUpdates.ReactReconcileTransaction && batchingStrategy, 'ReactUpdates: must inject a reconcile transaction class and batching ' + 'strategy') : invariant(ReactUpdates.ReactReconcileTransaction && batchingStrategy);\n}\nvar NESTED_UPDATES = {\n  initialize: function () {\n    this.dirtyComponentsLength = dirtyComponents.length;\n  },\n  close: function () {\n    if (this.dirtyComponentsLength !== dirtyComponents.length) {\n      // Additional updates were enqueued by componentDidUpdate handlers or\n      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run\n      // these new updates so that if A's componentDidUpdate calls setState on\n      // B, B will update before the callback A's updater provided when calling\n      // setState.\n      dirtyComponents.splice(0, this.dirtyComponentsLength);\n      flushBatchedUpdates();\n    } else {\n      dirtyComponents.length = 0;\n    }\n  }\n};\nvar UPDATE_QUEUEING = {\n  initialize: function () {\n    this.callbackQueue.reset();\n  },\n  close: function () {\n    this.callbackQueue.notifyAll();\n  }\n};\nvar TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];\nfunction ReactUpdatesFlushTransaction() {\n  this.reinitializeTransaction();\n  this.dirtyComponentsLength = null;\n  this.callbackQueue = CallbackQueue.getPooled();\n  this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled();\n}\nassign(ReactUpdatesFlushTransaction.prototype, Transaction.Mixin, {\n  getTransactionWrappers: function () {\n    return TRANSACTION_WRAPPERS;\n  },\n  destructor: function () {\n    this.dirtyComponentsLength = null;\n    CallbackQueue.release(this.callbackQueue);\n    this.callbackQueue = null;\n    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);\n    this.reconcileTransaction = null;\n  },\n  perform: function (method, scope, a) {\n    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`\n    // with this transaction's wrappers around it.\n    return Transaction.Mixin.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);\n  }\n});\nPooledClass.addPoolingTo(ReactUpdatesFlushTransaction);\nfunction batchedUpdates(callback, a, b, c, d) {\n  ensureInjected();\n  batchingStrategy.batchedUpdates(callback, a, b, c, d);\n}\n\n/**\n * Array comparator for ReactComponents by mount ordering.\n *\n * @param {ReactComponent} c1 first component you're comparing\n * @param {ReactComponent} c2 second component you're comparing\n * @return {number} Return value usable by Array.prototype.sort().\n */\nfunction mountOrderComparator(c1, c2) {\n  return c1._mountOrder - c2._mountOrder;\n}\nfunction runBatchedUpdates(transaction) {\n  var len = transaction.dirtyComponentsLength;\n  \"production\" !== process.env.NODE_ENV ? invariant(len === dirtyComponents.length, 'Expected flush transaction\\'s stored dirty-components length (%s) to ' + 'match dirty-components array length (%s).', len, dirtyComponents.length) : invariant(len === dirtyComponents.length);\n\n  // Since reconciling a component higher in the owner hierarchy usually (not\n  // always -- see shouldComponentUpdate()) will reconcile children, reconcile\n  // them before their children by sorting the array.\n  dirtyComponents.sort(mountOrderComparator);\n  for (var i = 0; i < len; i++) {\n    // If a component is unmounted before pending changes apply, it will still\n    // be here, but we assume that it has cleared its _pendingCallbacks and\n    // that performUpdateIfNecessary is a noop.\n    var component = dirtyComponents[i];\n\n    // If performUpdateIfNecessary happens to enqueue any new updates, we\n    // shouldn't execute the callbacks until the next render happens, so\n    // stash the callbacks first\n    var callbacks = component._pendingCallbacks;\n    component._pendingCallbacks = null;\n    ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction);\n    if (callbacks) {\n      for (var j = 0; j < callbacks.length; j++) {\n        transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());\n      }\n    }\n  }\n}\nvar flushBatchedUpdates = function () {\n  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents\n  // array and perform any updates enqueued by mount-ready handlers (i.e.,\n  // componentDidUpdate) but we need to check here too in order to catch\n  // updates enqueued by setState callbacks and asap calls.\n  while (dirtyComponents.length || asapEnqueued) {\n    if (dirtyComponents.length) {\n      var transaction = ReactUpdatesFlushTransaction.getPooled();\n      transaction.perform(runBatchedUpdates, null, transaction);\n      ReactUpdatesFlushTransaction.release(transaction);\n    }\n    if (asapEnqueued) {\n      asapEnqueued = false;\n      var queue = asapCallbackQueue;\n      asapCallbackQueue = CallbackQueue.getPooled();\n      queue.notifyAll();\n      CallbackQueue.release(queue);\n    }\n  }\n};\nflushBatchedUpdates = ReactPerf.measure('ReactUpdates', 'flushBatchedUpdates', flushBatchedUpdates);\n\n/**\n * Mark a component as needing a rerender, adding an optional callback to a\n * list of functions which will be executed once the rerender occurs.\n */\nfunction enqueueUpdate(component) {\n  ensureInjected();\n\n  // Various parts of our code (such as ReactCompositeComponent's\n  // _renderValidatedComponent) assume that calls to render aren't nested;\n  // verify that that's the case. (This is called by each top-level update\n  // function, like setProps, setState, forceUpdate, etc.; creation and\n  // destruction of top-level components is guarded in ReactMount.)\n  \"production\" !== process.env.NODE_ENV ? warning(ReactCurrentOwner.current == null, 'enqueueUpdate(): Render methods should be a pure function of props ' + 'and state; triggering nested component updates from render is not ' + 'allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate.') : null;\n  if (!batchingStrategy.isBatchingUpdates) {\n    batchingStrategy.batchedUpdates(enqueueUpdate, component);\n    return;\n  }\n  dirtyComponents.push(component);\n}\n\n/**\n * Enqueue a callback to be run at the end of the current batching cycle. Throws\n * if no updates are currently being performed.\n */\nfunction asap(callback, context) {\n  \"production\" !== process.env.NODE_ENV ? invariant(batchingStrategy.isBatchingUpdates, 'ReactUpdates.asap: Can\\'t enqueue an asap callback in a context where' + 'updates are not being batched.') : invariant(batchingStrategy.isBatchingUpdates);\n  asapCallbackQueue.enqueue(callback, context);\n  asapEnqueued = true;\n}\nvar ReactUpdatesInjection = {\n  injectReconcileTransaction: function (ReconcileTransaction) {\n    \"production\" !== process.env.NODE_ENV ? invariant(ReconcileTransaction, 'ReactUpdates: must provide a reconcile transaction class') : invariant(ReconcileTransaction);\n    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;\n  },\n  injectBatchingStrategy: function (_batchingStrategy) {\n    \"production\" !== process.env.NODE_ENV ? invariant(_batchingStrategy, 'ReactUpdates: must provide a batching strategy') : invariant(_batchingStrategy);\n    \"production\" !== process.env.NODE_ENV ? invariant(typeof _batchingStrategy.batchedUpdates === 'function', 'ReactUpdates: must provide a batchedUpdates() function') : invariant(typeof _batchingStrategy.batchedUpdates === 'function');\n    \"production\" !== process.env.NODE_ENV ? invariant(typeof _batchingStrategy.isBatchingUpdates === 'boolean', 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : invariant(typeof _batchingStrategy.isBatchingUpdates === 'boolean');\n    batchingStrategy = _batchingStrategy;\n  }\n};\nvar ReactUpdates = {\n  /**\n   * React references `ReactReconcileTransaction` using this property in order\n   * to allow dependency injection.\n   *\n   * @internal\n   */\n  ReactReconcileTransaction: null,\n  batchedUpdates: batchedUpdates,\n  enqueueUpdate: enqueueUpdate,\n  flushBatchedUpdates: flushBatchedUpdates,\n  injection: ReactUpdatesInjection,\n  asap: asap\n};\nmodule.exports = ReactUpdates;","map":{"version":3,"names":["CallbackQueue","require","PooledClass","ReactCurrentOwner","ReactPerf","ReactReconciler","Transaction","assign","invariant","warning","dirtyComponents","asapCallbackQueue","getPooled","asapEnqueued","batchingStrategy","ensureInjected","process","env","NODE_ENV","ReactUpdates","ReactReconcileTransaction","NESTED_UPDATES","initialize","dirtyComponentsLength","length","close","splice","flushBatchedUpdates","UPDATE_QUEUEING","callbackQueue","reset","notifyAll","TRANSACTION_WRAPPERS","ReactUpdatesFlushTransaction","reinitializeTransaction","reconcileTransaction","prototype","Mixin","getTransactionWrappers","destructor","release","perform","method","scope","a","call","addPoolingTo","batchedUpdates","callback","b","c","d","mountOrderComparator","c1","c2","_mountOrder","runBatchedUpdates","transaction","len","sort","i","component","callbacks","_pendingCallbacks","performUpdateIfNecessary","j","enqueue","getPublicInstance","queue","measure","enqueueUpdate","current","isBatchingUpdates","push","asap","context","ReactUpdatesInjection","injectReconcileTransaction","ReconcileTransaction","injectBatchingStrategy","_batchingStrategy","injection","module","exports"],"sources":["C:/Users/raffy/Desktop/test/Synth/Synth/node_modules/react-embedded-browser/node_modules/react/lib/ReactUpdates.js"],"sourcesContent":["/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactUpdates\n */\n\n'use strict';\n\nvar CallbackQueue = require(\"./CallbackQueue\");\nvar PooledClass = require(\"./PooledClass\");\nvar ReactCurrentOwner = require(\"./ReactCurrentOwner\");\nvar ReactPerf = require(\"./ReactPerf\");\nvar ReactReconciler = require(\"./ReactReconciler\");\nvar Transaction = require(\"./Transaction\");\n\nvar assign = require(\"./Object.assign\");\nvar invariant = require(\"./invariant\");\nvar warning = require(\"./warning\");\n\nvar dirtyComponents = [];\nvar asapCallbackQueue = CallbackQueue.getPooled();\nvar asapEnqueued = false;\n\nvar batchingStrategy = null;\n\nfunction ensureInjected() {\n  (\"production\" !== process.env.NODE_ENV ? invariant(\n    ReactUpdates.ReactReconcileTransaction && batchingStrategy,\n    'ReactUpdates: must inject a reconcile transaction class and batching ' +\n    'strategy'\n  ) : invariant(ReactUpdates.ReactReconcileTransaction && batchingStrategy));\n}\n\nvar NESTED_UPDATES = {\n  initialize: function() {\n    this.dirtyComponentsLength = dirtyComponents.length;\n  },\n  close: function() {\n    if (this.dirtyComponentsLength !== dirtyComponents.length) {\n      // Additional updates were enqueued by componentDidUpdate handlers or\n      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run\n      // these new updates so that if A's componentDidUpdate calls setState on\n      // B, B will update before the callback A's updater provided when calling\n      // setState.\n      dirtyComponents.splice(0, this.dirtyComponentsLength);\n      flushBatchedUpdates();\n    } else {\n      dirtyComponents.length = 0;\n    }\n  }\n};\n\nvar UPDATE_QUEUEING = {\n  initialize: function() {\n    this.callbackQueue.reset();\n  },\n  close: function() {\n    this.callbackQueue.notifyAll();\n  }\n};\n\nvar TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];\n\nfunction ReactUpdatesFlushTransaction() {\n  this.reinitializeTransaction();\n  this.dirtyComponentsLength = null;\n  this.callbackQueue = CallbackQueue.getPooled();\n  this.reconcileTransaction =\n    ReactUpdates.ReactReconcileTransaction.getPooled();\n}\n\nassign(\n  ReactUpdatesFlushTransaction.prototype,\n  Transaction.Mixin, {\n  getTransactionWrappers: function() {\n    return TRANSACTION_WRAPPERS;\n  },\n\n  destructor: function() {\n    this.dirtyComponentsLength = null;\n    CallbackQueue.release(this.callbackQueue);\n    this.callbackQueue = null;\n    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);\n    this.reconcileTransaction = null;\n  },\n\n  perform: function(method, scope, a) {\n    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`\n    // with this transaction's wrappers around it.\n    return Transaction.Mixin.perform.call(\n      this,\n      this.reconcileTransaction.perform,\n      this.reconcileTransaction,\n      method,\n      scope,\n      a\n    );\n  }\n});\n\nPooledClass.addPoolingTo(ReactUpdatesFlushTransaction);\n\nfunction batchedUpdates(callback, a, b, c, d) {\n  ensureInjected();\n  batchingStrategy.batchedUpdates(callback, a, b, c, d);\n}\n\n/**\n * Array comparator for ReactComponents by mount ordering.\n *\n * @param {ReactComponent} c1 first component you're comparing\n * @param {ReactComponent} c2 second component you're comparing\n * @return {number} Return value usable by Array.prototype.sort().\n */\nfunction mountOrderComparator(c1, c2) {\n  return c1._mountOrder - c2._mountOrder;\n}\n\nfunction runBatchedUpdates(transaction) {\n  var len = transaction.dirtyComponentsLength;\n  (\"production\" !== process.env.NODE_ENV ? invariant(\n    len === dirtyComponents.length,\n    'Expected flush transaction\\'s stored dirty-components length (%s) to ' +\n    'match dirty-components array length (%s).',\n    len,\n    dirtyComponents.length\n  ) : invariant(len === dirtyComponents.length));\n\n  // Since reconciling a component higher in the owner hierarchy usually (not\n  // always -- see shouldComponentUpdate()) will reconcile children, reconcile\n  // them before their children by sorting the array.\n  dirtyComponents.sort(mountOrderComparator);\n\n  for (var i = 0; i < len; i++) {\n    // If a component is unmounted before pending changes apply, it will still\n    // be here, but we assume that it has cleared its _pendingCallbacks and\n    // that performUpdateIfNecessary is a noop.\n    var component = dirtyComponents[i];\n\n    // If performUpdateIfNecessary happens to enqueue any new updates, we\n    // shouldn't execute the callbacks until the next render happens, so\n    // stash the callbacks first\n    var callbacks = component._pendingCallbacks;\n    component._pendingCallbacks = null;\n\n    ReactReconciler.performUpdateIfNecessary(\n      component,\n      transaction.reconcileTransaction\n    );\n\n    if (callbacks) {\n      for (var j = 0; j < callbacks.length; j++) {\n        transaction.callbackQueue.enqueue(\n          callbacks[j],\n          component.getPublicInstance()\n        );\n      }\n    }\n  }\n}\n\nvar flushBatchedUpdates = function() {\n  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents\n  // array and perform any updates enqueued by mount-ready handlers (i.e.,\n  // componentDidUpdate) but we need to check here too in order to catch\n  // updates enqueued by setState callbacks and asap calls.\n  while (dirtyComponents.length || asapEnqueued) {\n    if (dirtyComponents.length) {\n      var transaction = ReactUpdatesFlushTransaction.getPooled();\n      transaction.perform(runBatchedUpdates, null, transaction);\n      ReactUpdatesFlushTransaction.release(transaction);\n    }\n\n    if (asapEnqueued) {\n      asapEnqueued = false;\n      var queue = asapCallbackQueue;\n      asapCallbackQueue = CallbackQueue.getPooled();\n      queue.notifyAll();\n      CallbackQueue.release(queue);\n    }\n  }\n};\nflushBatchedUpdates = ReactPerf.measure(\n  'ReactUpdates',\n  'flushBatchedUpdates',\n  flushBatchedUpdates\n);\n\n/**\n * Mark a component as needing a rerender, adding an optional callback to a\n * list of functions which will be executed once the rerender occurs.\n */\nfunction enqueueUpdate(component) {\n  ensureInjected();\n\n  // Various parts of our code (such as ReactCompositeComponent's\n  // _renderValidatedComponent) assume that calls to render aren't nested;\n  // verify that that's the case. (This is called by each top-level update\n  // function, like setProps, setState, forceUpdate, etc.; creation and\n  // destruction of top-level components is guarded in ReactMount.)\n  (\"production\" !== process.env.NODE_ENV ? warning(\n    ReactCurrentOwner.current == null,\n    'enqueueUpdate(): Render methods should be a pure function of props ' +\n    'and state; triggering nested component updates from render is not ' +\n    'allowed. If necessary, trigger nested updates in ' +\n    'componentDidUpdate.'\n  ) : null);\n\n  if (!batchingStrategy.isBatchingUpdates) {\n    batchingStrategy.batchedUpdates(enqueueUpdate, component);\n    return;\n  }\n\n  dirtyComponents.push(component);\n}\n\n/**\n * Enqueue a callback to be run at the end of the current batching cycle. Throws\n * if no updates are currently being performed.\n */\nfunction asap(callback, context) {\n  (\"production\" !== process.env.NODE_ENV ? invariant(\n    batchingStrategy.isBatchingUpdates,\n    'ReactUpdates.asap: Can\\'t enqueue an asap callback in a context where' +\n    'updates are not being batched.'\n  ) : invariant(batchingStrategy.isBatchingUpdates));\n  asapCallbackQueue.enqueue(callback, context);\n  asapEnqueued = true;\n}\n\nvar ReactUpdatesInjection = {\n  injectReconcileTransaction: function(ReconcileTransaction) {\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      ReconcileTransaction,\n      'ReactUpdates: must provide a reconcile transaction class'\n    ) : invariant(ReconcileTransaction));\n    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;\n  },\n\n  injectBatchingStrategy: function(_batchingStrategy) {\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      _batchingStrategy,\n      'ReactUpdates: must provide a batching strategy'\n    ) : invariant(_batchingStrategy));\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      typeof _batchingStrategy.batchedUpdates === 'function',\n      'ReactUpdates: must provide a batchedUpdates() function'\n    ) : invariant(typeof _batchingStrategy.batchedUpdates === 'function'));\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      typeof _batchingStrategy.isBatchingUpdates === 'boolean',\n      'ReactUpdates: must provide an isBatchingUpdates boolean attribute'\n    ) : invariant(typeof _batchingStrategy.isBatchingUpdates === 'boolean'));\n    batchingStrategy = _batchingStrategy;\n  }\n};\n\nvar ReactUpdates = {\n  /**\n   * React references `ReactReconcileTransaction` using this property in order\n   * to allow dependency injection.\n   *\n   * @internal\n   */\n  ReactReconcileTransaction: null,\n\n  batchedUpdates: batchedUpdates,\n  enqueueUpdate: enqueueUpdate,\n  flushBatchedUpdates: flushBatchedUpdates,\n  injection: ReactUpdatesInjection,\n  asap: asap\n};\n\nmodule.exports = ReactUpdates;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}