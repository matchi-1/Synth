{"ast":null,"code":"/**\n * @license\n * Copyright 2017 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { Keyboard, Mouse, MouseButton, Touchscreen } from '../api/Input.js';\nimport { _keyDefinitions } from '../common/USKeyboardLayout.js';\nimport { assert } from '../util/assert.js';\n/**\n * @internal\n */\nexport class CdpKeyboard extends Keyboard {\n  #client;\n  #pressedKeys = new Set();\n  _modifiers = 0;\n  constructor(client) {\n    super();\n    this.#client = client;\n  }\n  updateClient(client) {\n    this.#client = client;\n  }\n  async down(key, options = {\n    text: undefined,\n    commands: []\n  }) {\n    const description = this.#keyDescriptionForString(key);\n    const autoRepeat = this.#pressedKeys.has(description.code);\n    this.#pressedKeys.add(description.code);\n    this._modifiers |= this.#modifierBit(description.key);\n    const text = options.text === undefined ? description.text : options.text;\n    await this.#client.send('Input.dispatchKeyEvent', {\n      type: text ? 'keyDown' : 'rawKeyDown',\n      modifiers: this._modifiers,\n      windowsVirtualKeyCode: description.keyCode,\n      code: description.code,\n      key: description.key,\n      text: text,\n      unmodifiedText: text,\n      autoRepeat,\n      location: description.location,\n      isKeypad: description.location === 3,\n      commands: options.commands\n    });\n  }\n  #modifierBit(key) {\n    if (key === 'Alt') {\n      return 1;\n    }\n    if (key === 'Control') {\n      return 2;\n    }\n    if (key === 'Meta') {\n      return 4;\n    }\n    if (key === 'Shift') {\n      return 8;\n    }\n    return 0;\n  }\n  #keyDescriptionForString(keyString) {\n    const shift = this._modifiers & 8;\n    const description = {\n      key: '',\n      keyCode: 0,\n      code: '',\n      text: '',\n      location: 0\n    };\n    const definition = _keyDefinitions[keyString];\n    assert(definition, `Unknown key: \"${keyString}\"`);\n    if (definition.key) {\n      description.key = definition.key;\n    }\n    if (shift && definition.shiftKey) {\n      description.key = definition.shiftKey;\n    }\n    if (definition.keyCode) {\n      description.keyCode = definition.keyCode;\n    }\n    if (shift && definition.shiftKeyCode) {\n      description.keyCode = definition.shiftKeyCode;\n    }\n    if (definition.code) {\n      description.code = definition.code;\n    }\n    if (definition.location) {\n      description.location = definition.location;\n    }\n    if (description.key.length === 1) {\n      description.text = description.key;\n    }\n    if (definition.text) {\n      description.text = definition.text;\n    }\n    if (shift && definition.shiftText) {\n      description.text = definition.shiftText;\n    }\n    // if any modifiers besides shift are pressed, no text should be sent\n    if (this._modifiers & ~8) {\n      description.text = '';\n    }\n    return description;\n  }\n  async up(key) {\n    const description = this.#keyDescriptionForString(key);\n    this._modifiers &= ~this.#modifierBit(description.key);\n    this.#pressedKeys.delete(description.code);\n    await this.#client.send('Input.dispatchKeyEvent', {\n      type: 'keyUp',\n      modifiers: this._modifiers,\n      key: description.key,\n      windowsVirtualKeyCode: description.keyCode,\n      code: description.code,\n      location: description.location\n    });\n  }\n  async sendCharacter(char) {\n    await this.#client.send('Input.insertText', {\n      text: char\n    });\n  }\n  charIsKey(char) {\n    return !!_keyDefinitions[char];\n  }\n  async type(text, options = {}) {\n    const delay = options.delay || undefined;\n    for (const char of text) {\n      if (this.charIsKey(char)) {\n        await this.press(char, {\n          delay\n        });\n      } else {\n        if (delay) {\n          await new Promise(f => {\n            return setTimeout(f, delay);\n          });\n        }\n        await this.sendCharacter(char);\n      }\n    }\n  }\n  async press(key, options = {}) {\n    const {\n      delay = null\n    } = options;\n    await this.down(key, options);\n    if (delay) {\n      await new Promise(f => {\n        return setTimeout(f, options.delay);\n      });\n    }\n    await this.up(key);\n  }\n}\nconst getFlag = button => {\n  switch (button) {\n    case MouseButton.Left:\n      return 1 /* MouseButtonFlag.Left */;\n    case MouseButton.Right:\n      return 2 /* MouseButtonFlag.Right */;\n    case MouseButton.Middle:\n      return 4 /* MouseButtonFlag.Middle */;\n    case MouseButton.Back:\n      return 8 /* MouseButtonFlag.Back */;\n    case MouseButton.Forward:\n      return 16 /* MouseButtonFlag.Forward */;\n  }\n};\n/**\n * This should match\n * https://source.chromium.org/chromium/chromium/src/+/refs/heads/main:content/browser/renderer_host/input/web_input_event_builders_mac.mm;drc=a61b95c63b0b75c1cfe872d9c8cdf927c226046e;bpv=1;bpt=1;l=221.\n */\nconst getButtonFromPressedButtons = buttons => {\n  if (buttons & 1 /* MouseButtonFlag.Left */) {\n    return MouseButton.Left;\n  } else if (buttons & 2 /* MouseButtonFlag.Right */) {\n    return MouseButton.Right;\n  } else if (buttons & 4 /* MouseButtonFlag.Middle */) {\n    return MouseButton.Middle;\n  } else if (buttons & 8 /* MouseButtonFlag.Back */) {\n    return MouseButton.Back;\n  } else if (buttons & 16 /* MouseButtonFlag.Forward */) {\n    return MouseButton.Forward;\n  }\n  return 'none';\n};\n/**\n * @internal\n */\nexport class CdpMouse extends Mouse {\n  #client;\n  #keyboard;\n  constructor(client, keyboard) {\n    super();\n    this.#client = client;\n    this.#keyboard = keyboard;\n  }\n  updateClient(client) {\n    this.#client = client;\n  }\n  #_state = {\n    position: {\n      x: 0,\n      y: 0\n    },\n    buttons: 0 /* MouseButtonFlag.None */\n  };\n  get #state() {\n    return Object.assign({\n      ...this.#_state\n    }, ...this.#transactions);\n  }\n  // Transactions can run in parallel, so we store each of thme in this array.\n  #transactions = [];\n  #createTransaction() {\n    const transaction = {};\n    this.#transactions.push(transaction);\n    const popTransaction = () => {\n      this.#transactions.splice(this.#transactions.indexOf(transaction), 1);\n    };\n    return {\n      update: updates => {\n        Object.assign(transaction, updates);\n      },\n      commit: () => {\n        this.#_state = {\n          ...this.#_state,\n          ...transaction\n        };\n        popTransaction();\n      },\n      rollback: popTransaction\n    };\n  }\n  /**\n   * This is a shortcut for a typical update, commit/rollback lifecycle based on\n   * the error of the action.\n   */\n  async #withTransaction(action) {\n    const {\n      update,\n      commit,\n      rollback\n    } = this.#createTransaction();\n    try {\n      await action(update);\n      commit();\n    } catch (error) {\n      rollback();\n      throw error;\n    }\n  }\n  async reset() {\n    const actions = [];\n    for (const [flag, button] of [[1 /* MouseButtonFlag.Left */, MouseButton.Left], [4 /* MouseButtonFlag.Middle */, MouseButton.Middle], [2 /* MouseButtonFlag.Right */, MouseButton.Right], [16 /* MouseButtonFlag.Forward */, MouseButton.Forward], [8 /* MouseButtonFlag.Back */, MouseButton.Back]]) {\n      if (this.#state.buttons & flag) {\n        actions.push(this.up({\n          button: button\n        }));\n      }\n    }\n    if (this.#state.position.x !== 0 || this.#state.position.y !== 0) {\n      actions.push(this.move(0, 0));\n    }\n    await Promise.all(actions);\n  }\n  async move(x, y, options = {}) {\n    const {\n      steps = 1\n    } = options;\n    const from = this.#state.position;\n    const to = {\n      x,\n      y\n    };\n    for (let i = 1; i <= steps; i++) {\n      await this.#withTransaction(updateState => {\n        updateState({\n          position: {\n            x: from.x + (to.x - from.x) * (i / steps),\n            y: from.y + (to.y - from.y) * (i / steps)\n          }\n        });\n        const {\n          buttons,\n          position\n        } = this.#state;\n        return this.#client.send('Input.dispatchMouseEvent', {\n          type: 'mouseMoved',\n          modifiers: this.#keyboard._modifiers,\n          buttons,\n          button: getButtonFromPressedButtons(buttons),\n          ...position\n        });\n      });\n    }\n  }\n  async down(options = {}) {\n    const {\n      button = MouseButton.Left,\n      clickCount = 1\n    } = options;\n    const flag = getFlag(button);\n    if (!flag) {\n      throw new Error(`Unsupported mouse button: ${button}`);\n    }\n    if (this.#state.buttons & flag) {\n      throw new Error(`'${button}' is already pressed.`);\n    }\n    await this.#withTransaction(updateState => {\n      updateState({\n        buttons: this.#state.buttons | flag\n      });\n      const {\n        buttons,\n        position\n      } = this.#state;\n      return this.#client.send('Input.dispatchMouseEvent', {\n        type: 'mousePressed',\n        modifiers: this.#keyboard._modifiers,\n        clickCount,\n        buttons,\n        button,\n        ...position\n      });\n    });\n  }\n  async up(options = {}) {\n    const {\n      button = MouseButton.Left,\n      clickCount = 1\n    } = options;\n    const flag = getFlag(button);\n    if (!flag) {\n      throw new Error(`Unsupported mouse button: ${button}`);\n    }\n    if (!(this.#state.buttons & flag)) {\n      throw new Error(`'${button}' is not pressed.`);\n    }\n    await this.#withTransaction(updateState => {\n      updateState({\n        buttons: this.#state.buttons & ~flag\n      });\n      const {\n        buttons,\n        position\n      } = this.#state;\n      return this.#client.send('Input.dispatchMouseEvent', {\n        type: 'mouseReleased',\n        modifiers: this.#keyboard._modifiers,\n        clickCount,\n        buttons,\n        button,\n        ...position\n      });\n    });\n  }\n  async click(x, y, options = {}) {\n    const {\n      delay,\n      count = 1,\n      clickCount = count\n    } = options;\n    if (count < 1) {\n      throw new Error('Click must occur a positive number of times.');\n    }\n    const actions = [this.move(x, y)];\n    if (clickCount === count) {\n      for (let i = 1; i < count; ++i) {\n        actions.push(this.down({\n          ...options,\n          clickCount: i\n        }), this.up({\n          ...options,\n          clickCount: i\n        }));\n      }\n    }\n    actions.push(this.down({\n      ...options,\n      clickCount\n    }));\n    if (typeof delay === 'number') {\n      await Promise.all(actions);\n      actions.length = 0;\n      await new Promise(resolve => {\n        setTimeout(resolve, delay);\n      });\n    }\n    actions.push(this.up({\n      ...options,\n      clickCount\n    }));\n    await Promise.all(actions);\n  }\n  async wheel(options = {}) {\n    const {\n      deltaX = 0,\n      deltaY = 0\n    } = options;\n    const {\n      position,\n      buttons\n    } = this.#state;\n    await this.#client.send('Input.dispatchMouseEvent', {\n      type: 'mouseWheel',\n      pointerType: 'mouse',\n      modifiers: this.#keyboard._modifiers,\n      deltaY,\n      deltaX,\n      buttons,\n      ...position\n    });\n  }\n  async drag(start, target) {\n    const promise = new Promise(resolve => {\n      this.#client.once('Input.dragIntercepted', event => {\n        return resolve(event.data);\n      });\n    });\n    await this.move(start.x, start.y);\n    await this.down();\n    await this.move(target.x, target.y);\n    return await promise;\n  }\n  async dragEnter(target, data) {\n    await this.#client.send('Input.dispatchDragEvent', {\n      type: 'dragEnter',\n      x: target.x,\n      y: target.y,\n      modifiers: this.#keyboard._modifiers,\n      data\n    });\n  }\n  async dragOver(target, data) {\n    await this.#client.send('Input.dispatchDragEvent', {\n      type: 'dragOver',\n      x: target.x,\n      y: target.y,\n      modifiers: this.#keyboard._modifiers,\n      data\n    });\n  }\n  async drop(target, data) {\n    await this.#client.send('Input.dispatchDragEvent', {\n      type: 'drop',\n      x: target.x,\n      y: target.y,\n      modifiers: this.#keyboard._modifiers,\n      data\n    });\n  }\n  async dragAndDrop(start, target, options = {}) {\n    const {\n      delay = null\n    } = options;\n    const data = await this.drag(start, target);\n    await this.dragEnter(target, data);\n    await this.dragOver(target, data);\n    if (delay) {\n      await new Promise(resolve => {\n        return setTimeout(resolve, delay);\n      });\n    }\n    await this.drop(target, data);\n    await this.up();\n  }\n}\n/**\n * @internal\n */\nexport class CdpTouchscreen extends Touchscreen {\n  #client;\n  #keyboard;\n  constructor(client, keyboard) {\n    super();\n    this.#client = client;\n    this.#keyboard = keyboard;\n  }\n  updateClient(client) {\n    this.#client = client;\n  }\n  async touchStart(x, y) {\n    await this.#client.send('Input.dispatchTouchEvent', {\n      type: 'touchStart',\n      touchPoints: [{\n        x: Math.round(x),\n        y: Math.round(y),\n        radiusX: 0.5,\n        radiusY: 0.5,\n        force: 0.5\n      }],\n      modifiers: this.#keyboard._modifiers\n    });\n  }\n  async touchMove(x, y) {\n    await this.#client.send('Input.dispatchTouchEvent', {\n      type: 'touchMove',\n      touchPoints: [{\n        x: Math.round(x),\n        y: Math.round(y),\n        radiusX: 0.5,\n        radiusY: 0.5,\n        force: 0.5\n      }],\n      modifiers: this.#keyboard._modifiers\n    });\n  }\n  async touchEnd() {\n    await this.#client.send('Input.dispatchTouchEvent', {\n      type: 'touchEnd',\n      touchPoints: [],\n      modifiers: this.#keyboard._modifiers\n    });\n  }\n}","map":{"version":3,"names":["Keyboard","Mouse","MouseButton","Touchscreen","_keyDefinitions","assert","CdpKeyboard","client","pressedKeys","Set","_modifiers","constructor","updateClient","down","key","options","text","undefined","commands","description","keyDescriptionForString","autoRepeat","has","code","add","modifierBit","send","type","modifiers","windowsVirtualKeyCode","keyCode","unmodifiedText","location","isKeypad","#modifierBit","#keyDescriptionForString","keyString","shift","definition","shiftKey","shiftKeyCode","length","shiftText","up","delete","sendCharacter","char","charIsKey","delay","press","Promise","f","setTimeout","getFlag","button","Left","Right","Middle","Back","Forward","getButtonFromPressedButtons","buttons","CdpMouse","keyboard","_state","position","x","y","state","#state","Object","assign","transactions","createTransaction","#createTransaction","transaction","push","popTransaction","splice","indexOf","update","updates","commit","rollback","withTransaction","#withTransaction","action","error","reset","actions","flag","move","all","steps","from","to","i","updateState","clickCount","Error","click","count","resolve","wheel","deltaX","deltaY","pointerType","drag","start","target","promise","once","event","data","dragEnter","dragOver","drop","dragAndDrop","CdpTouchscreen","touchStart","touchPoints","Math","round","radiusX","radiusY","force","touchMove","touchEnd"],"sources":["C:\\Users\\raffy\\Desktop\\test\\node_modules\\puppeteer-core\\src\\cdp\\Input.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2017 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport type {Protocol} from 'devtools-protocol';\n\nimport type {CDPSession} from '../api/CDPSession.js';\nimport type {Point} from '../api/ElementHandle.js';\nimport {\n  Keyboard,\n  Mouse,\n  MouseButton,\n  Touchscreen,\n  type KeyDownOptions,\n  type KeyPressOptions,\n  type KeyboardTypeOptions,\n  type MouseClickOptions,\n  type MouseMoveOptions,\n  type MouseOptions,\n  type MouseWheelOptions,\n} from '../api/Input.js';\nimport {\n  _keyDefinitions,\n  type KeyDefinition,\n  type KeyInput,\n} from '../common/USKeyboardLayout.js';\nimport {assert} from '../util/assert.js';\n\ntype KeyDescription = Required<\n  Pick<KeyDefinition, 'keyCode' | 'key' | 'text' | 'code' | 'location'>\n>;\n\n/**\n * @internal\n */\nexport class CdpKeyboard extends Keyboard {\n  #client: CDPSession;\n  #pressedKeys = new Set<string>();\n\n  _modifiers = 0;\n\n  constructor(client: CDPSession) {\n    super();\n    this.#client = client;\n  }\n\n  updateClient(client: CDPSession): void {\n    this.#client = client;\n  }\n\n  override async down(\n    key: KeyInput,\n    options: Readonly<KeyDownOptions> = {\n      text: undefined,\n      commands: [],\n    }\n  ): Promise<void> {\n    const description = this.#keyDescriptionForString(key);\n\n    const autoRepeat = this.#pressedKeys.has(description.code);\n    this.#pressedKeys.add(description.code);\n    this._modifiers |= this.#modifierBit(description.key);\n\n    const text = options.text === undefined ? description.text : options.text;\n    await this.#client.send('Input.dispatchKeyEvent', {\n      type: text ? 'keyDown' : 'rawKeyDown',\n      modifiers: this._modifiers,\n      windowsVirtualKeyCode: description.keyCode,\n      code: description.code,\n      key: description.key,\n      text: text,\n      unmodifiedText: text,\n      autoRepeat,\n      location: description.location,\n      isKeypad: description.location === 3,\n      commands: options.commands,\n    });\n  }\n\n  #modifierBit(key: string): number {\n    if (key === 'Alt') {\n      return 1;\n    }\n    if (key === 'Control') {\n      return 2;\n    }\n    if (key === 'Meta') {\n      return 4;\n    }\n    if (key === 'Shift') {\n      return 8;\n    }\n    return 0;\n  }\n\n  #keyDescriptionForString(keyString: KeyInput): KeyDescription {\n    const shift = this._modifiers & 8;\n    const description = {\n      key: '',\n      keyCode: 0,\n      code: '',\n      text: '',\n      location: 0,\n    };\n\n    const definition = _keyDefinitions[keyString];\n    assert(definition, `Unknown key: \"${keyString}\"`);\n\n    if (definition.key) {\n      description.key = definition.key;\n    }\n    if (shift && definition.shiftKey) {\n      description.key = definition.shiftKey;\n    }\n\n    if (definition.keyCode) {\n      description.keyCode = definition.keyCode;\n    }\n    if (shift && definition.shiftKeyCode) {\n      description.keyCode = definition.shiftKeyCode;\n    }\n\n    if (definition.code) {\n      description.code = definition.code;\n    }\n\n    if (definition.location) {\n      description.location = definition.location;\n    }\n\n    if (description.key.length === 1) {\n      description.text = description.key;\n    }\n\n    if (definition.text) {\n      description.text = definition.text;\n    }\n    if (shift && definition.shiftText) {\n      description.text = definition.shiftText;\n    }\n\n    // if any modifiers besides shift are pressed, no text should be sent\n    if (this._modifiers & ~8) {\n      description.text = '';\n    }\n\n    return description;\n  }\n\n  override async up(key: KeyInput): Promise<void> {\n    const description = this.#keyDescriptionForString(key);\n\n    this._modifiers &= ~this.#modifierBit(description.key);\n    this.#pressedKeys.delete(description.code);\n    await this.#client.send('Input.dispatchKeyEvent', {\n      type: 'keyUp',\n      modifiers: this._modifiers,\n      key: description.key,\n      windowsVirtualKeyCode: description.keyCode,\n      code: description.code,\n      location: description.location,\n    });\n  }\n\n  override async sendCharacter(char: string): Promise<void> {\n    await this.#client.send('Input.insertText', {text: char});\n  }\n\n  private charIsKey(char: string): char is KeyInput {\n    return !!_keyDefinitions[char as KeyInput];\n  }\n\n  override async type(\n    text: string,\n    options: Readonly<KeyboardTypeOptions> = {}\n  ): Promise<void> {\n    const delay = options.delay || undefined;\n    for (const char of text) {\n      if (this.charIsKey(char)) {\n        await this.press(char, {delay});\n      } else {\n        if (delay) {\n          await new Promise(f => {\n            return setTimeout(f, delay);\n          });\n        }\n        await this.sendCharacter(char);\n      }\n    }\n  }\n\n  override async press(\n    key: KeyInput,\n    options: Readonly<KeyPressOptions> = {}\n  ): Promise<void> {\n    const {delay = null} = options;\n    await this.down(key, options);\n    if (delay) {\n      await new Promise(f => {\n        return setTimeout(f, options.delay);\n      });\n    }\n    await this.up(key);\n  }\n}\n\n/**\n * This must follow {@link Protocol.Input.DispatchMouseEventRequest.buttons}.\n */\nconst enum MouseButtonFlag {\n  None = 0,\n  Left = 1,\n  Right = 1 << 1,\n  Middle = 1 << 2,\n  Back = 1 << 3,\n  Forward = 1 << 4,\n}\n\nconst getFlag = (button: MouseButton): MouseButtonFlag => {\n  switch (button) {\n    case MouseButton.Left:\n      return MouseButtonFlag.Left;\n    case MouseButton.Right:\n      return MouseButtonFlag.Right;\n    case MouseButton.Middle:\n      return MouseButtonFlag.Middle;\n    case MouseButton.Back:\n      return MouseButtonFlag.Back;\n    case MouseButton.Forward:\n      return MouseButtonFlag.Forward;\n  }\n};\n\n/**\n * This should match\n * https://source.chromium.org/chromium/chromium/src/+/refs/heads/main:content/browser/renderer_host/input/web_input_event_builders_mac.mm;drc=a61b95c63b0b75c1cfe872d9c8cdf927c226046e;bpv=1;bpt=1;l=221.\n */\nconst getButtonFromPressedButtons = (\n  buttons: number\n): Protocol.Input.MouseButton => {\n  if (buttons & MouseButtonFlag.Left) {\n    return MouseButton.Left;\n  } else if (buttons & MouseButtonFlag.Right) {\n    return MouseButton.Right;\n  } else if (buttons & MouseButtonFlag.Middle) {\n    return MouseButton.Middle;\n  } else if (buttons & MouseButtonFlag.Back) {\n    return MouseButton.Back;\n  } else if (buttons & MouseButtonFlag.Forward) {\n    return MouseButton.Forward;\n  }\n  return 'none';\n};\n\ninterface MouseState {\n  /**\n   * The current position of the mouse.\n   */\n  position: Point;\n  /**\n   * The buttons that are currently being pressed.\n   */\n  buttons: number;\n}\n\n/**\n * @internal\n */\nexport class CdpMouse extends Mouse {\n  #client: CDPSession;\n  #keyboard: CdpKeyboard;\n\n  constructor(client: CDPSession, keyboard: CdpKeyboard) {\n    super();\n    this.#client = client;\n    this.#keyboard = keyboard;\n  }\n\n  updateClient(client: CDPSession): void {\n    this.#client = client;\n  }\n\n  #_state: Readonly<MouseState> = {\n    position: {x: 0, y: 0},\n    buttons: MouseButtonFlag.None,\n  };\n  get #state(): MouseState {\n    return Object.assign({...this.#_state}, ...this.#transactions);\n  }\n\n  // Transactions can run in parallel, so we store each of thme in this array.\n  #transactions: Array<Partial<MouseState>> = [];\n  #createTransaction(): {\n    update: (updates: Partial<MouseState>) => void;\n    commit: () => void;\n    rollback: () => void;\n  } {\n    const transaction: Partial<MouseState> = {};\n    this.#transactions.push(transaction);\n    const popTransaction = () => {\n      this.#transactions.splice(this.#transactions.indexOf(transaction), 1);\n    };\n    return {\n      update: (updates: Partial<MouseState>) => {\n        Object.assign(transaction, updates);\n      },\n      commit: () => {\n        this.#_state = {...this.#_state, ...transaction};\n        popTransaction();\n      },\n      rollback: popTransaction,\n    };\n  }\n\n  /**\n   * This is a shortcut for a typical update, commit/rollback lifecycle based on\n   * the error of the action.\n   */\n  async #withTransaction(\n    action: (update: (updates: Partial<MouseState>) => void) => Promise<unknown>\n  ): Promise<void> {\n    const {update, commit, rollback} = this.#createTransaction();\n    try {\n      await action(update);\n      commit();\n    } catch (error) {\n      rollback();\n      throw error;\n    }\n  }\n\n  override async reset(): Promise<void> {\n    const actions = [];\n    for (const [flag, button] of [\n      [MouseButtonFlag.Left, MouseButton.Left],\n      [MouseButtonFlag.Middle, MouseButton.Middle],\n      [MouseButtonFlag.Right, MouseButton.Right],\n      [MouseButtonFlag.Forward, MouseButton.Forward],\n      [MouseButtonFlag.Back, MouseButton.Back],\n    ] as const) {\n      if (this.#state.buttons & flag) {\n        actions.push(this.up({button: button}));\n      }\n    }\n    if (this.#state.position.x !== 0 || this.#state.position.y !== 0) {\n      actions.push(this.move(0, 0));\n    }\n    await Promise.all(actions);\n  }\n\n  override async move(\n    x: number,\n    y: number,\n    options: Readonly<MouseMoveOptions> = {}\n  ): Promise<void> {\n    const {steps = 1} = options;\n    const from = this.#state.position;\n    const to = {x, y};\n    for (let i = 1; i <= steps; i++) {\n      await this.#withTransaction(updateState => {\n        updateState({\n          position: {\n            x: from.x + (to.x - from.x) * (i / steps),\n            y: from.y + (to.y - from.y) * (i / steps),\n          },\n        });\n        const {buttons, position} = this.#state;\n        return this.#client.send('Input.dispatchMouseEvent', {\n          type: 'mouseMoved',\n          modifiers: this.#keyboard._modifiers,\n          buttons,\n          button: getButtonFromPressedButtons(buttons),\n          ...position,\n        });\n      });\n    }\n  }\n\n  override async down(options: Readonly<MouseOptions> = {}): Promise<void> {\n    const {button = MouseButton.Left, clickCount = 1} = options;\n    const flag = getFlag(button);\n    if (!flag) {\n      throw new Error(`Unsupported mouse button: ${button}`);\n    }\n    if (this.#state.buttons & flag) {\n      throw new Error(`'${button}' is already pressed.`);\n    }\n    await this.#withTransaction(updateState => {\n      updateState({\n        buttons: this.#state.buttons | flag,\n      });\n      const {buttons, position} = this.#state;\n      return this.#client.send('Input.dispatchMouseEvent', {\n        type: 'mousePressed',\n        modifiers: this.#keyboard._modifiers,\n        clickCount,\n        buttons,\n        button,\n        ...position,\n      });\n    });\n  }\n\n  override async up(options: Readonly<MouseOptions> = {}): Promise<void> {\n    const {button = MouseButton.Left, clickCount = 1} = options;\n    const flag = getFlag(button);\n    if (!flag) {\n      throw new Error(`Unsupported mouse button: ${button}`);\n    }\n    if (!(this.#state.buttons & flag)) {\n      throw new Error(`'${button}' is not pressed.`);\n    }\n    await this.#withTransaction(updateState => {\n      updateState({\n        buttons: this.#state.buttons & ~flag,\n      });\n      const {buttons, position} = this.#state;\n      return this.#client.send('Input.dispatchMouseEvent', {\n        type: 'mouseReleased',\n        modifiers: this.#keyboard._modifiers,\n        clickCount,\n        buttons,\n        button,\n        ...position,\n      });\n    });\n  }\n\n  override async click(\n    x: number,\n    y: number,\n    options: Readonly<MouseClickOptions> = {}\n  ): Promise<void> {\n    const {delay, count = 1, clickCount = count} = options;\n    if (count < 1) {\n      throw new Error('Click must occur a positive number of times.');\n    }\n    const actions: Array<Promise<void>> = [this.move(x, y)];\n    if (clickCount === count) {\n      for (let i = 1; i < count; ++i) {\n        actions.push(\n          this.down({...options, clickCount: i}),\n          this.up({...options, clickCount: i})\n        );\n      }\n    }\n    actions.push(this.down({...options, clickCount}));\n    if (typeof delay === 'number') {\n      await Promise.all(actions);\n      actions.length = 0;\n      await new Promise(resolve => {\n        setTimeout(resolve, delay);\n      });\n    }\n    actions.push(this.up({...options, clickCount}));\n    await Promise.all(actions);\n  }\n\n  override async wheel(\n    options: Readonly<MouseWheelOptions> = {}\n  ): Promise<void> {\n    const {deltaX = 0, deltaY = 0} = options;\n    const {position, buttons} = this.#state;\n    await this.#client.send('Input.dispatchMouseEvent', {\n      type: 'mouseWheel',\n      pointerType: 'mouse',\n      modifiers: this.#keyboard._modifiers,\n      deltaY,\n      deltaX,\n      buttons,\n      ...position,\n    });\n  }\n\n  override async drag(\n    start: Point,\n    target: Point\n  ): Promise<Protocol.Input.DragData> {\n    const promise = new Promise<Protocol.Input.DragData>(resolve => {\n      this.#client.once('Input.dragIntercepted', event => {\n        return resolve(event.data);\n      });\n    });\n    await this.move(start.x, start.y);\n    await this.down();\n    await this.move(target.x, target.y);\n    return await promise;\n  }\n\n  override async dragEnter(\n    target: Point,\n    data: Protocol.Input.DragData\n  ): Promise<void> {\n    await this.#client.send('Input.dispatchDragEvent', {\n      type: 'dragEnter',\n      x: target.x,\n      y: target.y,\n      modifiers: this.#keyboard._modifiers,\n      data,\n    });\n  }\n\n  override async dragOver(\n    target: Point,\n    data: Protocol.Input.DragData\n  ): Promise<void> {\n    await this.#client.send('Input.dispatchDragEvent', {\n      type: 'dragOver',\n      x: target.x,\n      y: target.y,\n      modifiers: this.#keyboard._modifiers,\n      data,\n    });\n  }\n\n  override async drop(\n    target: Point,\n    data: Protocol.Input.DragData\n  ): Promise<void> {\n    await this.#client.send('Input.dispatchDragEvent', {\n      type: 'drop',\n      x: target.x,\n      y: target.y,\n      modifiers: this.#keyboard._modifiers,\n      data,\n    });\n  }\n\n  override async dragAndDrop(\n    start: Point,\n    target: Point,\n    options: {delay?: number} = {}\n  ): Promise<void> {\n    const {delay = null} = options;\n    const data = await this.drag(start, target);\n    await this.dragEnter(target, data);\n    await this.dragOver(target, data);\n    if (delay) {\n      await new Promise(resolve => {\n        return setTimeout(resolve, delay);\n      });\n    }\n    await this.drop(target, data);\n    await this.up();\n  }\n}\n\n/**\n * @internal\n */\nexport class CdpTouchscreen extends Touchscreen {\n  #client: CDPSession;\n  #keyboard: CdpKeyboard;\n\n  constructor(client: CDPSession, keyboard: CdpKeyboard) {\n    super();\n    this.#client = client;\n    this.#keyboard = keyboard;\n  }\n\n  updateClient(client: CDPSession): void {\n    this.#client = client;\n  }\n\n  override async touchStart(x: number, y: number): Promise<void> {\n    await this.#client.send('Input.dispatchTouchEvent', {\n      type: 'touchStart',\n      touchPoints: [\n        {\n          x: Math.round(x),\n          y: Math.round(y),\n          radiusX: 0.5,\n          radiusY: 0.5,\n          force: 0.5,\n        },\n      ],\n      modifiers: this.#keyboard._modifiers,\n    });\n  }\n\n  override async touchMove(x: number, y: number): Promise<void> {\n    await this.#client.send('Input.dispatchTouchEvent', {\n      type: 'touchMove',\n      touchPoints: [\n        {\n          x: Math.round(x),\n          y: Math.round(y),\n          radiusX: 0.5,\n          radiusY: 0.5,\n          force: 0.5,\n        },\n      ],\n      modifiers: this.#keyboard._modifiers,\n    });\n  }\n\n  override async touchEnd(): Promise<void> {\n    await this.#client.send('Input.dispatchTouchEvent', {\n      type: 'touchEnd',\n      touchPoints: [],\n      modifiers: this.#keyboard._modifiers,\n    });\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}