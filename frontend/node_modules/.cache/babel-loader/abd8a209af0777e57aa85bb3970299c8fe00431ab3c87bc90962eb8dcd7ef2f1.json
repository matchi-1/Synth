{"ast":null,"code":"/**\n * Copyright 2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n* @providesModule ReactFragment\n*/\n\n'use strict';\n\nvar ReactElement = require(\"./ReactElement\");\nvar warning = require(\"./warning\");\n\n/**\n * We used to allow keyed objects to serve as a collection of ReactElements,\n * or nested sets. This allowed us a way to explicitly key a set a fragment of\n * components. This is now being replaced with an opaque data structure.\n * The upgrade path is to call React.addons.createFragment({ key: value }) to\n * create a keyed fragment. The resulting data structure is opaque, for now.\n */\n\nif (\"production\" !== process.env.NODE_ENV) {\n  var fragmentKey = '_reactFragment';\n  var didWarnKey = '_reactDidWarn';\n  var canWarnForReactFragment = false;\n  try {\n    // Feature test. Don't even try to issue this warning if we can't use\n    // enumerable: false.\n\n    var dummy = function () {\n      return 1;\n    };\n    Object.defineProperty({}, fragmentKey, {\n      enumerable: false,\n      value: true\n    });\n    Object.defineProperty({}, 'key', {\n      enumerable: true,\n      get: dummy\n    });\n    canWarnForReactFragment = true;\n  } catch (x) {}\n  var proxyPropertyAccessWithWarning = function (obj, key) {\n    Object.defineProperty(obj, key, {\n      enumerable: true,\n      get: function () {\n        \"production\" !== process.env.NODE_ENV ? warning(this[didWarnKey], 'A ReactFragment is an opaque type. Accessing any of its ' + 'properties is deprecated. Pass it to one of the React.Children ' + 'helpers.') : null;\n        this[didWarnKey] = true;\n        return this[fragmentKey][key];\n      },\n      set: function (value) {\n        \"production\" !== process.env.NODE_ENV ? warning(this[didWarnKey], 'A ReactFragment is an immutable opaque type. Mutating its ' + 'properties is deprecated.') : null;\n        this[didWarnKey] = true;\n        this[fragmentKey][key] = value;\n      }\n    });\n  };\n  var issuedWarnings = {};\n  var didWarnForFragment = function (fragment) {\n    // We use the keys and the type of the value as a heuristic to dedupe the\n    // warning to avoid spamming too much.\n    var fragmentCacheKey = '';\n    for (var key in fragment) {\n      fragmentCacheKey += key + ':' + typeof fragment[key] + ',';\n    }\n    var alreadyWarnedOnce = !!issuedWarnings[fragmentCacheKey];\n    issuedWarnings[fragmentCacheKey] = true;\n    return alreadyWarnedOnce;\n  };\n}\nvar ReactFragment = {\n  // Wrap a keyed object in an opaque proxy that warns you if you access any\n  // of its properties.\n  create: function (object) {\n    if (\"production\" !== process.env.NODE_ENV) {\n      if (typeof object !== 'object' || !object || Array.isArray(object)) {\n        \"production\" !== process.env.NODE_ENV ? warning(false, 'React.addons.createFragment only accepts a single object.', object) : null;\n        return object;\n      }\n      if (ReactElement.isValidElement(object)) {\n        \"production\" !== process.env.NODE_ENV ? warning(false, 'React.addons.createFragment does not accept a ReactElement ' + 'without a wrapper object.') : null;\n        return object;\n      }\n      if (canWarnForReactFragment) {\n        var proxy = {};\n        Object.defineProperty(proxy, fragmentKey, {\n          enumerable: false,\n          value: object\n        });\n        Object.defineProperty(proxy, didWarnKey, {\n          writable: true,\n          enumerable: false,\n          value: false\n        });\n        for (var key in object) {\n          proxyPropertyAccessWithWarning(proxy, key);\n        }\n        Object.preventExtensions(proxy);\n        return proxy;\n      }\n    }\n    return object;\n  },\n  // Extract the original keyed object from the fragment opaque type. Warn if\n  // a plain object is passed here.\n  extract: function (fragment) {\n    if (\"production\" !== process.env.NODE_ENV) {\n      if (canWarnForReactFragment) {\n        if (!fragment[fragmentKey]) {\n          \"production\" !== process.env.NODE_ENV ? warning(didWarnForFragment(fragment), 'Any use of a keyed object should be wrapped in ' + 'React.addons.createFragment(object) before being passed as a ' + 'child.') : null;\n          return fragment;\n        }\n        return fragment[fragmentKey];\n      }\n    }\n    return fragment;\n  },\n  // Check if this is a fragment and if so, extract the keyed object. If it\n  // is a fragment-like object, warn that it should be wrapped. Ignore if we\n  // can't determine what kind of object this is.\n  extractIfFragment: function (fragment) {\n    if (\"production\" !== process.env.NODE_ENV) {\n      if (canWarnForReactFragment) {\n        // If it is the opaque type, return the keyed object.\n        if (fragment[fragmentKey]) {\n          return fragment[fragmentKey];\n        }\n        // Otherwise, check each property if it has an element, if it does\n        // it is probably meant as a fragment, so we can warn early. Defer,\n        // the warning to extract.\n        for (var key in fragment) {\n          if (fragment.hasOwnProperty(key) && ReactElement.isValidElement(fragment[key])) {\n            // This looks like a fragment object, we should provide an\n            // early warning.\n            return ReactFragment.extract(fragment);\n          }\n        }\n      }\n    }\n    return fragment;\n  }\n};\nmodule.exports = ReactFragment;","map":{"version":3,"names":["ReactElement","require","warning","process","env","NODE_ENV","fragmentKey","didWarnKey","canWarnForReactFragment","dummy","Object","defineProperty","enumerable","value","get","x","proxyPropertyAccessWithWarning","obj","key","set","issuedWarnings","didWarnForFragment","fragment","fragmentCacheKey","alreadyWarnedOnce","ReactFragment","create","object","Array","isArray","isValidElement","proxy","writable","preventExtensions","extract","extractIfFragment","hasOwnProperty","module","exports"],"sources":["C:/Users/raffy/Desktop/test/Synth/Synth/node_modules/react-embedded-browser/node_modules/react/lib/ReactFragment.js"],"sourcesContent":["/**\n * Copyright 2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n* @providesModule ReactFragment\n*/\n\n'use strict';\n\nvar ReactElement = require(\"./ReactElement\");\n\nvar warning = require(\"./warning\");\n\n/**\n * We used to allow keyed objects to serve as a collection of ReactElements,\n * or nested sets. This allowed us a way to explicitly key a set a fragment of\n * components. This is now being replaced with an opaque data structure.\n * The upgrade path is to call React.addons.createFragment({ key: value }) to\n * create a keyed fragment. The resulting data structure is opaque, for now.\n */\n\nif (\"production\" !== process.env.NODE_ENV) {\n  var fragmentKey = '_reactFragment';\n  var didWarnKey = '_reactDidWarn';\n  var canWarnForReactFragment = false;\n\n  try {\n    // Feature test. Don't even try to issue this warning if we can't use\n    // enumerable: false.\n\n    var dummy = function() {\n      return 1;\n    };\n\n    Object.defineProperty(\n      {},\n      fragmentKey,\n      {enumerable: false, value: true}\n    );\n\n    Object.defineProperty(\n      {},\n      'key',\n      {enumerable: true, get: dummy}\n    );\n\n    canWarnForReactFragment = true;\n  } catch (x) { }\n\n  var proxyPropertyAccessWithWarning = function(obj, key) {\n    Object.defineProperty(obj, key, {\n      enumerable: true,\n      get: function() {\n        (\"production\" !== process.env.NODE_ENV ? warning(\n          this[didWarnKey],\n          'A ReactFragment is an opaque type. Accessing any of its ' +\n          'properties is deprecated. Pass it to one of the React.Children ' +\n          'helpers.'\n        ) : null);\n        this[didWarnKey] = true;\n        return this[fragmentKey][key];\n      },\n      set: function(value) {\n        (\"production\" !== process.env.NODE_ENV ? warning(\n          this[didWarnKey],\n          'A ReactFragment is an immutable opaque type. Mutating its ' +\n          'properties is deprecated.'\n        ) : null);\n        this[didWarnKey] = true;\n        this[fragmentKey][key] = value;\n      }\n    });\n  };\n\n  var issuedWarnings = {};\n\n  var didWarnForFragment = function(fragment) {\n    // We use the keys and the type of the value as a heuristic to dedupe the\n    // warning to avoid spamming too much.\n    var fragmentCacheKey = '';\n    for (var key in fragment) {\n      fragmentCacheKey += key + ':' + (typeof fragment[key]) + ',';\n    }\n    var alreadyWarnedOnce = !!issuedWarnings[fragmentCacheKey];\n    issuedWarnings[fragmentCacheKey] = true;\n    return alreadyWarnedOnce;\n  };\n}\n\nvar ReactFragment = {\n  // Wrap a keyed object in an opaque proxy that warns you if you access any\n  // of its properties.\n  create: function(object) {\n    if (\"production\" !== process.env.NODE_ENV) {\n      if (typeof object !== 'object' || !object || Array.isArray(object)) {\n        (\"production\" !== process.env.NODE_ENV ? warning(\n          false,\n          'React.addons.createFragment only accepts a single object.',\n          object\n        ) : null);\n        return object;\n      }\n      if (ReactElement.isValidElement(object)) {\n        (\"production\" !== process.env.NODE_ENV ? warning(\n          false,\n          'React.addons.createFragment does not accept a ReactElement ' +\n          'without a wrapper object.'\n        ) : null);\n        return object;\n      }\n      if (canWarnForReactFragment) {\n        var proxy = {};\n        Object.defineProperty(proxy, fragmentKey, {\n          enumerable: false,\n          value: object\n        });\n        Object.defineProperty(proxy, didWarnKey, {\n          writable: true,\n          enumerable: false,\n          value: false\n        });\n        for (var key in object) {\n          proxyPropertyAccessWithWarning(proxy, key);\n        }\n        Object.preventExtensions(proxy);\n        return proxy;\n      }\n    }\n    return object;\n  },\n  // Extract the original keyed object from the fragment opaque type. Warn if\n  // a plain object is passed here.\n  extract: function(fragment) {\n    if (\"production\" !== process.env.NODE_ENV) {\n      if (canWarnForReactFragment) {\n        if (!fragment[fragmentKey]) {\n          (\"production\" !== process.env.NODE_ENV ? warning(\n            didWarnForFragment(fragment),\n            'Any use of a keyed object should be wrapped in ' +\n            'React.addons.createFragment(object) before being passed as a ' +\n            'child.'\n          ) : null);\n          return fragment;\n        }\n        return fragment[fragmentKey];\n      }\n    }\n    return fragment;\n  },\n  // Check if this is a fragment and if so, extract the keyed object. If it\n  // is a fragment-like object, warn that it should be wrapped. Ignore if we\n  // can't determine what kind of object this is.\n  extractIfFragment: function(fragment) {\n    if (\"production\" !== process.env.NODE_ENV) {\n      if (canWarnForReactFragment) {\n        // If it is the opaque type, return the keyed object.\n        if (fragment[fragmentKey]) {\n          return fragment[fragmentKey];\n        }\n        // Otherwise, check each property if it has an element, if it does\n        // it is probably meant as a fragment, so we can warn early. Defer,\n        // the warning to extract.\n        for (var key in fragment) {\n          if (fragment.hasOwnProperty(key) &&\n              ReactElement.isValidElement(fragment[key])) {\n            // This looks like a fragment object, we should provide an\n            // early warning.\n            return ReactFragment.extract(fragment);\n          }\n        }\n      }\n    }\n    return fragment;\n  }\n};\n\nmodule.exports = ReactFragment;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}