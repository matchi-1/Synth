{"ast":null,"code":"/**\n * Copyright 2014-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactChildReconciler\n * @typechecks static-only\n */\n\n'use strict';\n\nvar ReactReconciler = require(\"./ReactReconciler\");\nvar flattenChildren = require(\"./flattenChildren\");\nvar instantiateReactComponent = require(\"./instantiateReactComponent\");\nvar shouldUpdateReactComponent = require(\"./shouldUpdateReactComponent\");\n\n/**\n * ReactChildReconciler provides helpers for initializing or updating a set of\n * children. Its output is suitable for passing it onto ReactMultiChild which\n * does diffed reordering and insertion.\n */\nvar ReactChildReconciler = {\n  /**\n   * Generates a \"mount image\" for each of the supplied children. In the case\n   * of `ReactDOMComponent`, a mount image is a string of markup.\n   *\n   * @param {?object} nestedChildNodes Nested child maps.\n   * @return {?object} A set of child instances.\n   * @internal\n   */\n  instantiateChildren: function (nestedChildNodes, transaction, context) {\n    var children = flattenChildren(nestedChildNodes);\n    for (var name in children) {\n      if (children.hasOwnProperty(name)) {\n        var child = children[name];\n        // The rendered children must be turned into instances as they're\n        // mounted.\n        var childInstance = instantiateReactComponent(child, null);\n        children[name] = childInstance;\n      }\n    }\n    return children;\n  },\n  /**\n   * Updates the rendered children and returns a new set of children.\n   *\n   * @param {?object} prevChildren Previously initialized set of children.\n   * @param {?object} nextNestedChildNodes Nested child maps.\n   * @param {ReactReconcileTransaction} transaction\n   * @param {object} context\n   * @return {?object} A new set of child instances.\n   * @internal\n   */\n  updateChildren: function (prevChildren, nextNestedChildNodes, transaction, context) {\n    // We currently don't have a way to track moves here but if we use iterators\n    // instead of for..in we can zip the iterators and check if an item has\n    // moved.\n    // TODO: If nothing has changed, return the prevChildren object so that we\n    // can quickly bailout if nothing has changed.\n    var nextChildren = flattenChildren(nextNestedChildNodes);\n    if (!nextChildren && !prevChildren) {\n      return null;\n    }\n    var name;\n    for (name in nextChildren) {\n      if (!nextChildren.hasOwnProperty(name)) {\n        continue;\n      }\n      var prevChild = prevChildren && prevChildren[name];\n      var prevElement = prevChild && prevChild._currentElement;\n      var nextElement = nextChildren[name];\n      if (shouldUpdateReactComponent(prevElement, nextElement)) {\n        ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);\n        nextChildren[name] = prevChild;\n      } else {\n        if (prevChild) {\n          ReactReconciler.unmountComponent(prevChild, name);\n        }\n        // The child must be instantiated before it's mounted.\n        var nextChildInstance = instantiateReactComponent(nextElement, null);\n        nextChildren[name] = nextChildInstance;\n      }\n    }\n    // Unmount children that are no longer present.\n    for (name in prevChildren) {\n      if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {\n        ReactReconciler.unmountComponent(prevChildren[name]);\n      }\n    }\n    return nextChildren;\n  },\n  /**\n   * Unmounts all rendered children. This should be used to clean up children\n   * when this component is unmounted.\n   *\n   * @param {?object} renderedChildren Previously initialized set of children.\n   * @internal\n   */\n  unmountChildren: function (renderedChildren) {\n    for (var name in renderedChildren) {\n      var renderedChild = renderedChildren[name];\n      ReactReconciler.unmountComponent(renderedChild);\n    }\n  }\n};\nmodule.exports = ReactChildReconciler;","map":{"version":3,"names":["ReactReconciler","require","flattenChildren","instantiateReactComponent","shouldUpdateReactComponent","ReactChildReconciler","instantiateChildren","nestedChildNodes","transaction","context","children","name","hasOwnProperty","child","childInstance","updateChildren","prevChildren","nextNestedChildNodes","nextChildren","prevChild","prevElement","_currentElement","nextElement","receiveComponent","unmountComponent","nextChildInstance","unmountChildren","renderedChildren","renderedChild","module","exports"],"sources":["C:/Users/raffy/Desktop/test/Synth/Synth/node_modules/react-embedded-browser/node_modules/react/lib/ReactChildReconciler.js"],"sourcesContent":["/**\n * Copyright 2014-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactChildReconciler\n * @typechecks static-only\n */\n\n'use strict';\n\nvar ReactReconciler = require(\"./ReactReconciler\");\n\nvar flattenChildren = require(\"./flattenChildren\");\nvar instantiateReactComponent = require(\"./instantiateReactComponent\");\nvar shouldUpdateReactComponent = require(\"./shouldUpdateReactComponent\");\n\n/**\n * ReactChildReconciler provides helpers for initializing or updating a set of\n * children. Its output is suitable for passing it onto ReactMultiChild which\n * does diffed reordering and insertion.\n */\nvar ReactChildReconciler = {\n\n  /**\n   * Generates a \"mount image\" for each of the supplied children. In the case\n   * of `ReactDOMComponent`, a mount image is a string of markup.\n   *\n   * @param {?object} nestedChildNodes Nested child maps.\n   * @return {?object} A set of child instances.\n   * @internal\n   */\n  instantiateChildren: function(nestedChildNodes, transaction, context) {\n    var children = flattenChildren(nestedChildNodes);\n    for (var name in children) {\n      if (children.hasOwnProperty(name)) {\n        var child = children[name];\n        // The rendered children must be turned into instances as they're\n        // mounted.\n        var childInstance = instantiateReactComponent(child, null);\n        children[name] = childInstance;\n      }\n    }\n    return children;\n  },\n\n  /**\n   * Updates the rendered children and returns a new set of children.\n   *\n   * @param {?object} prevChildren Previously initialized set of children.\n   * @param {?object} nextNestedChildNodes Nested child maps.\n   * @param {ReactReconcileTransaction} transaction\n   * @param {object} context\n   * @return {?object} A new set of child instances.\n   * @internal\n   */\n  updateChildren: function(\n    prevChildren,\n    nextNestedChildNodes,\n    transaction,\n    context) {\n    // We currently don't have a way to track moves here but if we use iterators\n    // instead of for..in we can zip the iterators and check if an item has\n    // moved.\n    // TODO: If nothing has changed, return the prevChildren object so that we\n    // can quickly bailout if nothing has changed.\n    var nextChildren = flattenChildren(nextNestedChildNodes);\n    if (!nextChildren && !prevChildren) {\n      return null;\n    }\n    var name;\n    for (name in nextChildren) {\n      if (!nextChildren.hasOwnProperty(name)) {\n        continue;\n      }\n      var prevChild = prevChildren && prevChildren[name];\n      var prevElement = prevChild && prevChild._currentElement;\n      var nextElement = nextChildren[name];\n      if (shouldUpdateReactComponent(prevElement, nextElement)) {\n        ReactReconciler.receiveComponent(\n          prevChild, nextElement, transaction, context\n        );\n        nextChildren[name] = prevChild;\n      } else {\n        if (prevChild) {\n          ReactReconciler.unmountComponent(prevChild, name);\n        }\n        // The child must be instantiated before it's mounted.\n        var nextChildInstance = instantiateReactComponent(\n          nextElement,\n          null\n        );\n        nextChildren[name] = nextChildInstance;\n      }\n    }\n    // Unmount children that are no longer present.\n    for (name in prevChildren) {\n      if (prevChildren.hasOwnProperty(name) &&\n          !(nextChildren && nextChildren.hasOwnProperty(name))) {\n        ReactReconciler.unmountComponent(prevChildren[name]);\n      }\n    }\n    return nextChildren;\n  },\n\n  /**\n   * Unmounts all rendered children. This should be used to clean up children\n   * when this component is unmounted.\n   *\n   * @param {?object} renderedChildren Previously initialized set of children.\n   * @internal\n   */\n  unmountChildren: function(renderedChildren) {\n    for (var name in renderedChildren) {\n      var renderedChild = renderedChildren[name];\n      ReactReconciler.unmountComponent(renderedChild);\n    }\n  }\n\n};\n\nmodule.exports = ReactChildReconciler;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}