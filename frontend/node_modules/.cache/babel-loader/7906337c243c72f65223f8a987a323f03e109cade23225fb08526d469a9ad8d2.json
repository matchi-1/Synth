{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { QueryHandler } from '../common/QueryHandler.js';\nimport { assert } from '../util/assert.js';\nimport { AsyncIterableUtil } from '../util/AsyncIterableUtil.js';\nconst isKnownAttribute = attribute => {\n  return ['name', 'role'].includes(attribute);\n};\n/**\n * The selectors consist of an accessible name to query for and optionally\n * further aria attributes on the form `[<attribute>=<value>]`.\n * Currently, we only support the `name` and `role` attribute.\n * The following examples showcase how the syntax works wrt. querying:\n *\n * - 'title[role=\"heading\"]' queries for elements with name 'title' and role 'heading'.\n * - '[role=\"image\"]' queries for elements with role 'image' and any name.\n * - 'label' queries for elements with name 'label' and any role.\n * - '[name=\"\"][role=\"button\"]' queries for elements with no name and role 'button'.\n */\nconst ATTRIBUTE_REGEXP = /\\[\\s*(?<attribute>\\w+)\\s*=\\s*(?<quote>\"|')(?<value>\\\\.|.*?(?=\\k<quote>))\\k<quote>\\s*\\]/g;\nconst parseARIASelector = selector => {\n  const queryOptions = {};\n  const defaultName = selector.replace(ATTRIBUTE_REGEXP, (_, attribute, __, value) => {\n    assert(isKnownAttribute(attribute), `Unknown aria attribute \"${attribute}\" in selector`);\n    queryOptions[attribute] = value;\n    return '';\n  });\n  if (defaultName && !queryOptions.name) {\n    queryOptions.name = defaultName;\n  }\n  return queryOptions;\n};\n/**\n * @internal\n */\nexport class ARIAQueryHandler extends QueryHandler {\n  static querySelector = async (node, selector, {\n    ariaQuerySelector\n  }) => {\n    return await ariaQuerySelector(node, selector);\n  };\n  static async *queryAll(element, selector) {\n    const {\n      name,\n      role\n    } = parseARIASelector(selector);\n    yield* element.queryAXTree(name, role);\n  }\n  static queryOne = async (element, selector) => {\n    return (await AsyncIterableUtil.first(this.queryAll(element, selector))) ?? null;\n  };\n}","map":{"version":3,"names":["QueryHandler","assert","AsyncIterableUtil","isKnownAttribute","attribute","includes","ATTRIBUTE_REGEXP","parseARIASelector","selector","queryOptions","defaultName","replace","_","__","value","name","ARIAQueryHandler","querySelector","node","ariaQuerySelector","queryAll","element","role","queryAXTree","queryOne","first"],"sources":["C:\\Users\\raffy\\Desktop\\test\\node_modules\\puppeteer-core\\src\\cdp\\AriaQueryHandler.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport type {ElementHandle} from '../api/ElementHandle.js';\nimport {QueryHandler, type QuerySelector} from '../common/QueryHandler.js';\nimport type {AwaitableIterable} from '../common/types.js';\nimport {assert} from '../util/assert.js';\nimport {AsyncIterableUtil} from '../util/AsyncIterableUtil.js';\n\ninterface ARIASelector {\n  name?: string;\n  role?: string;\n}\n\nconst isKnownAttribute = (\n  attribute: string\n): attribute is keyof ARIASelector => {\n  return ['name', 'role'].includes(attribute);\n};\n\n/**\n * The selectors consist of an accessible name to query for and optionally\n * further aria attributes on the form `[<attribute>=<value>]`.\n * Currently, we only support the `name` and `role` attribute.\n * The following examples showcase how the syntax works wrt. querying:\n *\n * - 'title[role=\"heading\"]' queries for elements with name 'title' and role 'heading'.\n * - '[role=\"image\"]' queries for elements with role 'image' and any name.\n * - 'label' queries for elements with name 'label' and any role.\n * - '[name=\"\"][role=\"button\"]' queries for elements with no name and role 'button'.\n */\nconst ATTRIBUTE_REGEXP =\n  /\\[\\s*(?<attribute>\\w+)\\s*=\\s*(?<quote>\"|')(?<value>\\\\.|.*?(?=\\k<quote>))\\k<quote>\\s*\\]/g;\nconst parseARIASelector = (selector: string): ARIASelector => {\n  const queryOptions: ARIASelector = {};\n  const defaultName = selector.replace(\n    ATTRIBUTE_REGEXP,\n    (_, attribute, __, value) => {\n      assert(\n        isKnownAttribute(attribute),\n        `Unknown aria attribute \"${attribute}\" in selector`\n      );\n      queryOptions[attribute] = value;\n      return '';\n    }\n  );\n  if (defaultName && !queryOptions.name) {\n    queryOptions.name = defaultName;\n  }\n  return queryOptions;\n};\n\n/**\n * @internal\n */\nexport class ARIAQueryHandler extends QueryHandler {\n  static override querySelector: QuerySelector = async (\n    node,\n    selector,\n    {ariaQuerySelector}\n  ) => {\n    return await ariaQuerySelector(node, selector);\n  };\n\n  static override async *queryAll(\n    element: ElementHandle<Node>,\n    selector: string\n  ): AwaitableIterable<ElementHandle<Node>> {\n    const {name, role} = parseARIASelector(selector);\n    yield* element.queryAXTree(name, role);\n  }\n\n  static override queryOne = async (\n    element: ElementHandle<Node>,\n    selector: string\n  ): Promise<ElementHandle<Node> | null> => {\n    return (\n      (await AsyncIterableUtil.first(this.queryAll(element, selector))) ?? null\n    );\n  };\n}\n"],"mappings":"AAAA;;;;;AAOA,SAAQA,YAAY,QAA2B,2BAA2B;AAE1E,SAAQC,MAAM,QAAO,mBAAmB;AACxC,SAAQC,iBAAiB,QAAO,8BAA8B;AAO9D,MAAMC,gBAAgB,GACpBC,SAAiB,IACkB;EACnC,OAAO,CAAC,MAAM,EAAE,MAAM,CAAC,CAACC,QAAQ,CAACD,SAAS,CAAC;AAC7C,CAAC;AAED;;;;;;;;;;;AAWA,MAAME,gBAAgB,GACpB,yFAAyF;AAC3F,MAAMC,iBAAiB,GAAIC,QAAgB,IAAkB;EAC3D,MAAMC,YAAY,GAAiB,EAAE;EACrC,MAAMC,WAAW,GAAGF,QAAQ,CAACG,OAAO,CAClCL,gBAAgB,EAChB,CAACM,CAAC,EAAER,SAAS,EAAES,EAAE,EAAEC,KAAK,KAAI;IAC1Bb,MAAM,CACJE,gBAAgB,CAACC,SAAS,CAAC,EAC3B,2BAA2BA,SAAS,eAAe,CACpD;IACDK,YAAY,CAACL,SAAS,CAAC,GAAGU,KAAK;IAC/B,OAAO,EAAE;EACX,CAAC,CACF;EACD,IAAIJ,WAAW,IAAI,CAACD,YAAY,CAACM,IAAI,EAAE;IACrCN,YAAY,CAACM,IAAI,GAAGL,WAAW;EACjC;EACA,OAAOD,YAAY;AACrB,CAAC;AAED;;;AAGA,OAAM,MAAOO,gBAAiB,SAAQhB,YAAY;EAChD,OAAgBiB,aAAa,GAAkB,MAAAA,CAC7CC,IAAI,EACJV,QAAQ,EACR;IAACW;EAAiB,CAAC,KACjB;IACF,OAAO,MAAMA,iBAAiB,CAACD,IAAI,EAAEV,QAAQ,CAAC;EAChD,CAAC;EAED,cAAuBY,QAAQA,CAC7BC,OAA4B,EAC5Bb,QAAgB;IAEhB,MAAM;MAACO,IAAI;MAAEO;IAAI,CAAC,GAAGf,iBAAiB,CAACC,QAAQ,CAAC;IAChD,OAAOa,OAAO,CAACE,WAAW,CAACR,IAAI,EAAEO,IAAI,CAAC;EACxC;EAEA,OAAgBE,QAAQ,GAAG,MAAAA,CACzBH,OAA4B,EAC5Bb,QAAgB,KACuB;IACvC,OACE,CAAC,MAAMN,iBAAiB,CAACuB,KAAK,CAAC,IAAI,CAACL,QAAQ,CAACC,OAAO,EAAEb,QAAQ,CAAC,CAAC,KAAK,IAAI;EAE7E,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}